(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
<<CompiledFunctionTools`


(* ::Input::Initialization:: *)
Print["SuperFlocci V1.0.0.\nAndrew Gomes, Maximillian Ruhdorfer and Joseph Tooby-Smith"];


(* ::Input::Initialization:: *)
Flocci$FunctionList={};
Flocci$FunctionListAdd[str_String]:=Module[{},Flocci$FunctionList=DeleteDuplicates[Append[Flocci$FunctionList,str]]];
Flocci$FunctionListAdd[str_List]:=Map[Flocci$FunctionListAdd,str];
Flocci$SetDescription[name_,{tagT_,inputT_,outputT_,descriptionT_}]:=Module[{},
Flocci$FunctionListAdd[{name}];
ToExpression[name,InputForm,Function[x,Set[MessageName[x,"tag"],tagT],HoldFirst]];
ToExpression[name,InputForm,Function[x,Set[MessageName[x,"input"],inputT],HoldFirst]];
ToExpression[name,InputForm,Function[x,Set[MessageName[x,"output"],outputT],HoldFirst]];
ToExpression[name,InputForm,Function[x,Set[MessageName[x,"description"],descriptionT],HoldFirst]];

];
Flocci$SetDescription[name_,{tagT_,inputT_,outputT_,descriptionT_,clearType_}]:=Module[{},
Flocci$FunctionListAdd[{name}];
ToExpression[name,InputForm,Function[x,Set[MessageName[x,"tag"],tagT],HoldFirst]];
ToExpression[name,InputForm,Function[x,Set[MessageName[x,"input"],inputT],HoldFirst]];
ToExpression[name,InputForm,Function[x,Set[MessageName[x,"output"],outputT],HoldFirst]];
ToExpression[name,InputForm,Function[x,Set[MessageName[x,"description"],descriptionT],HoldFirst]];
ToExpression[name,InputForm,Function[x,Set[MessageName[x,"clear"],clearType],HoldFirst]];
];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$TimeAssociation",{"Timing","-","An association map.","Contains a map with strings as keys, and {time,number of times called} as values for each string."}];
Flocci$SetDescription["Flocci$Timing",{"Timing","str) A string","A function","Ues as <stuff> //Timing //Flocci$Timing[str].  Adds {time,1} to Flocci$TimeAssociation[str] and creates it if need be. Output is the output of  <stuff>, so does not change the working of the function.","3"}]
Flocci$SetDescription["Flocci$TimingReset",{"Timing","-","-","Puts Flocci$TimeAssociation=<||>;"}]
Flocci$SetDescription["Flocci$TimingPrint",{"Timing","-","-","Turns Flocci$TimeAssociation into a list."}]

Flocci$TimeAssociation=<||>;
Flocci$Timing[str_]:=Flocci$Timing[str]=Function[x, x//(If[!(Lookup[Flocci$TimeAssociation,str,False]=== False),Flocci$TimeAssociation[[str]]+={First[#],1},AppendTo[Flocci$TimeAssociation,str-> {First[#],1}]]; Last[#])&] ;
Flocci$TimingReset:=Module[{},Flocci$TimeAssociation=<||>;]
Flocci$TimingPrint:=Transpose[{Keys[Flocci$TimeAssociation],Values[Flocci$TimeAssociation]}];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$AlgAss",{"LieAlg","-","An association map","Assocaites algebra type A with 1, B with 2, ..., G with 7, and U1 with 0."}];
Flocci$SetDescription["Flocci$AlgStandard",{"LieAlg","s) A simple Lie algebra, as a string, or a varible with or without LieArt.","A pair of integers e.g. {1,2}","Standardizes the form of our algebras. The first number (1) is the type of algebra, and the second number (2) is the rank.  "}];
Flocci$AlgAss=<|"A"-> 1,"B"-> 2,"C"-> 3,"D"-> 4,"E"-> 5,"F"-> 6,"G"-> 7,"U"-> 0|>;
Flocci$AlgStandard[s_]:={Lookup[Flocci$AlgAss,StringTake[#,1],1],StringDrop[#,1]//ToExpression} &@If[Head[Head[s]]===Algebra,ToString[Head[s][[1]]]<>ToString[s[[1]]],ToString[s]]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$Rank"}];
Flocci$Rank::input="i) A simple Lie algebra e.g. A1. ii) A semi-simple Lie algebra {A1,A2}."; 
Flocci$Rank::output="i) The rank e.g. 1. ii) The list of ranks e.g. {1,2}.";
Flocci$Rank::description="-";
Flocci$Rank::tag="LieAlg";
Flocci$Rank::clear="4";
Flocci$Rank[s_]:=Flocci$Rank[s]=Flocci$AlgStandard[s][[2]];
Flocci$Rank[g_List]:=Flocci$Rank[g]=Map[Flocci$Rank,g];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$TypeAQ","Flocci$TypeBQ","Flocci$TypeCQ","Flocci$TypeDQ","Flocci$classicalQ","Flocci$TypeG2Q","Flocci$TypeF4Q","Flocci$TypeE6Q","Flocci$TypeE7Q","Flocci$TypeE8Q","Flocci$TypeU1Q"}];
Flocci$TypeAQ::tag="LieAlg";Flocci$TypeAQ::input="s) A simple Lie algebra";Flocci$TypeAQ::output="True or False";
Flocci$TypeAQ::description="Outputs True if algebra is of type A or False otherwise.";

Flocci$TypeBQ::tag="LieAlg";Flocci$TypeBQ::input="s) A simple Lie algebra";Flocci$TypeBQ::output="True or False";
Flocci$TypeBQ::description="Outputs True if algebra is of type B or False otherwise.";

Flocci$TypeCQ::tag="LieAlg";Flocci$TypeCQ::input="s) A simple Lie algebra";Flocci$TypeCQ::output="True or False";
Flocci$TypeCQ::description="Outputs True if algebra is of type C or False otherwise.";

Flocci$TypeDQ::tag="LieAlg";Flocci$TypeDQ::input="s) A simple Lie algebra";Flocci$TypeDQ::output="True or False";
Flocci$TypeDQ::description="Outputs True if algebra is of type D or False otherwise.";

Flocci$TypeG2Q::tag="LieAlg";Flocci$TypeG2Q::input="s) A simple Lie algebra";Flocci$TypeG2Q::output="True or False";
Flocci$TypeG2Q::description="Outputs True if algebra is of type G2 or False otherwise.";

Flocci$TypeF4Q::tag="LieAlg";Flocci$TypeF4Q::input="s) A simple Lie algebra";Flocci$TypeF4Q::output="True or False";
Flocci$TypeF4Q::description="Outputs True if algebra is of type F4 or False otherwise.";

Flocci$TypeE6Q::tag="LieAlg";Flocci$TypeE6Q::input="s) A simple Lie algebra";Flocci$TypeE6Q::output="True or False";
Flocci$TypeE6Q::description="Outputs True if algebra is of type E6 or False otherwise.";

Flocci$TypeE7Q::tag="LieAlg";Flocci$TypeE7Q::input="s) A simple Lie algebra";Flocci$TypeE7Q::output="True or False";
Flocci$TypeE7Q::description="Outputs True if algebra is of type E7 or False otherwise.";

Flocci$TypeE8Q::tag="LieAlg";Flocci$TypeE8Q::input="s) A simple Lie algebra";Flocci$TypeE8Q::output="True or False";
Flocci$TypeE8Q::description="Outputs True if algebra is of type E8 or False otherwise.";

Flocci$TypeU1Q::tag="LieAlg";Flocci$TypeU1Q::input="s) A simple Lie algebra";Flocci$TypeU1Q::output="True or False";
Flocci$TypeU1Q::description="Outputs True if algebra is of type U(1) or False otherwise.";

Flocci$classicalQ::tag="LieAlg";Flocci$classicalQ::input="s) A simple Lie algebra";Flocci$classicalQ::output="True or False";
Flocci$classicalQ::description="Outputs True if algebra is of type A, B, C or D, or False otherwise.";

Flocci$TypeAQ[s_]:=Flocci$AlgStandard[s][[1]]==1;
Flocci$TypeBQ[s_]:=Flocci$AlgStandard[s][[1]]==2;
Flocci$TypeCQ[s_]:=Flocci$AlgStandard[s][[1]]==3;
Flocci$TypeDQ[s_]:=Flocci$AlgStandard[s][[1]]==4;

Flocci$classicalQ[s_]:=(Flocci$TypeAQ[s]||Flocci$TypeBQ[s]||Flocci$TypeCQ[s]||Flocci$TypeDQ[s])

Flocci$TypeG2Q[s_]:=(s===G2);
Flocci$TypeF4Q[s_]:=(s===F4);
Flocci$TypeE6Q[s_]:=(s===E6);
Flocci$TypeE7Q[s_]:=(s===E7);
Flocci$TypeE8Q[s_]:=(s===E8);
Flocci$TypeU1Q[s_]:=(s===U1);


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$CartanMatrix"}];
Flocci$CartanMatrix::tag="LieAlg";
Flocci$CartanMatrix::input="s: simple Lie algebra, e.g. A4"; 
Flocci$CartanMatrix::output="Cartan matrix for s.";
Flocci$CartanMatrix::description="Returns Cartan matrix for s.";
Flocci$CartanMatrix::clear="3";
Flocci$CartanMatrix[s_]:=Flocci$CartanMatrix[s]=Module[{rank},
rank= Flocci$Rank[s];
Which[
Flocci$TypeAQ[s],
If[Flocci$Rank[s]==1,Return[{{2}}],Return[SparseArray[{Band[{1,1}]->2,Band[{1,2}]->-1,Band[{2,1}]->-1},{rank,rank}]//Normal]],
Flocci$TypeBQ[s],
Return[ArrayFlatten[{{SparseArray[{Band[{1,1}]->2,Band[{1,2}]->-1,Band[{2,1}]->-1},{rank-1,rank-1}],0},{0,0}}]+SparseArray[{{rank,rank}-> 2,{rank-1,rank}->-2,{rank,rank-1}->-1},{rank,rank}]//Normal],
Flocci$TypeCQ[s],
If[Flocci$Rank[s]==2,{{2,-1},{-2,2}},Return[ArrayFlatten[{{SparseArray[{Band[{1,1}]->2,Band[{1,2}]->-1,Band[{2,1}]->-1},{rank-1,rank-1}],0},{0,0}}]+SparseArray[{{rank,rank}-> 2,{rank-1,rank}->-1,{rank,rank-1}->-2},{rank,rank}]//Normal]],
Flocci$TypeDQ[s],
Return[ArrayFlatten[{{SparseArray[{Band[{1,1}]->2,Band[{1,2}]->-1,Band[{2,1}]->-1},{rank-2,rank-2}],0},{0,DiagonalMatrix[{2,2}]}}]+SparseArray[{{rank,rank-2}-> -1,{rank-1,rank-2}->-1,{rank-2,rank-1}->-1,{rank-2,rank}->-1},{rank,rank}]//Normal],
Flocci$TypeG2Q[s],
Return[{{2,-1},{-3,2}}],
Flocci$TypeE6Q[s],
Return[{{2,-1,0,0,0,0},{-1,2,-1,0,0,0},{0,-1,2,-1,0,-1},{0,0,-1,2,-1,0},{0,0,0,-1,2,0},{0,0,-1,0,0,2}}],
Flocci$TypeE7Q[s],
Return[{{2,-1,0,0,0,0,0},{-1,2,-1,0,0,0,0},{0,-1,2,-1,0,0,-1},{0,0,-1,2,-1,0,0},{0,0,0,-1,2,-1,0},{0,0,0,0,-1,2,0},{0,0,-1,0,0,0,2}}],
Flocci$TypeE8Q[s],
Return[{{2,-1,0,0,0,0,0,0},{-1,2,-1,0,0,0,0,0},{0,-1,2,-1,0,0,0,-1},{0,0,-1,2,-1,0,0,0},{0,0,0,-1,2,-1,0,0},{0,0,0,0,-1,2,-1,0},{0,0,0,0,0,-1,2,0},{0,0,-1,0,0,0,0,2}}],
Flocci$TypeF4Q[s],
Return[{{2,-1,0,0},{-1,2,-2,0},{0,-1,2,-1},{0,0,-1,2}}]
]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$MetricTensor"}];
Flocci$MetricTensor::tag="LieAlg";
Flocci$MetricTensor::input="s: simple Lie algebra, e.g. A4"; 
Flocci$MetricTensor::output="Metric tensor for s.";
Flocci$MetricTensor::description="Returns Metric tensor for s.";
Flocci$MetricTensor::clear="3";
Flocci$MetricTensor[s_]:=Flocci$MetricTensor[s]=Module[{rank},
(*We take the metric tensors from Table 2 of Dynkin "Semi-simple...".*)
rank= Flocci$Rank[s];
Which[
Flocci$TypeAQ[s],
(*The metric tensor for An have the from:
1/(n+1)...
*)
Return[1/(rank+1) Table[PadRight[Range[i],rank,i],{i,1,rank}]*Table[PadLeft[Reverse[Range[rank+1-i]],rank,rank+1-i],{i,1,rank}]],
Flocci$TypeBQ[s],
Return[1/2*Append[ArrayFlatten@{{2*Table[PadRight[Range[i],rank-1,i],{i,1,rank-1}],Table[{i},{i,1,rank-1}]}},Join[Table[i,{i,1,rank-1}],{rank/2}]]],
Flocci$TypeCQ[s],
Return[1/2 Table[PadRight[Range[i],rank,i],{i,1,rank}]],
Flocci$TypeDQ[s],
Return[1/2*ArrayFlatten[{{2*Table[PadRight[Range[i],rank-2,i],{i,1,rank-2}],Table[{i,i},{i,1,rank-2}]},{Transpose[Table[{i,i},{i,1,rank-2}]],{{rank/2,(rank-2)/2},{(rank-2)/2,rank/2}}}}]],
Flocci$TypeG2Q[s],
Return[{{2/3,1},{1,2}}],
Flocci$TypeE6Q[s],
Return[{{4/3,5/3,2,4/3,2/3,1},{5/3,10/3,4,8/3,4/3,2},{2,4,6,4,2,3},{4/3,8/3,4,10/3,5/3,2},{2/3,4/3,2,5/3,4/3,1},{1,2,3,2,1,2}}],
Flocci$TypeE7Q[s],
Return[{{2,3,4,3,2,1,2},{3,6,8,6,4,2,4},{4,8,12,9,6,3,6},{3,6,9,15/2,5,5/2,9/2},{2,4,6,5,4,2,3},{1,2,3,5/2,2,3/2,3/2},{2,4,6,9/2,3,3/2,7/2}}],
Flocci$TypeE8Q[s],
Return[{{4,7,10,8,6,4,2,5},{7,14,20,16,12,8,4,10},{10,20,30,24,18,12,6,15},{8,16,24,20,15,10,5,12},{6,12,18,15,12,8,4,9},{4,8,12,10,8,6,3,6},{2,4,6,5,4,3,2,3},{5,10,15,12,9,6,3,8}}],
Flocci$TypeF4Q[s],
Return[{{2,3,2,1},{3,6,4,2},{2,4,3,3/2},{1,2,3/2,1}}]
]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$PositiveRootsSB","Flocci$PositiveRoots"}];
Flocci$PositiveRootsSB::tag="LieAlg";
Flocci$PositiveRoots::tag="LieAlg";
Flocci$PositiveRootsSB::input="s: simple Lie algebra, e.g. A4"; 
Flocci$PositiveRootsSB::output="Positive roots in simple root basis.";
Flocci$PositiveRootsSB::description="Returns positive roots in simple root basis {{a1,a2,a3},{a1p,a2p,a3p},...} where {a1,a2,a3} stands for \[IndentingNewLine]           a1*\!\(\*SubscriptBox[\(\[Alpha]\), \(1\)]\) + a2*\!\(\*SubscriptBox[\(\[Alpha]\), \(2\)]\) + a3*\!\(\*SubscriptBox[\(\[Alpha]\), \(3\)]\) with \!\(\*SubscriptBox[\(\[Alpha]\), \(i\)]\) being simple roots.";
Flocci$PositiveRoots::input="s: simple Lie algebra, e.g. A4"; 
Flocci$PositiveRoots::output="Positive roots in fundamental weight basis.";
Flocci$PositiveRoots::description="Returns positive roots in fundamental weight basis given by Flocci$PositiveRootsSB[s].Flocci$CartanMatrix[s].";
Flocci$PositiveRoots::clear="3";
Flocci$PositiveRootsSB[s_]:=Module[{posRoots,rank,\[Alpha],\[Alpha]1,\[Alpha]2,\[Alpha]3},
(* This function returns the positive roots for the simple Lie algebra s in the simple root basis 
  Input:    - s simple Lie algebra in LieArt format of as expression
Output:   - positive roots in simple root basis {{a1,a2,a3},{a1p,a2p,a3p},...} where {a1,a2,a3} stands for 
           a1*Subscript[\[Alpha], 1] + a2*Subscript[\[Alpha], 2] + a3*Subscript[\[Alpha], 3] with Subscript[\[Alpha], i] being simple roots
*)
(* initialize list of positive roots and find rank of algebra *)
posRoots={};
rank=Flocci$Rank[s];
(* Return the corresponding positive roots for the algebra s *)
Which[
Flocci$TypeAQ[s],
Do[
(* The positive roots in terms of the simple roots are of the form (1,0,0,...), (1,1,0,...), ..., (1,1,...,1),(0,1,0,...), (0,1,1,0,...),... *)
\[Alpha]=SparseArray[{i->1},rank];
AppendTo[posRoots,\[Alpha]];
Do[
\[Alpha][[j]]=1;
AppendTo[posRoots,\[Alpha]]
,{j,i+1,rank}]
,{i,1,rank}],
Flocci$TypeBQ[s],
Do[
(* The positive roots in terms of the simple roots are of the form Subscript[\[Alpha], i]+...+Subscript[\[Alpha], j-1], Subscript[\[Alpha], i]+...+Subscript[\[Alpha], j-1]+2Subscript[\[Alpha], j]+...+2Subscript[\[Alpha], n] for 1<=i<j<=n-1 and Subscript[\[Alpha], i]+...+Subscript[\[Alpha], n], 1<=i<n*)
\[Alpha]1=SparseArray[{i->1},rank];
\[Alpha]2=Join[Table[0,{k,1,i-1}],{1},Table[2,{k,i+1,rank}]];
\[Alpha]3=Join[Table[0,{k,1,i-1}],Table[1,{k,i,rank}]];
posRoots=Join[posRoots,{\[Alpha]1,\[Alpha]2,\[Alpha]3}];
Do[
\[Alpha]1[[j]]=1;
\[Alpha]2[[j]]=1;
AppendTo[posRoots,\[Alpha]1];
AppendTo[posRoots,\[Alpha]2];
,{j,i+1,rank-1}]
,{i,1,rank-1}];
AppendTo[posRoots,SparseArray[{rank->1},rank]],
Flocci$TypeCQ[s],
Do[
(* The positive roots in terms of the simple roots are of the form Subscript[\[Alpha], i]+...+Subscript[\[Alpha], j-1], for 1<=i<j<=n and Subscript[\[Alpha], i]+...+Subscript[\[Alpha], j-1]+2Subscript[\[Alpha], j]+...+2Subscript[\[Alpha], n-1]+Subscript[\[Alpha], n], 1<=i<=j<=n*)
\[Alpha]1=SparseArray[{i->1},rank];
\[Alpha]2=Join[Table[0,{k,1,i-1}],Table[2,{k,i,rank-1}],{1}];
posRoots=Join[posRoots,{\[Alpha]1,\[Alpha]2}];
Do[
\[Alpha]1[[j]]=1;
\[Alpha]2[[j-1]]=1;
posRoots=Join[posRoots,{\[Alpha]1,\[Alpha]2}];
,{j,i+1,rank-1}];
\[Alpha]2=Join[Table[0,{k,1,i-1}],Table[1,{k,i,rank}]];
AppendTo[posRoots,\[Alpha]2]
,{i,1,rank-1}];
AppendTo[posRoots,SparseArray[{rank->1},rank]],
Flocci$TypeDQ[s],
Do[
(* The positive roots in terms of the simple roots are of the form Subscript[\[Alpha], i]+...+Subscript[\[Alpha], j-1], for 1<=i<j<=n and (Subscript[\[Alpha], i]+...+Subscript[\[Alpha], n])+(Subscript[\[Alpha], j]+...+Subscript[\[Alpha], n])-(Subscript[\[Alpha], n-1]+Subscript[\[Alpha], n]), 1<=i<j<=n*)
\[Alpha]1=SparseArray[{i->1},rank];
\[Alpha]2=Join[Table[0,{k,1,i-1}],Table[1,{k,i,rank}]]+Join[Table[0,{k,1,i}],Table[1,{k,i+1,rank}]]-SparseArray[{rank-1->1,rank->1},rank];
posRoots=Join[posRoots,{\[Alpha]1,\[Alpha]2}];
Do[
\[Alpha]1[[j]]=1;
\[Alpha]2[[j]]=\[Alpha]2[[j]]-1;
posRoots=Join[posRoots,{\[Alpha]1,\[Alpha]2}];
,{j,i+1,rank-1}];
,{i,1,rank-1}],
s===G2,
posRoots={{3,2},{3,1},{2,1},{1,1},{0,1},{1,0}},
s===E6,
posRoots={{1,2,3,2,1,2},{1,2,3,2,1,1},{1,2,2,2,1,1},{1,2,2,1,1,1},{1,1,2,2,1,1},{0,1,2,2,1,1},{1,2,2,1,0,1},{1,1,2,1,1,1},{0,1,2,1,1,1},{1,1,2,1,0,1},{1,1,1,1,1,1},{0,1,2,1,0,1},{0,1,1,1,1,1},{1,1,1,1,0,1},{1,1,1,1,1,0},{0,1,1,1,0,1},{0,1,1,1,1,0},{0,0,1,1,1,1},{1,1,1,0,0,1},{1,1,1,1,0,0},{0,1,1,0,0,1},{0,1,1,1,0,0},{0,0,1,1,0,1},{0,0,1,1,1,0},{1,1,1,0,0,0},{0,1,1,0,0,0},{0,0,1,0,0,1},{0,0,1,1,0,0},{0,0,0,1,1,0},{1,1,0,0,0,0},{0,1,0,0,0,0},{0,0,1,0,0,0},{0,0,0,0,0,1},{0,0,0,1,0,0},{0,0,0,0,1,0},{1,0,0,0,0,0}},
s===E7,
posRoots={{2,3,4,3,2,1,2},{1,3,4,3,2,1,2},{1,2,4,3,2,1,2},{1,2,3,3,2,1,2},{1,2,3,2,2,1,2},{1,2,3,3,2,1,1},{1,2,3,2,1,1,2},{1,2,3,2,2,1,1},{1,2,3,2,1,0,2},{1,2,3,2,1,1,1},{1,2,2,2,2,1,1},{1,2,3,2,1,0,1},{1,2,2,2,1,1,1},{1,1,2,2,2,1,1},{0,1,2,2,2,1,1},{1,2,2,2,1,0,1},{1,2,2,1,1,1,1},{1,1,2,2,1,1,1},{0,1,2,2,1,1,1},{1,2,2,1,1,0,1},{1,1,2,2,1,0,1},{1,1,2,1,1,1,1},{0,1,2,2,1,0,1},{0,1,2,1,1,1,1},{1,2,2,1,0,0,1},{1,1,2,1,1,0,1},{1,1,1,1,1,1,1},{0,1,2,1,1,0,1},{0,1,1,1,1,1,1},{1,1,2,1,0,0,1},{1,1,1,1,1,0,1},{1,1,1,1,1,1,0},{0,1,2,1,0,0,1},{0,1,1,1,1,0,1},{0,1,1,1,1,1,0},{0,0,1,1,1,1,1},{1,1,1,1,0,0,1},{1,1,1,1,1,0,0},{0,1,1,1,0,0,1},{0,1,1,1,1,0,0},{0,0,1,1,1,0,1},{0,0,1,1,1,1,0},{1,1,1,0,0,0,1},{1,1,1,1,0,0,0},{0,1,1,0,0,0,1},{0,1,1,1,0,0,0},{0,0,1,1,0,0,1},{0,0,1,1,1,0,0},{0,0,0,1,1,1,0},{1,1,1,0,0,0,0},{0,1,1,0,0,0,0},{0,0,1,0,0,0,1},{0,0,1,1,0,0,0},{0,0,0,1,1,0,0},{0,0,0,0,1,1,0},{1,1,0,0,0,0,0},{0,1,0,0,0,0,0},{0,0,1,0,0,0,0},{0,0,0,0,0,0,1},{0,0,0,1,0,0,0},{0,0,0,0,1,0,0},{0,0,0,0,0,1,0},{1,0,0,0,0,0,0}},
s===E8,
posRoots={{2,4,6,5,4,3,2,3},{2,4,6,5,4,3,1,3},{2,4,6,5,4,2,1,3},{2,4,6,5,3,2,1,3},{2,4,6,4,3,2,1,3},{2,4,5,4,3,2,1,3},{2,4,5,4,3,2,1,2},{2,3,5,4,3,2,1,3},{1,3,5,4,3,2,1,3},{2,3,5,4,3,2,1,2},{1,3,5,4,3,2,1,2},{2,3,4,4,3,2,1,2},{1,3,4,4,3,2,1,2},{2,3,4,3,3,2,1,2},{1,3,4,3,3,2,1,2},{1,2,4,4,3,2,1,2},{2,3,4,3,2,2,1,2},{1,3,4,3,2,2,1,2},{1,2,4,3,3,2,1,2},{2,3,4,3,2,1,1,2},{1,3,4,3,2,1,1,2},{1,2,4,3,2,2,1,2},{1,2,3,3,3,2,1,2},{2,3,4,3,2,1,0,2},{1,3,4,3,2,1,0,2},{1,2,4,3,2,1,1,2},{1,2,3,3,2,2,1,2},{1,2,3,3,3,2,1,1},{1,2,4,3,2,1,0,2},{1,2,3,3,2,1,1,2},{1,2,3,2,2,2,1,2},{1,2,3,3,2,2,1,1},{1,2,3,3,2,1,0,2},{1,2,3,2,2,1,1,2},{1,2,3,3,2,1,1,1},{1,2,3,2,2,2,1,1},{1,2,3,2,2,1,0,2},{1,2,3,2,1,1,1,2},{1,2,3,3,2,1,0,1},{1,2,3,2,2,1,1,1},{1,2,2,2,2,2,1,1},{1,2,3,2,1,1,0,2},{1,2,3,2,2,1,0,1},{1,2,3,2,1,1,1,1},{1,2,2,2,2,1,1,1},{1,1,2,2,2,2,1,1},{0,1,2,2,2,2,1,1},{1,2,3,2,1,0,0,2},{1,2,3,2,1,1,0,1},{1,2,2,2,2,1,0,1},{1,2,2,2,1,1,1,1},{1,1,2,2,2,1,1,1},{0,1,2,2,2,1,1,1},{1,2,3,2,1,0,0,1},{1,2,2,2,1,1,0,1},{1,2,2,1,1,1,1,1},{1,1,2,2,2,1,0,1},{1,1,2,2,1,1,1,1},{0,1,2,2,2,1,0,1},{0,1,2,2,1,1,1,1},{1,2,2,2,1,0,0,1},{1,2,2,1,1,1,0,1},{1,1,2,2,1,1,0,1},{1,1,2,1,1,1,1,1},{0,1,2,2,1,1,0,1},{0,1,2,1,1,1,1,1},{1,2,2,1,1,0,0,1},{1,1,2,2,1,0,0,1},{1,1,2,1,1,1,0,1},{1,1,1,1,1,1,1,1},{0,1,2,2,1,0,0,1},{0,1,2,1,1,1,0,1},{0,1,1,1,1,1,1,1},{1,2,2,1,0,0,0,1},{1,1,2,1,1,0,0,1},{1,1,1,1,1,1,0,1},{1,1,1,1,1,1,1,0},{0,1,2,1,1,0,0,1},{0,1,1,1,1,1,0,1},{0,1,1,1,1,1,1,0},{0,0,1,1,1,1,1,1},{1,1,2,1,0,0,0,1},{1,1,1,1,1,0,0,1},{1,1,1,1,1,1,0,0},{0,1,2,1,0,0,0,1},{0,1,1,1,1,0,0,1},{0,1,1,1,1,1,0,0},{0,0,1,1,1,1,0,1},{0,0,1,1,1,1,1,0},{1,1,1,1,0,0,0,1},{1,1,1,1,1,0,0,0},{0,1,1,1,0,0,0,1},{0,1,1,1,1,0,0,0},{0,0,1,1,1,0,0,1},{0,0,1,1,1,1,0,0},{0,0,0,1,1,1,1,0},{1,1,1,0,0,0,0,1},{1,1,1,1,0,0,0,0},{0,1,1,0,0,0,0,1},{0,1,1,1,0,0,0,0},{0,0,1,1,0,0,0,1},{0,0,1,1,1,0,0,0},{0,0,0,1,1,1,0,0},{0,0,0,0,1,1,1,0},{1,1,1,0,0,0,0,0},{0,1,1,0,0,0,0,0},{0,0,1,0,0,0,0,1},{0,0,1,1,0,0,0,0},{0,0,0,1,1,0,0,0},{0,0,0,0,1,1,0,0},{0,0,0,0,0,1,1,0},{1,1,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,0},{0,0,0,0,0,0,0,1},{0,0,0,1,0,0,0,0},{0,0,0,0,1,0,0,0},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0},{1,0,0,0,0,0,0,0}},
s===F4,
posRoots={{2,3,4,2},{1,3,4,2},{1,2,4,2},{1,2,3,2},{1,2,3,1},{1,2,2,2},{1,2,2,1},{1,1,2,2},{0,1,2,2},{1,2,2,0},{1,1,2,1},{0,1,2,1},{1,1,2,0},{1,1,1,1},{0,1,2,0},{0,1,1,1},{1,1,1,0},{0,1,1,0},{0,0,1,1},{1,1,0,0},{0,1,0,0},{0,0,1,0},{0,0,0,1},{1,0,0,0}}
];
Return[Map[Normal,posRoots]];
]
Flocci$PositiveRoots[s_]:=Flocci$PositiveRoots[s]=Flocci$PositiveRootsSB[s].Flocci$CartanMatrix[s](*Positive roots in the fundamental weights basis*)


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$Roots"}];
Flocci$Roots::tag="LieAlg";
Flocci$Roots::input="g: Lie algebra in the format {s1,s2,...}, e.g. {A4}"; 
Flocci$Roots::output="All roots in fundamental weight basis.";
Flocci$Roots::description="Returns all roots in fundamental weight basis for the Lie algebra g.";
Flocci$Roots[g_]:=Module[{ranklist,rootg,roots,zero,s,rootT},
ranklist=Flocci$Rank[g];
roots={};
Do[s=g[[i]];
zero=Map[{ConstantArray[0,#]}&,ranklist];
rootg=Join[List@@@Flocci$PositiveRoots[s],-List@@@Flocci$PositiveRoots[s]];
zero[[i]]=rootg;
rootT=Tuples[zero];
roots=Join[roots,rootT],{i,1,Length[g]}];
Map[Flatten,roots]]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$ScalarProduct"}];
Flocci$ScalarProduct::tag="LieAlg";
Flocci$ScalarProduct::input="s: simple Lie algebra, e.g. A4. \[Lambda]1,\[Lambda]2: weights"; 
Flocci$ScalarProduct::output="Scalar product of \[Lambda]1 and \[Lambda]2 using Flocci$MetricTensor[s].";
Flocci$ScalarProduct::description="Returns the scalar product of \[Lambda]1 and \[Lambda]2.";
Flocci$ScalarProduct[s_][\[Lambda]1_,\[Lambda]2_]:=\[Lambda]1.Flocci$MetricTensor[s].\[Lambda]2;


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$Dim"}];
Flocci$Dim::tag="LieAlg";
Flocci$Dim::input="s) A simple lie algebra or a semi-simple Lie algebra.\n\[Lambda]) The hw of s.";
Flocci$Dim::output="The dimension of the irrep of s defined by \[Lambda].";
Flocci$Dim::description="-";
Flocci$Dim::clear="4";
Flocci$Dim[s_,\[Lambda]_]:=Flocci$Dim[s,\[Lambda]]=Module[{},(*For the dimension of irreps of simple g*)
(* Finds the dimension of the irrep with highest weight \[Lambda] of the algebra alg
   Input:      -s  algebra either in LieArt format or expression
             -\[Lambda]   heighest weight of representation
Output:     - dimension of representation
*)
(* Use the appropriate dimensionality formula for the algebra alg *)
Which[
Flocci$TypeAQ[s],
Return[Flocci$DimAn[s]@@\[Lambda]],
Flocci$TypeBQ[s],
Return[Flocci$DimBn[s]@@\[Lambda]],
Flocci$TypeCQ[s],
Return[Flocci$DimCn[s]@@\[Lambda]],
Flocci$TypeDQ[s],
Return[Flocci$DimDn[s]@@\[Lambda]],
Flocci$TypeG2Q[s],
Return[Flocci$DimG2@@\[Lambda]],
Flocci$TypeE6Q[s],
Return[Flocci$DimE6@@\[Lambda]],
Flocci$TypeE7Q[s],
Return[Flocci$DimE7@@\[Lambda]],
Flocci$TypeE8Q[s],
Return[Flocci$DimE8@@\[Lambda]],
Flocci$TypeF4Q[s],
Return[Flocci$DimF4@@\[Lambda]]
]
]
(*Flocci$Dim[g_List,rep_]:=Sum[Product[Flocci$Dim[g\[LeftDoubleBracket]i\[RightDoubleBracket],ir\[LeftDoubleBracket]i\[RightDoubleBracket]],{i,1,Length[g]}],{ir,rep}] *)
Flocci$Dim[g_List,rep_]:=If[rep=={},
0,
Plus@@Table[Times@@MapThread[Flocci$Dim,{g,ir}],{ir,Transpose[Map[Transpose,TakeList[Transpose[rep],Flocci$Rank[g]]]]}]
];(*for the dimension of representations of semi-simple g*)


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$DimAn"}];
Flocci$DimAn::tag="LieAlg";
Flocci$DimAn::input="s: simple A-type Lie algebra, e.g. A4."; 
Flocci$DimAn::output="Function which takes in heighest weight in returns dimensionality of representation.";
Flocci$DimAn::description="Generates analytic function for dimensionality formula of s representations.";
Flocci$DimAn::clear="3";
Flocci$DimAn[s_]:=Flocci$DimAn[s]=Module[{\[Lambda]p\[Delta],dim,i,j,rank,\[Alpha],arg},
(* Finds the dimensionality formula for the An algebra s 
   Input:   - s simple An algebra
Output   - function with analytic expression of Weyl dimensionality formula *)

(* find rank of algebra by length of highest weight *)
rank=Flocci$Rank[s];
(* Define arguments for function that we return, i.e. general highest weight {a1,a2,...} *)
arg=ToExpression["a" <> ToString[#]] & /@ Range[rank];
(* define \[Lambda] + \[Delta], where \[Delta]=(1,1,...,1) *)
\[Lambda]p\[Delta]=arg+Array[1&,rank];
dim=1;
(* Take product over all positive roots. This implements the algorithm in Section 8.11 of Graaf's book. *)
Do[
(* The positive roots in terms of the simple roots are of the form (1,0,0,...), (1,1,0,...), ..., (1,1,...,1),(0,1,0,...), (0,1,1,0,...),... *)
\[Alpha]=SparseArray[{i->1},rank];
dim=dim*\[Alpha].\[Lambda]p\[Delta];
Do[
\[Alpha][[j]]=1;
dim=dim*\[Alpha].\[Lambda]p\[Delta]/(\[Alpha].\[Alpha]);
,{j,i+1,rank}]
,{i,1,rank}];
(* Return function with analytic form of dimensionality formula *)
Function[Evaluate[arg],Evaluate[dim]]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$DimBn"}];
Flocci$DimBn::tag="LieAlg";
Flocci$DimBn::input="s: simple B-type Lie algebra, e.g. B4."; 
Flocci$DimBn::output="Function which takes in heighest weight in returns dimensionality of representation.";
Flocci$DimBn::description="Generates analytic function for dimensionality formula of s representations.";
Flocci$DimBn::clear="3";
Flocci$DimBn[s_]:=Flocci$DimBn[s]=
Module[{\[Lambda]p\[Delta],dim,i,j,rank,k1,k2,k3,k,arg,metric,\[Alpha]},
(* Finds the dimensionality formula for the Bn algebra s 
   Input:   - s simple Bn algebra
Output   - function with analytic expression of Weyl dimensionality formula *)

(* find rank of algebra by length of highest weight *)
rank=Flocci$Rank[s];
(* Define arguments for function that we return, i.e. general highest weight {a1,a2,...} *)
arg=ToExpression["a" <> ToString[#]] & /@ Range[rank];
(* define \[Lambda] + \[Delta], where \[Delta]=(1,1,...,1) *)
\[Lambda]p\[Delta]=arg+Array[1&,rank];
metric=DiagonalMatrix[Join[Table[2,{k,1,rank-1}],{1}]];
dim=1;
\[Alpha]=ConstantArray[1,rank];
(* Take product over all positive roots. This implements the algorithm in Section 8.11 of Graaf's book. *)
Do[
(* The positive roots in terms of the simple roots are of the form Subscript[\[Alpha], i]+...+Subscript[\[Alpha], j-1], Subscript[\[Alpha], i]+...+Subscript[\[Alpha], j-1]+2Subscript[\[Alpha], j]+...+2Subscript[\[Alpha], n] for 1<=i<j<=n-1 and Subscript[\[Alpha], i]+...+Subscript[\[Alpha], n], 1<=i<n*)
k1=SparseArray[{i->1},rank];
k2=Join[Table[0,{k,1,i-1}],{1},Table[2,{k,i+1,rank}]];
k3=Join[Table[0,{k,1,i-1}],Table[1,{k,i,rank}]];
dim=dim*k1.metric.\[Lambda]p\[Delta]/(k1.metric.\[Alpha]);
dim=dim*k2.metric.\[Lambda]p\[Delta]/(k2.metric.\[Alpha]);
dim=dim*k3.metric.\[Lambda]p\[Delta]/(k3.metric.\[Alpha]);
Do[
k1[[j]]=1;
k2[[j]]=1;
dim=dim*k1.metric.\[Lambda]p\[Delta]/(k1.metric.\[Alpha]);
dim=dim*k2.metric.\[Lambda]p\[Delta]/(k2.metric.\[Alpha]);
,{j,i+1,rank-1}]
,{i,1,rank-1}];
k3=SparseArray[{rank->1},rank];
dim=dim*k3.metric.\[Lambda]p\[Delta]/(k3.metric.\[Alpha]);
(* Return function with analytic form of dimensionality formula *)
Function[Evaluate[arg],Evaluate[dim]]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$DimCn"}];
Flocci$DimCn::tag="LieAlg";
Flocci$DimCn::input="s: simple C-type Lie algebra, e.g. C4."; 
Flocci$DimCn::output="Function which takes in heighest weight in returns dimensionality of representation.";
Flocci$DimCn::description="Generates analytic function for dimensionality formula of s representations.";
Flocci$DimCn::clear="3";
Flocci$DimCn[s_]:=Flocci$DimCn[s]=
Module[{\[Lambda]p\[Delta],dim,i,j,rank,k1,k2,k3,k,metric,\[Alpha],arg},
(* Finds the dimensionality formula for the Cn algebra s 
   Input:   - s simple Cn algebra
Output   - function with analytic expression of Weyl dimensionality formula *)

(* find rank of algebra by length of highest weight *)
rank=Flocci$Rank[s];
(* Define arguments for function that we return, i.e. general highest weight {a1,a2,...} *)
arg=ToExpression["a" <> ToString[#]] & /@ Range[rank];
(* define \[Lambda] + \[Delta], where \[Delta]=(1,1,...,1) *)
\[Lambda]p\[Delta]=arg+Array[1&,rank];
metric=DiagonalMatrix[Join[Table[1,{k,1,rank-1}],{2}]];
dim=1;
\[Alpha]=ConstantArray[1,rank];
(* Take product over all positive roots. This implements the algorithm in Section 8.11 of Graaf's book. *)
Do[
(* The positive roots in terms of the simple roots are of the form Subscript[\[Alpha], i]+...+Subscript[\[Alpha], j-1], for 1<=i<j<=n and Subscript[\[Alpha], i]+...+Subscript[\[Alpha], j-1]+2Subscript[\[Alpha], j]+...+2Subscript[\[Alpha], n-1]+Subscript[\[Alpha], n], 1<=i<=j<=n*)
k1=SparseArray[{i->1},rank];
k2=Join[Table[0,{k,1,i-1}],Table[2,{k,i,rank-1}],{1}];
dim=dim*k1.metric.\[Lambda]p\[Delta]/(k1.metric.\[Alpha]);
dim=dim*k2.metric.\[Lambda]p\[Delta]/(k2.metric.\[Alpha]);
Do[
k1[[j]]=1;
k2[[j-1]]=1;
dim=dim*k1.metric.\[Lambda]p\[Delta]/(k1.metric.\[Alpha]);
dim=dim*k2.metric.\[Lambda]p\[Delta]/(k2.metric.\[Alpha]);
,{j,i+1,rank-1}];
k2=Join[Table[0,{k,1,i-1}],Table[1,{k,i,rank}]];
dim=dim*k2.metric.\[Lambda]p\[Delta]/(k2.metric.\[Alpha]);
,{i,1,rank-1}];
k2=SparseArray[{rank->1},rank];
dim=dim*k2.metric.\[Lambda]p\[Delta]/(k2.metric.\[Alpha]);
(* Return function with analytic form of dimensionality formula *)
Function[Evaluate[arg],Evaluate[dim]]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$DimDn"}];
Flocci$DimDn::tag="LieAlg";
Flocci$DimDn::input="s: simple D-type Lie algebra, e.g. D4."; 
Flocci$DimDn::output="Function which takes in heighest weight in returns dimensionality of representation.";
Flocci$DimDn::description="Generates analytic function for dimensionality formula of s representations.";
Flocci$DimDn::clear="3";
Flocci$DimDn[s_]:=Flocci$DimDn[s]=
Module[{\[Lambda]p\[Delta],dim,i,j,rank,k1,k2,k3,k,metric,\[Alpha],arg},
(* Finds the dimensionality formula for the Dn algebra s 
   Input:   - s simple Dn algebra
Output   - function with analytic expression of Weyl dimensionality formula *)

(* find rank of algebra by length of highest weight *)
rank=Flocci$Rank[s];
(* Define arguments for function that we return, i.e. general highest weight {a1,a2,...} *)
arg=ToExpression["a" <> ToString[#]] & /@ Range[rank];
(* define \[Lambda] + \[Delta], where \[Delta]=(1,1,...,1) *)
\[Lambda]p\[Delta]=arg+Array[1&,rank];

metric=DiagonalMatrix[Table[1,{k,1,rank}]];
dim=1;
\[Alpha]=ConstantArray[1,rank];
(* Take product over all positive roots. This implements the algorithm in Section 8.11 of Graaf's book. *)
Do[
(* The positive roots in terms of the simple roots are of the form Subscript[\[Alpha], i]+...+Subscript[\[Alpha], j-1], for 1<=i<j<=n and (Subscript[\[Alpha], i]+...+Subscript[\[Alpha], n])+(Subscript[\[Alpha], j]+...+Subscript[\[Alpha], n])-(Subscript[\[Alpha], n-1]+Subscript[\[Alpha], n]), 1<=i<j<=n*)
k1=SparseArray[{i->1},rank];
k2=Join[Table[0,{k,1,i-1}],Table[1,{k,i,rank}]]+Join[Table[0,{k,1,i}],Table[1,{k,i+1,rank}]]-SparseArray[{rank-1->1,rank->1},rank];
dim=dim*k1.metric.\[Lambda]p\[Delta]/(k1.metric.\[Alpha]);
dim=dim*k2.metric.\[Lambda]p\[Delta]/(k2.metric.\[Alpha]);
Do[
k1[[j]]=1;
k2[[j]]=k2[[j]]-1;
dim=dim*k1.metric.\[Lambda]p\[Delta]/(k1.metric.\[Alpha]);
dim=dim*k2.metric.\[Lambda]p\[Delta]/(k2.metric.\[Alpha]);
,{j,i+1,rank-1}];
,{i,1,rank-1}];
(* Return function with analytic form of dimensionality formula *)
Function[Evaluate[arg],Evaluate[dim]]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$DimG2"}];
Flocci$DimG2::tag="LieAlg";
Flocci$DimG2::input="a1,a2: highest weight of G2 representation."; 
Flocci$DimG2::output="Dimension of G2 representation with highest weight {a1,a2}.";
Flocci$DimG2::description="Returns dimenions of G2 representation with highest weight {a1,a2}.";

Flocci$DimG2[a1_,a2_]:=
((1+a1)*(1+a2)*(1+a1+3*(1+a2))*(2*(1+a1)+3*(1+a2))*(3*(1+a1)+3*(1+a2))*(3*(1+a1)+6*(1+a2)))/1080


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$DimE6"}];
Flocci$DimE6::tag="LieAlg";
Flocci$DimE6::input="a1,a2,a3,a4,a5,a6: highest weight of E6 representation."; 
Flocci$DimE6::output="Dimension of E6 representation with highest weight {a1,a2,a3,a4,a5,a6}.";
Flocci$DimE6::description="Returns dimenions of E6 representation with highest weight {a1,a2,a3,a4,a5,a6}.";

Flocci$DimE6[a1_,a2_,a3_,a4_,a5_,a6_]:=
((1+a1)*(1+a2)*(2+a1+a2)*(1+a3)*(2+a2+a3)*(3+a1+a2+a3)*(1+a4)*(2+a3+a4)*(3+a2+a3+a4)*(4+a1+a2+a3+a4)*(1+a5)*(2+a4+a5)*(3+a3+a4+a5)*(4+a2+a3+a4+a5)*(5+a1+a2+a3+a4+a5)*(1+a6)*(2+a3+a6)*(3+a2+a3+a6)*(4+a1+a2+a3+a6)*(3+a3+a4+a6)*(4+a2+a3+a4+a6)*(5+a1+a2+a3+a4+a6)*(3+a2+2*(1+a3)+a4+a6)*(4+a1+a2+2*(1+a3)+a4+a6)*(3+a1+2*(1+a2)+2*(1+a3)+a4+a6)*(4+a3+a4+a5+a6)*(5+a2+a3+a4+a5+a6)*(6+a1+a2+a3+a4+a5+a6)*(4+a2+2*(1+a3)+a4+a5+a6)*(5+a1+a2+2*(1+a3)+a4+a5+a6)*(4+a1+2*(1+a2)+2*(1+a3)+a4+a5+a6)*(3+a2+2*(1+a3)+2*(1+a4)+a5+a6)*(4+a1+a2+2*(1+a3)+2*(1+a4)+a5+a6)*(3+a1+2*(1+a2)+2*(1+a3)+2*(1+a4)+a5+a6)*(3+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+a6)*(2+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+2*(1+a6)))/23361421521715200000


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$DimE7"}];
Flocci$DimE7::tag="LieAlg";
Flocci$DimE7::input="a1,a2,a3,a4,a5,a6,a7: highest weight of E7 representation."; 
Flocci$DimE7::output="Dimension of E7 representation with highest weight {a1,a2,a3,a4,a5,a6,a7}.";
Flocci$DimE7::description="Returns dimenions of E7 representation with highest weight {a1,a2,a3,a4,a5,a6,a7}.";

Flocci$DimE7[a1_,a2_,a3_,a4_,a5_,a6_,a7_]:=
((1+a1)*(1+a2)*(2+a1+a2)*(1+a3)*(2+a2+a3)*(3+a1+a2+a3)*(1+a4)*(2+a3+a4)*(3+a2+a3+a4)*(4+a1+a2+a3+a4)*(1+a5)*(2+a4+a5)*(3+a3+a4+a5)*(4+a2+a3+a4+a5)*(5+a1+a2+a3+a4+a5)*(1+a6)*(2+a5+a6)*(3+a4+a5+a6)*(4+a3+a4+a5+a6)*(5+a2+a3+a4+a5+a6)*(6+a1+a2+a3+a4+a5+a6)*(1+a7)*(2+a3+a7)*(3+a2+a3+a7)*(4+a1+a2+a3+a7)*(3+a3+a4+a7)*(4+a2+a3+a4+a7)*(5+a1+a2+a3+a4+a7)*(3+a2+2*(1+a3)+a4+a7)*(4+a1+a2+2*(1+a3)+a4+a7)*(3+a1+2*(1+a2)+2*(1+a3)+a4+a7)*(4+a3+a4+a5+a7)*(5+a2+a3+a4+a5+a7)*(6+a1+a2+a3+a4+a5+a7)*(4+a2+2*(1+a3)+a4+a5+a7)*(5+a1+a2+2*(1+a3)+a4+a5+a7)*(4+a1+2*(1+a2)+2*(1+a3)+a4+a5+a7)*(3+a2+2*(1+a3)+2*(1+a4)+a5+a7)*(4+a1+a2+2*(1+a3)+2*(1+a4)+a5+a7)*(3+a1+2*(1+a2)+2*(1+a3)+2*(1+a4)+a5+a7)*(3+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+a7)*(5+a3+a4+a5+a6+a7)*(6+a2+a3+a4+a5+a6+a7)*(7+a1+a2+a3+a4+a5+a6+a7)*(5+a2+2*(1+a3)+a4+a5+a6+a7)*(6+a1+a2+2*(1+a3)+a4+a5+a6+a7)*(5+a1+2*(1+a2)+2*(1+a3)+a4+a5+a6+a7)*(4+a2+2*(1+a3)+2*(1+a4)+a5+a6+a7)*(5+a1+a2+2*(1+a3)+2*(1+a4)+a5+a6+a7)*(4+a1+2*(1+a2)+2*(1+a3)+2*(1+a4)+a5+a6+a7)*(4+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+a6+a7)*(3+a2+2*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a7)*(4+a1+a2+2*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a7)*(3+a1+2*(1+a2)+2*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a7)*(3+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a7)*(3+a1+2*(1+a2)+3*(1+a3)+3*(1+a4)+2*(1+a5)+a6+a7)*(2+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+2*(1+a7))*(3+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+a6+2*(1+a7))*(2+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+2*(1+a5)+a6+2*(1+a7))*(2+a1+2*(1+a2)+3*(1+a3)+3*(1+a4)+2*(1+a5)+a6+2*(1+a7))*(2+a1+2*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+a6+2*(1+a7))*(2+a1+3*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+a6+2*(1+a7))*(1+2*(1+a1)+3*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+a6+2*(1+a7)))/19403468278119790545603479218421760000000000


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$DimE8"}];
Flocci$DimE8::tag="LieAlg";
Flocci$DimE8::input="a1,a2,a3,a4,a5,a6,a7,a8: highest weight of E8 representation."; 
Flocci$DimE8::output="Dimension of E8 representation with highest weight {a1,a2,a3,a4,a5,a6,a7,a8}.";
Flocci$DimE8::description="Returns dimenions of E8 representation with highest weight {a1,a2,a3,a4,a5,a6,a7,a8}.";

Flocci$DimE8[a1_,a2_,a3_,a4_,a5_,a6_,a7_,a8_]:=
((1+a1)*(1+a2)*(2+a1+a2)*(1+a3)*(2+a2+a3)*(3+a1+a2+a3)*(1+a4)*(2+a3+a4)*(3+a2+a3+a4)*(4+a1+a2+a3+a4)*(1+a5)*(2+a4+a5)*(3+a3+a4+a5)*(4+a2+a3+a4+a5)*(5+a1+a2+a3+a4+a5)*(1+a6)*(2+a5+a6)*(3+a4+a5+a6)*(4+a3+a4+a5+a6)*(5+a2+a3+a4+a5+a6)*(6+a1+a2+a3+a4+a5+a6)*(1+a7)*(2+a6+a7)*(3+a5+a6+a7)*(4+a4+a5+a6+a7)*(5+a3+a4+a5+a6+a7)*(6+a2+a3+a4+a5+a6+a7)*(7+a1+a2+a3+a4+a5+a6+a7)*(1+a8)*(2+a3+a8)*(3+a2+a3+a8)*(4+a1+a2+a3+a8)*(3+a3+a4+a8)*(4+a2+a3+a4+a8)*(5+a1+a2+a3+a4+a8)*(3+a2+2*(1+a3)+a4+a8)*(4+a1+a2+2*(1+a3)+a4+a8)*(3+a1+2*(1+a2)+2*(1+a3)+a4+a8)*(4+a3+a4+a5+a8)*(5+a2+a3+a4+a5+a8)*(6+a1+a2+a3+a4+a5+a8)*(4+a2+2*(1+a3)+a4+a5+a8)*(5+a1+a2+2*(1+a3)+a4+a5+a8)*(4+a1+2*(1+a2)+2*(1+a3)+a4+a5+a8)*(3+a2+2*(1+a3)+2*(1+a4)+a5+a8)*(4+a1+a2+2*(1+a3)+2*(1+a4)+a5+a8)*(3+a1+2*(1+a2)+2*(1+a3)+2*(1+a4)+a5+a8)*(3+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+a8)*(5+a3+a4+a5+a6+a8)*(6+a2+a3+a4+a5+a6+a8)*(7+a1+a2+a3+a4+a5+a6+a8)*(5+a2+2*(1+a3)+a4+a5+a6+a8)*(6+a1+a2+2*(1+a3)+a4+a5+a6+a8)*(5+a1+2*(1+a2)+2*(1+a3)+a4+a5+a6+a8)*(4+a2+2*(1+a3)+2*(1+a4)+a5+a6+a8)*(5+a1+a2+2*(1+a3)+2*(1+a4)+a5+a6+a8)*(4+a1+2*(1+a2)+2*(1+a3)+2*(1+a4)+a5+a6+a8)*(4+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+a6+a8)*(3+a2+2*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a8)*(4+a1+a2+2*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a8)*(3+a1+2*(1+a2)+2*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a8)*(3+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a8)*(3+a1+2*(1+a2)+3*(1+a3)+3*(1+a4)+2*(1+a5)+a6+a8)*(6+a3+a4+a5+a6+a7+a8)*(7+a2+a3+a4+a5+a6+a7+a8)*(8+a1+a2+a3+a4+a5+a6+a7+a8)*(6+a2+2*(1+a3)+a4+a5+a6+a7+a8)*(7+a1+a2+2*(1+a3)+a4+a5+a6+a7+a8)*(6+a1+2*(1+a2)+2*(1+a3)+a4+a5+a6+a7+a8)*(5+a2+2*(1+a3)+2*(1+a4)+a5+a6+a7+a8)*(6+a1+a2+2*(1+a3)+2*(1+a4)+a5+a6+a7+a8)*(5+a1+2*(1+a2)+2*(1+a3)+2*(1+a4)+a5+a6+a7+a8)*(5+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+a6+a7+a8)*(4+a2+2*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a7+a8)*(5+a1+a2+2*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a7+a8)*(4+a1+2*(1+a2)+2*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a7+a8)*(4+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a7+a8)*(4+a1+2*(1+a2)+3*(1+a3)+3*(1+a4)+2*(1+a5)+a6+a7+a8)*(3+a2+2*(1+a3)+2*(1+a4)+2*(1+a5)+2*(1+a6)+a7+a8)*(4+a1+a2+2*(1+a3)+2*(1+a4)+2*(1+a5)+2*(1+a6)+a7+a8)*(3+a1+2*(1+a2)+2*(1+a3)+2*(1+a4)+2*(1+a5)+2*(1+a6)+a7+a8)*(3+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+2*(1+a5)+2*(1+a6)+a7+a8)*(3+a1+2*(1+a2)+3*(1+a3)+3*(1+a4)+2*(1+a5)+2*(1+a6)+a7+a8)*(3+a1+2*(1+a2)+3*(1+a3)+3*(1+a4)+3*(1+a5)+2*(1+a6)+a7+a8)*(2+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+2*(1+a8))*(3+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+a6+2*(1+a8))*(2+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+2*(1+a5)+a6+2*(1+a8))*(2+a1+2*(1+a2)+3*(1+a3)+3*(1+a4)+2*(1+a5)+a6+2*(1+a8))*(2+a1+2*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+a6+2*(1+a8))*(2+a1+3*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+a6+2*(1+a8))*(1+2*(1+a1)+3*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+a6+2*(1+a8))*(4+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+a5+a6+a7+2*(1+a8))*(3+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+2*(1+a5)+a6+a7+2*(1+a8))*(3+a1+2*(1+a2)+3*(1+a3)+3*(1+a4)+2*(1+a5)+a6+a7+2*(1+a8))*(3+a1+2*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+a6+a7+2*(1+a8))*(3+a1+3*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+a6+a7+2*(1+a8))*(2+2*(1+a1)+3*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+a6+a7+2*(1+a8))*(2+a1+2*(1+a2)+3*(1+a3)+2*(1+a4)+2*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(2+a1+2*(1+a2)+3*(1+a3)+3*(1+a4)+2*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(2+a1+2*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(2+a1+3*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(1+2*(1+a1)+3*(1+a2)+4*(1+a3)+3*(1+a4)+2*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(2+a1+2*(1+a2)+3*(1+a3)+3*(1+a4)+3*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(2+a1+2*(1+a2)+4*(1+a3)+3*(1+a4)+3*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(2+a1+3*(1+a2)+4*(1+a3)+3*(1+a4)+3*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(1+2*(1+a1)+3*(1+a2)+4*(1+a3)+3*(1+a4)+3*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(2+a1+2*(1+a2)+4*(1+a3)+4*(1+a4)+3*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(2+a1+3*(1+a2)+4*(1+a3)+4*(1+a4)+3*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(1+2*(1+a1)+3*(1+a2)+4*(1+a3)+4*(1+a4)+3*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(2+a1+3*(1+a2)+5*(1+a3)+4*(1+a4)+3*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(1+2*(1+a1)+3*(1+a2)+5*(1+a3)+4*(1+a4)+3*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(1+2*(1+a1)+4*(1+a2)+5*(1+a3)+4*(1+a4)+3*(1+a5)+2*(1+a6)+a7+2*(1+a8))*(2+a1+3*(1+a2)+5*(1+a3)+4*(1+a4)+3*(1+a5)+2*(1+a6)+a7+3*(1+a8))*(1+2*(1+a1)+3*(1+a2)+5*(1+a3)+4*(1+a4)+3*(1+a5)+2*(1+a6)+a7+3*(1+a8))*(1+2*(1+a1)+4*(1+a2)+5*(1+a3)+4*(1+a4)+3*(1+a5)+2*(1+a6)+a7+3*(1+a8))*(1+2*(1+a1)+4*(1+a2)+6*(1+a3)+4*(1+a4)+3*(1+a5)+2*(1+a6)+a7+3*(1+a8))*(1+2*(1+a1)+4*(1+a2)+6*(1+a3)+5*(1+a4)+3*(1+a5)+2*(1+a6)+a7+3*(1+a8))*(1+2*(1+a1)+4*(1+a2)+6*(1+a3)+5*(1+a4)+4*(1+a5)+2*(1+a6)+a7+3*(1+a8))*(1+2*(1+a1)+4*(1+a2)+6*(1+a3)+5*(1+a4)+4*(1+a5)+3*(1+a6)+a7+3*(1+a8))*(2*(1+a1)+4*(1+a2)+6*(1+a3)+5*(1+a4)+4*(1+a5)+3*(1+a6)+2*(1+a7)+3*(1+a8)))/12389761771281087987161913865011039548629176646031786340025309566313679656889905840128000000000000000000000


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$DimF4"}];
Flocci$DimF4::tag="LieAlg";
Flocci$DimF4::input="a1,a2,a3,a4: highest weight of F4 representation."; 
Flocci$DimF4::output="Dimension of F4 representation with highest weight {a1,a2,a3,a4}.";
Flocci$DimF4::description="Returns dimenions of F4 representation with highest weight {a1,a2,a3,a4}.";

Flocci$DimF4[a1_,a2_,a3_,a4_]:=
((1+a1)*(1+a2)*(2*(1+a1)+2*(1+a2))*(1+a3)*(1+2*(1+a2)+a3)*(1+2*(1+a1)+2*(1+a2)+a3)*(2*(1+a2)+2*(1+a3))*(2*(1+a1)+2*(1+a2)+2*(1+a3))*(2*(1+a1)+4*(1+a2)+2*(1+a3))*(1+a4)*(2+a3+a4)*(2+2*(1+a2)+a3+a4)*(2+2*(1+a1)+2*(1+a2)+a3+a4)*(1+2*(1+a2)+2*(1+a3)+a4)*(1+2*(1+a1)+2*(1+a2)+2*(1+a3)+a4)*(1+2*(1+a1)+4*(1+a2)+2*(1+a3)+a4)*(1+2*(1+a1)+4*(1+a2)+3*(1+a3)+a4)*(2*(1+a2)+2*(1+a3)+2*(1+a4))*(2*(1+a1)+2*(1+a2)+2*(1+a3)+2*(1+a4))*(2*(1+a1)+4*(1+a2)+2*(1+a3)+2*(1+a4))*(2*(1+a1)+4*(1+a2)+3*(1+a3)+2*(1+a4))*(2*(1+a1)+4*(1+a2)+4*(1+a3)+2*(1+a4))*(2*(1+a1)+6*(1+a2)+4*(1+a3)+2*(1+a4))*(4*(1+a1)+6*(1+a2)+4*(1+a3)+2*(1+a4)))/24721080975360000


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$Order",{"LieAlg","s)A simple Lie algebra.","An integer.","Outputs the dimension of the adjoint irrep."}];
Flocci$Order[s_]:=2*Length[Flocci$PositiveRoots[s]]+Flocci$Rank[s]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$DynkinIndex",{"LieAlg","s)A simple Lie algebra.\n \[Lambda]) The highest weight of an irrep ","An integer.","Outputs the dimension of the adjoint irrep."}];
Flocci$DynkinIndex[s_,\[Lambda]_]:=Module[{\[Rho]2,dim\[Lambda],ord},
\[Rho]2=Total[Flocci$PositiveRoots[s]];
dim\[Lambda]=Flocci$Dim[s,\[Lambda]];
ord=Flocci$Order[s];
dim\[Lambda]/(2 ord) Flocci$ScalarProduct[s][\[Lambda],\[Lambda]+\[Rho]2]
];


(* ::Input::Initialization:: *)
(*NOTE: some functions in this section are modifications of LieART functions*)

Flocci$FunctionListAdd[{"Flocci$InverseTransposeCartanMatrix","Flocci$SingleDominantWeightSystem","Flocci$XisAndMul","Flocci$PartialOrbit","Flocci$Reflect","Flocci$ReflectToDominantWeight","Flocci$DominantWeightMultiplicities","Flocci$WeightSystem","Flocci$WeightSystemFromFlat","Flocci$WeightSystemSorted"}];
Flocci$InverseTransposeCartanMatrix::tag="Weights";
Flocci$SingleDominantWeightSystem::tag="Weights";
Flocci$XisAndMul::tag="Weights";
Flocci$PartialOrbit::tag="Weights";
Flocci$Reflect::tag="Weights";
Flocci$ReflectToDominantWeight::tag="Weights";
Flocci$DominantWeightMultiplicities::tag="Weights";
Flocci$WeightSystem::tag="Weights";
Flocci$WeightSystemFromFlat::tag="Weights";
Flocci$WeightSystemSorted::tag="Weights";

Flocci$InverseTransposeCartanMatrix::input="g: simple Lie algebra, e.g. A4"; 
Flocci$InverseTransposeCartanMatrix::output="Inversed, transposed Cartan matrix";
Flocci$InverseTransposeCartanMatrix::description="Inversed, transposed Cartan matrix";Flocci$InverseTransposeCartanMatrix::clear="3";Flocci$InverseTransposeCartanMatrix[g_]:=Flocci$InverseTransposeCartanMatrix[g]=Flocci$CartanMatrix[g]//Transpose//Inverse;

Flocci$SingleDominantWeightSystem::input="g: simple Lie algebra, e.g. A4\nhw: a highest weight, e.g. {1,0,0,0}"; 
Flocci$SingleDominantWeightSystem::output="The dominant weight system without multiplicities, for the highest weight of a simple Lie algebra";
Flocci$SingleDominantWeightSystem::description="Works by recursively subtracting positive roots from the highest weight, deleting duplicates";
Flocci$SingleDominantWeightSystem[g_,hw_] :=
SortBy[
NestWhile[
Function[{prev,curr},
{Join[prev,curr],DeleteDuplicates[Complement[Flatten[
Function[weight,Select[(weight-#)&/@Flocci$PositiveRoots[g], AllTrue[#,NonNegative]&]]/@curr,(*from each new weight, subtract all positive roots, keep only if dominant*)
1],prev,curr]](*delete if alread produced, then delete duplicates within new list*)}
]//Apply,
{{},{hw}},#[[2]]!={}&][[1]],
-Total[Flocci$InverseTransposeCartanMatrix[g].#]&];(*produce weights, ordered by level*)

Flocci$XisAndMul::input="g: simple Lie algebra, e.g. A4\nt: vector of positions specifying a partial orbit"; 
Flocci$XisAndMul::output="List of pairs of the form {partial orbit representative, orbit size factor}";
Flocci$XisAndMul::description="Modified from a LieART function";
Flocci$XisAndMul[g_, t_] := Function[xi,
{xi,If[Complement[Position[Flocci$MetricTensor[g].xi, _?Positive], t]=={}, 1, 2] Length[Flocci$PartialOrbit[g,xi, Extract[Flocci$CartanMatrix[g], t]]]}
] /@ Select[Flocci$PositiveRoots[g],AllTrue[Extract[#, t],NonNegative]&];(*returns a list of the pair: {partial orbit representative,orbit size factor}*)

Flocci$PartialOrbit::input="g: simple Lie algebra, e.g. A4\nweight: a weight\nsimpleRoots: a subset of the simple roots of g"; 
Flocci$PartialOrbit::output="A list of weights";
Flocci$PartialOrbit::description="Finds the orbit of a weight generated by a set of simple roots. Reflects recursively.";
Flocci$PartialOrbit[g_,weight_, simpleRoots_] :=
        NestWhile[
Function[{prev,curr},
{Join[prev,curr],DeleteDuplicates[Complement[Flatten[Outer[Flocci$Reflect[g],curr,simpleRoots,1],1],prev,curr]]}
]//Apply,
{{},{weight}},#[[2]]!={}&][[1]];(*orbits the weight using only the given simple roots, recursively reflecting only those weights that have not yet been reflected (for efficiency), and deleting duplicates/those weights already produced*)

Flocci$Reflect::input="g: simple Lie algebra, e.g. A4\nweight: a weight\nroot: a root of g"; 
Flocci$Reflect::output="A weight";
Flocci$Reflect::description="Reflects the weight about the root";
Flocci$Reflect[g_][weight_,root_]:=weight - 2 Flocci$ScalarProduct[g][weight, root]/Flocci$ScalarProduct[g][root, root] root;

Flocci$ReflectToDominantWeight::input="g: simple Lie algebra, e.g. A4\nweight: a weight"; 
Flocci$ReflectToDominantWeight::output="A dominant weight";
Flocci$ReflectToDominantWeight::description="Recursively reflect about simple roots until a dominant weight is obtained";
Flocci$ReflectToDominantWeight[g_,weight_]:=
NestWhile[
Flocci$Reflect[g][#,Extract[Flocci$CartanMatrix[g],FirstPosition[#,_?Negative]]]&,
weight,!AllTrue[#,NonNegative]&];(*recursively choose simple root used to reflect weight by looking for first negative coordinate of weight*)

Flocci$DominantWeightMultiplicities::input="g: simple Lie algebra, e.g. A4\ndominantWeights: list of dominant weights"; 
Flocci$DominantWeightMultiplicities::output="a list of pairs {dominant weight, multiplicity}";
Flocci$DominantWeightMultiplicities::description="Modified from a LieART function. See the Modified Freundenthal's formula in Graaf Lie Algebras Theory and Algorithms for description.";
Flocci$DominantWeightMultiplicities[g_,dominantWeights_]:=Module[{delta},
delta=ConstantArray[1,Flocci$Rank[g]];
Fold[
Function[{prevWithMult,curr},
Append[prevWithMult,
{curr,
Total[Apply[Function[{root,mul},
mul Total[(Flocci$ScalarProduct[g][#[[1]],root]#[[2]])&/@NestWhileList[{(#[[1]]+root),FirstCase[prevWithMult,{Flocci$ReflectToDominantWeight[g,#[[1]]+root],xx_}:>xx,0]}&,{curr,-1},(#[[2]]!=0)&][[2;;-2]]]
]]/@Flocci$XisAndMul[g,Position[curr,0]]
]/(Flocci$ScalarProduct[g][dominantWeights[[1]]+delta,dominantWeights[[1]]+delta]-Flocci$ScalarProduct[g][curr+delta, curr+delta])}(*see the modified Freundenthal's formula in Graaf*)
]
],
{{dominantWeights[[1]],1}},dominantWeights[[2;;]]](*create list by folding dominant weight into growing list of weights with mult*)
];(*produce the list of pairs {domWeight, multiplicity}*)

Flocci$WeightSystem::input="g: simple or semi-simple Lie algebra\nhw/hws: a highest weight or a list of them if semi-simple"; 
Flocci$WeightSystem::output="A list of weights, in general with duplicates";
Flocci$WeightSystem::description="Produces the full weight system of a Lie algebra. First by producing the dominant weight system without multiplicities, then calculating multiplicities, and finally reflecting to produce the whole weight system.";
Flocci$WeightSystem::clear="4"; 
Flocci$WeightSystem[g_,hw_]:=Flocci$WeightSystem[g,hw]=SortBy[Flatten[
Apply[Function[{domWeight,mult},
ConstantArray[Flocci$PartialOrbit[g,domWeight,Flocci$CartanMatrix[g]],mult]
]]/@Flocci$DominantWeightMultiplicities[g,Flocci$SingleDominantWeightSystem[g,hw]],
2] ,-Total[Flocci$InverseTransposeCartanMatrix[g].#]&];(*produce list of weights, in general with duplicates*)

Flocci$WeightSystem[g_List,hws_]:=If[Length[g]==1,Flocci$WeightSystem[g[[1]],hws[[1]]],Flatten[Outer@@Join[{Join},MapThread[Flocci$WeightSystem,{g,hws}],{1}],Length[g]-1]];(*takes list of simple algebras and list of each hw*)

Flocci$WeightSystemFromFlat::input="g: semi-simple Lie algebra, e.g. {A4,A1}\nhw: a single semi-simple highest weight (with commensurate ordering), e.g. {1,0,0,0,1}"; 
Flocci$WeightSystemFromFlat::output="A list of weights, in general with duplicates";
Flocci$WeightSystemFromFlat::description="Produces the full weight system of a Lie algebra. First by producing the dominant weight system without multiplicities, then calculating multiplicities, and finally reflecting to produce the whole weight system.";
Flocci$WeightSystemFromFlat[g_List,hw_]:=If[Length[g]==1,Flocci$WeightSystem[g[[1]],hw],Flatten[Outer@@Join[{Join},MapThread[Flocci$WeightSystem,{g,TakeList[hw,Flocci$Rank[g]]}],{1}],Length[g]-1]];(*takes list of simple algebras and a single semisimple hw*)

(*
Flocci$SemiSimpleWeightSystem[g_,hws_]:=Flatten[Outer@@Join[{Join},MapThread[Flocci$WeightSystem,{g,hws}],{1}],1];

(*The below takes in a semi-simple g, and a single hw*)
Flocci$FlatSemiSimpleWeightSystem[g_,hw_]:=Flatten[Outer@@Join[{Join},MapThread[Flocci$WeightSystem,{g,TakeList[hw,Flocci$Rank[g]]}],{1}],1];
(*takes flattened semisimple hw*)
*)

(*weightSystemSemiIR2[g_,hw_]:=weightSystemSemiIR2[g,hw]=Flocci$FlatSemiSimpleWeightSystem[g,hw]//Sort;*)
(*weightSystemSimpleIR2[g_,irrep_]:=weightSystemSimpleIR2[g,irrep]=List@@@WeightSystem[Irrep[AlgebraClass[g]]@@irrep]//Sort;*)
(*weightSystemSemiIR2[g_,irrep_]:=weightSystemSemiIR2[g,irrep]=Flatten/@(MapThread[weightSystemSimpleIR2,{g,TakeList[irrep,Flocci$Rank[g]]}]//Tuples//Sort);*)
Flocci$WeightSystemSorted::input="g: semi-simple Lie algebra"; 
Flocci$WeightSystemSorted::output="A weight system";
Flocci$WeightSystemSorted::description="Sorts the weight system produced by Flocci$WeightSystemFromFlat";
Flocci$WeightSystemSorted::clear="3"; 
Flocci$WeightSystemSorted[g_,irrep_]:=(*Flocci$WeightSystemSorted[g,irrep]=*)Flocci$WeightSystemFromFlat[g,irrep]//Sort;


(* ::Input::Initialization:: *)
(*We make some weight system functions that utilize the u(1)'s*)
Flocci$WeightSystemU1::tag="Weights";
Flocci$WeightSystemFromFlatU1::tag="Weights";

Flocci$WeightSystemU1::input="g: simple or semi-simple Lie algebra OR U1\nhw: a highest weight or a list of them if semi-simple"; 
Flocci$WeightSystemU1::output="A list of weights, in general with duplicates";
Flocci$WeightSystemU1::description="Returns highest weight if U1, otherwise call Flocci$WeightSystem";
Flocci$WeightSystemU1[g_,hw_]:=If[g===U1,{hw},Flocci$WeightSystem[g,hw]];

Flocci$WeightSystemFromFlatU1::input="g: list of algebras, can accommodate U1 factors\nhw: a flattened highest weight"; 
Flocci$WeightSystemFromFlatU1::output="A list of weights, in general with duplicates";
Flocci$WeightSystemFromFlatU1::description="See Flocci$WeightSystemFromFlat and Flocci$WeightSystemU1";
Flocci$WeightSystemFromFlatU1[g_List,hw_]:=If[Length[g]==1,Flocci$WeightSystemU1[g[[1]],hw],Flatten[Outer@@Join[{Join},MapThread[Flocci$WeightSystemU1,{g,TakeList[hw,Flocci$Rank[g]]}],{1}],Length[g]-1]];



(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$ExtractDominantWeights",{"LieAlg","list) An integer 2-tensor.","An integer 2-tensor","Outputs the rows of list which have non-negative entries."}];
Flocci$ExtractDominantWeights=Compile[{{list,_Integer,2}},Block[{bool},
Select[list,(bool=True;Do[If[p<0,bool=False;Break[];],{p,#}]; bool)&]//Sort]
,CompilationTarget->"C"];
CompilePrint[Flocci$ExtractDominantWeights];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$WeightSystemU1","Flocci$WeightSystemFromFlatU1"}];
Flocci$SetDescription["Flocci$ExtractHighestWeights",{"LieAlg","g) A reductive Lie algebra (with U1's at the end).\n \[CapitalPhi]t) A integer 2-tensor of weights.","False or an Integer 2-tensor of highest weights","If \[CapitalPhi]t is a valid weight system of g, then it outputs the highest weights. Else outputs False."}];
Flocci$ExtractHighestWeights[g_,\[CapitalPhi]t_]:=Module[{\[Delta],\[Delta]CP,\[CapitalPhi]sort,hw,\[CapitalPhi]hw,pos,hwlist,noU1s},
(*We count the number of U(1)'s assumed the be at the end.*)
noU1s=Count[g,U1];
(*Firstly we find the weight \[Delta], and a normalized version there-of.*)
\[Delta]=Flatten[Table[If[s===U1,Nothing,Flocci$MetricTensor[s].ConstantArray[1,Flocci$Rank[s]]],{s,g}]];
\[Delta]CP=Join[\[Delta]/GCD@@\[Delta],ConstantArray[0,noU1s]];

(*We sort \[CapitalPhi] based on the projection*)
\[CapitalPhi]sort=SortBy[\[CapitalPhi]t,#.\[Delta]CP &];
hwlist={};
While[Length[\[CapitalPhi]sort]!= 0,
hw=\[CapitalPhi]sort[[-1]];
If[AnyTrue[Take[hw,{1,-1-noU1s}],#<0 &],Return[False]];
AppendTo[hwlist,hw];
\[CapitalPhi]hw=Flocci$WeightSystemFromFlatU1[g,hw];
Do[
pos=Position[\[CapitalPhi]sort,wi];
If[Length[pos]==0,Return[False]];
\[CapitalPhi]sort=Delete[\[CapitalPhi]sort,pos[[1]]];
,{wi,\[CapitalPhi]hw}];
];
hwlist
]
Flocci$ExtractHighestWeights[{A2,U1},Join[Flocci$WeightSystemFromFlatU1[{A2,U1},{1,0,-3}],Flocci$WeightSystemFromFlatU1[{A2,U1},{1,2,-4}]]]
Flocci$ExtractHighestWeights[{A2,U1},{{1,0,-3},{-1,1,-3},{0,-1,-2}}]


(* ::Input::Initialization:: *)

Flocci$SetDescription["Flocci$HighestWeightMultiplicity",{"LieAlg","projWSIn) A weight system of the parent projected under \[CapitalLambda].\ndelta)Flocci$SSNode$DeltaCoprime of the child.\n\[Beta]multIn)Flocci$SSNode$HWsMult of the child.\n\[Beta]uniFlat) Flocci$SSNode$UniHWs of the child.\n\[Beta]uniWSFlat) Flocci$SSNode$UniIrrepDominFlat of the child.\nrange) Flocci$SSNode$UniIrrepDominRange of the child.","A integer 1-tensor.","The multiplicities of each hw in Flocci$SSNode$UniHWs within the rep projWS. If projWS does not branch correctly, we output {-1,-1,...}."  }];
Flocci$HighestWeightMultiplicity=Compile[{{projWSIn,_Integer,2},{delta,_Integer,1},{\[Beta]multIn,_Integer,1},{\[Beta]uniFlat,_Integer,2},{\[Beta]uniWSFlat,_Integer,2},{range,_Integer,2}},
Block[{projWS,pos,irrepMult,\[Beta]mult,indexedSort,posList},
indexedSort=projWSIn.delta//Ordering;
projWS=projWSIn[[indexedSort]];
\[Beta]mult=\[Beta]multIn;
irrepMult=ConstantArray[0,Length[\[Beta]mult]];
While[Length[projWS]!=0,
pos=Position[\[Beta]uniFlat,Last[projWS]];
If[Length[pos]==0||\[Beta]mult[[pos[[1,1]]]]==irrepMult[[pos[[1,1]]]],irrepMult=ConstantArray[-1,Length[\[Beta]mult]];Break[];,
(*posList=Table[Position[projWS,\[Beta]uniWSFlat\[LeftDoubleBracket]wi\[RightDoubleBracket]]\[LeftDoubleBracket]1\[RightDoubleBracket],{wi,range\[LeftDoubleBracket]pos\[LeftDoubleBracket]1,1\[RightDoubleBracket],1\[RightDoubleBracket],range\[LeftDoubleBracket]pos\[LeftDoubleBracket]1,1\[RightDoubleBracket],2\[RightDoubleBracket]}];
projWS=Delete[projWS,posList];*)
Do[projWS=Delete[projWS,Position[projWS,\[Beta]uniWSFlat[[wi]]][[1]]],{wi,range[[pos[[1,1]],1]],range[[pos[[1,1]],2]]}];
irrepMult[[pos[[1,1]]]]++;
];
];
irrepMult
]
,CompilationTarget->"C",Parallelization->True];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$TensorProduct",{"LieAlg","g) A semi-simple Lie algebra.\n \[Lambda]1) The highest weight of a single irrep of g.\n \[Lambda]2) The highest weight of a single irrep of g.","A 2-tensor of integers.","Outputs the highest weights of the tensor product rep of \[Lambda]1 and \[Lambda]2."}];

Flocci$TensorProduct[g_,\[Lambda]1_,\[Lambda]2_]:=Module[{ws1,ws2,plus},
ws1=Flocci$WeightSystemFromFlat[g,\[Lambda]1];
ws2=Flocci$WeightSystemFromFlat[g,\[Lambda]2];
plus=Flatten[Outer[Plus,ws1,ws2,1],1];
Flocci$ExtractHighestWeights[g,plus]
]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$ACCs",{"LieAlg","g) A semi-simple Lie algebra.\n hws) A list of highest weights of  g.\n abstractU1s) A 2-tensor, where each row is a U(1) charge.","A 1-vector","Outputs the anomaly cancleation conditions for g+u(1)+...+u(1) with the given (possibly abstract) u(1) charges."}];
Flocci$ACCs[g_,hws_,abstractU1s_]:=Module[{parthws,dimL,dynkinL,coeffg2u1,eqsg2u1,coeffgrav,eqsgrav,u1u1u1,tripleEq},
(*Here n is the number of u(1)'s*)
(*We first make a list of charges of the right size*)
(*abstractU1s=Array[x,{n,Length[hws]}];*)
(*We partition the hws, and find there dimenisions and dynkin indices.*)
parthws=Map[TakeList[#,Flocci$Rank[g]]&,hws];
dimL=Table[Flocci$Dim[g[[i]],\[Lambda][[i]]],{\[Lambda],parthws},{i,1,Length[g]}];
dynkinL=Table[Flocci$DynkinIndex[g[[i]],\[Lambda][[i]]],{\[Lambda],parthws},{i,1,Length[g]}];
(*We find the g^2u(1) anomaly  equations*)
coeffg2u1=Table[Product[If[i!= k, dimL[[j,k]],dynkinL[[j,k]]],{k,1,Length[g]}],{i,1,Length[g]},{j,1,Length[hws]}];
eqsg2u1=coeffg2u1.Transpose[abstractU1s];
(*We find the gravitational anomaly equations*)
coeffgrav=Table[Product[ dimL[[j,k]],{k,1,Length[g]}],{j,1,Length[hws]}];
eqsgrav={coeffgrav}.Transpose[abstractU1s];
(*We find the u(1)^3 anomalies *)
u1u1u1=Map[Times@@#&,Tuples[abstractU1s,3]]//DeleteDuplicates;
tripleEq=coeffgrav.Transpose[u1u1u1];
(*We combine all the equations*)
DeleteDuplicates[Flatten[Join[tripleEq,eqsgrav,eqsg2u1]]]
];
Flocci$ACCs[{A2,A1},{{1,0,1},{0,1,1},{0,1,1}},{{-1,-1,2}}]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$AnomalyFreeSemiSimple",{"LieAlg","g) A semi-simple Lie algebra.\n hws) A list of highest weights of  g.","A 1-vector","Outputs the values of the anomaly equations for the semi-simple repesentation determined by the highest weights hws."}];
Flocci$AnomalyFreeSemiSimple[g_,hws_]:=Module[{gtake,dimlist,AnomList},
gtake=Map[Transpose,TakeList[Transpose[hws],Flocci$Rank[g]]];
dimlist=Map[Length[Flocci$WeightSystemSorted[g,#]]&,hws];
AnomList=Table[If[Flocci$TypeAQ[g[[i]]]&&!(g[[i]]===A1), Flocci$AnomCoeffCompiled[gtake[[i]],dimlist],ConstantArray[0,Length[dimlist]]],{i,1,Length[g]}]//Transpose;
DeleteDuplicates[Map[Total,Transpose[AnomList]]]
]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$AnomalyFreeCheck",{"LieAlg","g) A reductive Lie algebra.\n hws) A 2-integer tensor of highest weights of  g.","True or False","Outputs True if the rep determined by hws is free of local anomalies, outputs false otherwise."}];
Flocci$AnomalyFreeCheck[g_,hws_]:=Module[{u1positions,gSS,hwsSS,u1List,boolSemiSimple,boolU1},
(*We first find the u1 positions*)
u1positions=Position[g,_?(Flocci$TypeU1Q[#]&)];
(*We do a quckier check if there are no u1s*)
If[Length[u1positions]==0, Return[Flocci$AnomalyFreeSemiSimple[g,hws]=={0}]];
(*We get the semi-simple part*)
gSS=Delete[g,u1positions];
hwsSS=Map[Flatten[Delete[TakeList[#,Flocci$Rank[g]],u1positions]]&,hws];
(*We get the u1 list of charges*)
u1List=Map[Flatten[TakeList[#,Flocci$Rank[g]][[Flatten[u1positions]]]]&,hws]//Transpose;
(*We test the semi-simple part*)
boolSemiSimple=Flocci$AnomalyFreeSemiSimple[gSS,hwsSS]=={0};
(*We test the U(1) part*)
boolU1=Flocci$ACCs[gSS,hwsSS,u1List]=={0};
(*We output the final result*)
boolSemiSimple&&boolU1
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$AnomCoeffCompiled"}];
Flocci$AnomCoeffCompiled::tag="LieAlg";
Flocci$AnomCoeffCompiled::input="hws: highest weights. dims: dimensions of representations with heighest weights in hws."; 
Flocci$AnomCoeffCompiled::output="anomaly coefficient.";
Flocci$AnomCoeffCompiled::description="Returns anomaly coefficient for representation with heighest weight in hws with dimensions in dims.";

Flocci$AnomCoeffCompiled=Compile[{{hws,_Integer,2},{dims,_Integer,1}},
Block[{totVal,n,\[Beta]i},
n=Length[hws[[1]]]+1;
Table[
\[Beta]i=hws[[i]];
totVal=Sum[i*(n-2 i) (n-i) (\[Beta]i[[i]]+1) (\[Beta]i[[i]]+1) (\[Beta]i[[i]]+1),{i,1,n-1}];
Do[totVal+=3*Sum[i*(n-2 i) (n-j) (\[Beta]i[[i]]+1) (\[Beta]i[[i]]+1) (\[Beta]i[[j]]+1),{j,i+1,n-1}]+3*Sum[i*(n-2 j) (n-j) (\[Beta]i[[i]]+1) (\[Beta]i[[j]]+1) (\[Beta]i[[j]]+1),{j,i+1,n-1}];
Do[totVal+=6*Sum[i*(n-2 j) (n-k) (\[Beta]i[[i]]+1) (\[Beta]i[[j]]+1) (\[Beta]i[[k]]+1),{k,j+1,n-1}];,{j,i+1,n-1}];,{i,1,n-1}];
dims[[i]]*totVal
,{i,1,Length[hws]}]
]
,CompilationTarget->"C",Parallelization->True];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$SimpleIrrepsWithDim"}];
Flocci$SimpleIrrepsWithDim::tag="LieAlg";
Flocci$SimpleIrrepsWithDim::input="alg: A simple Lie algebra.\nmaxDim: An natural number representating the maximum dimension.";
Flocci$SimpleIrrepsWithDim::output="A list of hws of reps of alg of dimension<maxDim.";
Flocci$SimpleIrrepsWithDim::description="Finds the highest weights of representations of g of dimension less then maxDim.";
Flocci$SimpleIrrepsWithDim::clear="3";
Flocci$SimpleIrrepsWithDim[alg_,maxDim_]:=Flocci$SimpleIrrepsWithDim[alg,maxDim]=Module[{counter,a,dim,n},
(*Outputs list of the double {dim, {hw}} eg. list of {3, {{1,0}} } *)
n=Flocci$Rank[alg];
counter=Table[0,n];
Reap[
While[True,(*must be true for base (0,..,0) case*)
dim=Flocci$Dim[alg,counter];
If[dim<=maxDim,
Sow[{dim,{counter}}];counter[[1]]++;,
a=FirstPosition[counter,xx_/;xx!=0][[1]];If[a==n,Break[],counter[[a]]=0;counter[[a+1]]++;]
];
];
][[2,1]]
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$IrrepSimplePower"}];
Flocci$IrrepSimplePower::tag="LieAlg";
Flocci$IrrepSimplePower::input="g: A simple Lie algebra\nn: An natural number representating the the power of that simple factor.\ndim: Natural number representing dimension\nlocalA1Dim: Natural number indicating the total dimension of reps that are non-trivial only under A1 factors for the problem at hand (12 in SM+rh\[Nu])";
Flocci$IrrepSimplePower::output="A list of hws of reps of g^n of dimension<dim.";
Flocci$IrrepSimplePower::description="Finds the highest weights of representations of g^n of dimension less then dim.";
Flocci$IrrepSimplePower::clear="3";
Flocci$IrrepSimplePower[g_,n_,dim_,localA1Dim_]:=Flocci$IrrepSimplePower[g,n,dim,localA1Dim]=Module[{dimp},
(*Outputs list of the double {dim, hw} eg. list of {9, {{1,0},{1,0}} } *)

(*If the algebra A1dim dimensions solely in su(2) factors, and A1dim\[LessEqual]dim/3, then only need to go up to dim/3, since reps of su(2) cannot decompose into non-trivial reps of other algebras.*)
dimp=If[g===SU2,Max[Floor[dim/3],localA1Dim],dim];
If[n==1,
Flocci$SimpleIrrepsWithDim[g,dimp],
Select[Function[{tup1,tup2},{tup1[[1]]tup2[[1]],Join[tup1[[2]],tup2[[2]]]}]@@@Tuples[{Flocci$IrrepSimplePower[g,n-1,dim,localA1Dim],Flocci$SimpleIrrepsWithDim[g,dimp]}],Function[xx,xx[[1]]<=dimp]]
](*dont put semicolon here!*)
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$IrrepsLessThenOrEqualDim"}];
Flocci$IrrepsLessThenOrEqualDim::tag="LieAlg";
Flocci$IrrepsLessThenOrEqualDim::input="g: A semi-simple Lie algebra e.g. {A1,A10}.\ndim: An natural number representating the dimension.\nlocalA1Dim: Natural number indicating the total dimension of reps that are non-trivial only under A1 factors for the problem at hand (12 in SM+rh\[Nu]). If localA1Dim=dim it has no effect.";
Flocci$IrrepsLessThenOrEqualDim::output="A list of hws of reps of g of dimension<dim.";
Flocci$IrrepsLessThenOrEqualDim::description="Finds the highest weights of representations of g of dimension less then dim.";
Flocci$IrrepsLessThenOrEqualDim::clear="3";
Flocci$IrrepsLessThenOrEqualDim[g_,dim_,localA1Dim_]:=Flocci$IrrepsLessThenOrEqualDim[g,dim,localA1Dim]=Block[{hw1,simplepowerirreps},
(*Outputs list of flattened hw without extra bracket eg. list of {1,0,1,0} *)
simplepowerirreps=Flocci$IrrepSimplePower[#[[1]],Length[#],dim,localA1Dim]&/@Split[g];
hw1=Fold[Select[Function[{tup1,tup2},{tup1[[1]]tup2[[1]],Join[tup1[[2]],tup2[[2]]]}]@@@Tuples[{#1,#2}],Function[xx,xx[[1]]<=dim]]&,simplepowerirreps]//Timing//Flocci$Timing["reps: 1.1"];(*list of the double {dim, hw} eg. list of {9, {{1,0},{1,0}} } *)(*get irreps of simple ideals less than dim (returns irrep's dim and irrep), fold them into irreps of g less than dim*)

(*Eliminate ones that are trivial under non-SU2 but have dim greater than localA1Dim, get rid of dim info.*)
Flatten[#[[2]]]&/@Select[hw1,If[Total[Pick[#[[2]],!(#===SU2)&/@g],2]==0,#[[1]]<= localA1Dim,True]&]//Timing//Flocci$Timing["reps: 1.2"]
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$biE6"}];
Flocci$biE6::tag="Commu";
Flocci$biE6::input="-";
Flocci$biE6::output="The matrix: {{1,0,0,0,0,0},{1,1,0,0,0,0},{0,1,1,1,0,0},{0,0,0,1,1,0},{0,0,0,0,1,0},{0,0,1,0,0,1}}";
Flocci$biE6::description="This corresponds to the matrix bi such that for E6 the 2-cocycle defining commutators is \[Epsilon](\[Lambda]1,\[Lambda]2)=(-1\!\(\*SuperscriptBox[\()\), \(\[Lambda]1 . \*SuperscriptBox[\(ga\), \(T\)] . bi . ga . \[Lambda]2\)]\)";
Flocci$biE6=Module[{bi,orb,orbt,min,ca},
(*Following 3.2.4 of Mitzman*)
ca=Flocci$CartanMatrix[E6];
bi=ConstantArray[0,{6,6}];
orb[i_,j_]:={{i,j},{j,i},{If[i!= 6,6-i,i],If[j!= 6,6-j,j]},{If[j!= 6,6-j,j],If[i!= 6,6-i,i]}};
Do[
If[i!= j,
orbt=orb[i,j];
min=Ordering[orbt][[1]];
If[min==1||min==3,bi[[i,j]]=0];
If[min==2||min==4,bi[[i,j]]=If[(-1)^Flocci$ScalarProduct[E6][ca[[i]],ca[[j]]]==-1,1,0]];
,bi[[i,j]]=1];
,{i,1,6},{j,1,6}];
bi
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$SimplyLacedCommutators"}];
Flocci$SimplyLacedCommutators::tag="Commu";
Flocci$SimplyLacedCommutators::input="A simple Lie algebra s of type A, D or E.";
Flocci$SimplyLacedCommutators::output="A 3-tensor vauled in the integers.";
Flocci$SimplyLacedCommutators::description="See Flocci$Commutators.";

Flocci$SimplyLacedCommutators[s_]:=Module[{rank,bi,orded,ca,ga,Aijk,roots,negaRoots,pos,k},
(*We first get some relevent information about the algebra s*)
rank=Flocci$Rank[s];
ca=Flocci$CartanMatrix[s];
ga=Flocci$MetricTensor[s];
roots=Flocci$Roots[{s}];
negaRoots=Table[Position[roots,-r],{r,roots}]//Flatten;
(*We need to ensure invariance under outer automorphisms of this operators for A with odd rank and D. For this we need to change the ordering for the A case*)
orded=Range[rank];
If[Flocci$TypeAQ[s]&& OddQ[rank],orded={Table[{i,rank+1-i},{i,1,rank/2}],If[OddQ[rank],Floor[rank/2]+1,Nothing]}//Flatten];
(*We next construct the bilinear operator bi. The bilinear operator \[Epsilon](\[Lambda]1,\[Lambda]2)=(-1)^(\[Lambda]1.ga^T.bi.ga.\[Lambda]2) *)
bi=Table[Which[orded[[i]]<orded[[j]],0,i==j,1/2 Flocci$ScalarProduct[s][ca[[i]],ca[[j]]],orded[[i]]>orded[[j]],Flocci$ScalarProduct[s][ca[[i]],ca[[j]]]],{i,1,rank},{j,1,rank}];
If[Flocci$TypeE6Q[s],bi=Flocci$biE6];
(*We construct the tensor Aijk such that [Xi,Xj]=Aijk Xk*)
Aijk=ConstantArray[0,{rank+Length[roots],rank+Length[roots],rank+Length[roots]}];
(*[h\[Lambda]i,e\[Alpha]]=(\[Lambda]i,\[Alpha]) e\[Alpha]*)
Do[
Aijk[[i,rank+k,rank+k]]=Flocci$ScalarProduct[s][ca[[i]],roots[[k]]];
Aijk[[rank+k,i,rank+k]]=-Flocci$ScalarProduct[s][ca[[i]],roots[[k]]];
,{i,1,rank},{k,1,Length[roots]}];
(*[e\[Alpha],e-\[Alpha]]=-h\[Alpha]=-\[Alpha]i hi, where \[Alpha]=\sum \[Alpha]i\[Lambda]i*)
Do[Aijk[[rank+k,rank+negaRoots[[k]],i]]=-(ga.roots[[k]])[[i]],{i,1,rank},{k,1,Length[roots]}];
(*[e\[Lambda]i,e\[Lambda]j]=\[Epsilon](\[Lambda]i,\[Lambda]j) e(\[Lambda]i+\[Lambda]j), where \[Alpha]=\sum \[Alpha]i\[Lambda]i*)
Do[
If[negaRoots[[i]]==j,Continue[]];
pos=Position[roots,roots[[i]]+roots[[j]]]//Flatten;
If[Length[pos]==0,Continue[]];
k=pos[[1]];
Aijk[[i+rank,j+rank,k+rank]]=(-1)^(roots[[i]].Transpose[ga].bi.ga.roots[[j]])
,{i,1,Length[roots]},{j,1,Length[roots]}];
(*The output is Aijk*)
Aijk
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$NonSimplyLacedCommutator"}];
Flocci$NonSimplyLacedCommutator::tag="Commu";
Flocci$NonSimplyLacedCommutator::input="A simple Lie algebra s of type C, B or F.";
Flocci$NonSimplyLacedCommutator::output="A 3-tensor vauled in the integers.";
Flocci$NonSimplyLacedCommutator::description="See Flocci$Commutators.";


Flocci$NonSimplyLacedCommutator[s_]:=Module[{rank,ca,roots,supAlg,\[Sigma],supRank,supca,supga,\[CapitalDelta]0,supRoots,\[CapitalPhi]0,\[Tau],s1,s2,Ch,Ce,t\[Lambda],CeIndex,C,AijkSup,Aijk1,Aijk,Cp,Asupp,AS2,AijkToSolve,LiSol,AijkValues},
(*We get relevent data for our algebra*)
rank=Flocci$Rank[s];
roots=Flocci$Roots[{s}];
ca=Flocci$CartanMatrix[s];
(*We form the sup algebra*)
supAlg=Which[Flocci$TypeCQ[s],ToExpression["A"<>ToString[2rank-1]],Flocci$TypeBQ[s],ToExpression["D"<>ToString[rank+1]],Flocci$TypeF4Q[s],E6];
supRank=Flocci$Rank[supAlg];
supca=Flocci$CartanMatrix[supAlg];
supga=Flocci$MetricTensor[supAlg];
supRoots=Flocci$Roots[{supAlg}];
(*We want to construct the embedding of s into supAlg*)

(*We start by constructing the graph automorphisms of supAlg*)
\[Sigma]=Which[Flocci$TypeCQ[s],supca.Table[If[j==supRank+1-i,1,0],{i,1,supRank},{j,1,supRank}].supga,Flocci$TypeBQ[s],supca.Permute[IdentityMatrix[supRank],Cycles[{{supRank-1,supRank}}]].supga,Flocci$TypeF4Q[s],supca.{{0,0,0,0,1,0},{0,0,0,1,0,0},{0,0,1,0,0,0},{0,1,0,0,0,0},{1,0,0,0,0,0},{0,0,0,0,0,1}}.supga];
(*We form the set Subscript[\[CapitalDelta], [0]]. This is isomorphic to \[CapitalLambda][s]. By thinking about scalar products, it is easty to see that the ordering below gives the correct correspondence*)
\[CapitalDelta]0=Map[1/2 (#+\[Sigma].#)&,supca]//DeleteDuplicates;
If[Flocci$TypeF4Q[s],\[CapitalDelta]0=Reverse[\[CapitalDelta]0]];
(*We form the set Subscript[\[CapitalPhi], [0]]. This is isomorphic to \[CapitalPhi][s]. We keep track of \tilde lambda which forms this entry*)
\[CapitalPhi]0=DeleteDuplicates[Map[{1/2 (#+\[Sigma].#),#}&,supRoots],#1[[1]]==#2[[1]]&];
(*We now want to form the map \[Tau] between root systems*)
s1=Table[Array[a,Length[ca]]/.Solve[Array[a,Length[ca]].ca==r][[1]],{r,roots}];
s2=Table[Array[a,Length[\[CapitalDelta]0]]/.Solve[Array[a,Length[\[CapitalDelta]0]].\[CapitalDelta]0==r[[1]]][[1]],{r,\[CapitalPhi]0}];
\[Tau]=Table[Position[s2,si],{si,s1}]//Flatten;
(*We now construct the change of basis matrix, which we denote C*)
(*For the h's we have Subscript[h, \[Tau](\[Lambda])^v]*)
Ch=Table[Array[a,Length[supca]]/.Solve[Array[a,Length[supca]].supca==(2t\[Lambda])/Flocci$ScalarProduct[supAlg][t\[Lambda],t\[Lambda]]][[1]],{t\[Lambda],\[CapitalDelta]0}];
(*For the e's we have Subscript[e, \[Lambda]]+Subscript[e, \[Sigma].\[Lambda]] if \[Lambda]\[NotEqual] \[Sigma]\[Lambda], or Subscript[e, \[Lambda]] otherwise*)
CeIndex=Flatten[Table[
t\[Lambda]=\[CapitalPhi]0[[\[Tau][[i]],2]];
If[t\[Lambda]== \[Sigma].t\[Lambda],{{i,Flatten[Position[supRoots,t\[Lambda]]][[1]]}-> 1},{{i,Flatten[Position[supRoots,t\[Lambda]]][[1]]}-> 1,{i,Flatten[Position[supRoots,\[Sigma].t\[Lambda]]][[1]]}-> 1}]
,{i,1,Length[roots]}],1];
Ce=SparseArray[CeIndex,{Length[roots],Length[supRoots]}]//Normal;
(*We now construct the full change of basis matrix*)
C={{Ch,0},{0,Ce}}//ArrayFlatten//SparseArray;

(*We construct the commutator matrix based on that of the sup algebra*)
AijkSup=Flocci$SimplyLacedCommutators[supAlg];

(*We want to multiply C\[LeftDoubleBracket]i,i\[Prime]\[RightDoubleBracket] C\[LeftDoubleBracket]j,j\[Prime]\[RightDoubleBracket]AijkSup\[LeftDoubleBracket]i\[Prime],j\[Prime]\[RightDoubleBracket], but will do it by sparse arrays.*)
Asupp=SparseArray[AijkSup]["NonzeroPositions"];
AS2=SparseArray[(Asupp[[All,{1,2}]]//DeleteDuplicates)/. {x_,y_}:> {x,y}-> a[x,y],{Length[AijkSup],Length[AijkSup]}];
Aijk1=C.AS2.Transpose[C];

(*For the third index we need to solve equations*)
AijkToSolve=SparseArray[Aijk1]["NonzeroValues"]/. a[i_,j_]:> AijkSup[[i,j]];
AijkValues=Table[LinearSolve[Transpose[C],AijkToSolve[[i]]],{i,1,Length[AijkToSolve]}];
(*We make the matrix*)
Aijk=ConstantArray[0,{rank+Length[roots],rank+Length[roots],rank+Length[roots]}];
Do[Aijk[[SparseArray[Aijk1]["NonzeroPositions"][[i,1]],SparseArray[Aijk1]["NonzeroPositions"][[i,2]]]]=AijkValues[[i]],{i,1,Length[AijkValues]}];
Aijk
]

Flocci$NonSimplyLacedCommutator[F4]


(* ::Input::Initialization:: *)
(*For G2, we follow Mitzmann page~77. First we need to construct the commutators of D4 based on a special \[Epsilon]. The method here is very similar to the above except we use a order-3 automorphism rather then an order 2-automorphism.*)
Flocci$FunctionListAdd[{"Flocci$CommutatorD4"}];
Flocci$CommutatorD4::tag="Commu";
Flocci$CommutatorD4::input="-";
Flocci$CommutatorD4::output="A specific integer 3-tensor.";
Flocci$CommutatorD4::description="See Flocci$Commutators. Commutator of D4 using a specific \[Epsilon] such that the commutator of G2 can be found. See Mitzmann page 77.";
Flocci$CommutatorD4=Module[{rank,bi,orded,ca,ga,Aijk,roots,negaRoots,pos,k,s},
s=D4;
(*We first get some relevent information about the algebra s*)
rank=Flocci$Rank[s];
ca=Flocci$CartanMatrix[s];
ga=Flocci$MetricTensor[s];
roots=Flocci$Roots[{s}];
negaRoots=Table[Position[roots,-r],{r,roots}]//Flatten;
(*We need to ensure invariance under outer automorphisms of this operators for A with odd rank and D. For this we need to change the ordering for the A case*)
orded=Range[rank];
If[Flocci$TypeAQ[s]&& OddQ[rank],orded={Table[{i,rank+1-i},{i,1,rank/2}],If[OddQ[rank],Floor[rank/2]+1,Nothing]}//Flatten];
(*We next construct the bilinear operator bi. The bilinear operator \[Epsilon](\[Lambda]1,\[Lambda]2)=(-1)^(\[Lambda]1.ga^T.bi.ga.\[Lambda]2) *)
bi={{1,0,0,0},{1,1,1,1},{0,0,1,0},{0,0,0,1}};
(*We construct the tensor Aijk such that [Xi,Xj]=Aijk Xk*)
Aijk=ConstantArray[0,{rank+Length[roots],rank+Length[roots],rank+Length[roots]}];
(*[h\[Lambda]i,e\[Alpha]]=(\[Lambda]i,\[Alpha]) e\[Alpha]*)
Do[
Aijk[[i,rank+k,rank+k]]=Flocci$ScalarProduct[s][ca[[i]],roots[[k]]];
Aijk[[rank+k,i,rank+k]]=-Flocci$ScalarProduct[s][ca[[i]],roots[[k]]];
,{i,1,rank},{k,1,Length[roots]}];
(*[e\[Alpha],e-\[Alpha]]=-h\[Alpha]=-\[Alpha]i hi, where \[Alpha]=\sum \[Alpha]i\[Lambda]i*)
Do[Aijk[[rank+k,rank+negaRoots[[k]],i]]=-(ga.roots[[k]])[[i]],{i,1,rank},{k,1,Length[roots]}];
(*[e\[Lambda]i,e\[Lambda]j]=\[Epsilon](\[Lambda]i,\[Lambda]j) e(\[Lambda]i+\[Lambda]j), where \[Alpha]=\sum \[Alpha]i\[Lambda]i*)
Do[
If[negaRoots[[i]]==j,Continue[]];
pos=Position[roots,roots[[i]]+roots[[j]]]//Flatten;
If[Length[pos]==0,Continue[]];
k=pos[[1]];
Aijk[[i+rank,j+rank,k+rank]]=(-1)^(roots[[i]].Transpose[ga].bi.ga.roots[[j]])
,{i,1,Length[roots]},{j,1,Length[roots]}];
(*The output is Aijk*)
Aijk
];
Flocci$FunctionListAdd[{"Flocci$CommutatorG2"}];
Flocci$CommutatorG2::tag="Commu";
Flocci$CommutatorG2::input="-";
Flocci$CommutatorG2::output="A specific integer 3-tensor.";
Flocci$CommutatorG2::description="See Flocci$Commutators. Commutator of G2. See Mitzmann page 77.";
Flocci$CommutatorG2=Module[{rank,s,ca,roots,supAlg,\[Sigma],supRank,supca,supga,\[CapitalDelta]0,supRoots,\[CapitalPhi]0,\[Tau],s1,s2,Ch,Ce,t\[Lambda],CeIndex,C,AijkSup,Aijk1,Aijk,Cp,Asupp,AS2,AijkToSolve,LiSol,AijkValues},
s=G2;
(*We get relevent data for our algebra*)
rank=Flocci$Rank[s];
roots=Flocci$Roots[{s}];
ca=Flocci$CartanMatrix[s];
(*We form the sup algebra*)
supAlg=D4;
supRank=Flocci$Rank[supAlg];
supca=Flocci$CartanMatrix[supAlg];
supga=Flocci$MetricTensor[supAlg];
supRoots=Flocci$Roots[{supAlg}];
(*We want to construct the embedding of s into supAlg*)

(*We start by constructing the graph automorphisms of supAlg*)
\[Sigma]=supca.{{0,0,0,1},{0,1,0,0},{1,0,0,0},{0,0,1,0}}.supga;
(*We form the set Subscript[\[CapitalDelta], [0]]. This is isomorphic to \[CapitalLambda][s]. By thinking about scalar products, it is easty to see that the ordering below gives the correct correspondence*)
\[CapitalDelta]0=Map[1/3 (#+\[Sigma].#+\[Sigma].\[Sigma].#)&,supca]//DeleteDuplicates;
(*We form the set Subscript[\[CapitalPhi], [0]]. This is isomorphic to \[CapitalPhi][s]. We keep track of \tilde lambda which forms this entry*)
\[CapitalPhi]0=DeleteDuplicates[Map[{1/3 (#+\[Sigma].#+\[Sigma].\[Sigma].#),#}&,supRoots],#1[[1]]==#2[[1]]&];
(*We now want to form the map \[Tau] between root systems*)
s1=Table[Array[a,Length[ca]]/.Solve[Array[a,Length[ca]].ca==r][[1]],{r,roots}];
s2=Table[Array[a,Length[\[CapitalDelta]0]]/.Solve[Array[a,Length[\[CapitalDelta]0]].\[CapitalDelta]0==r[[1]]][[1]],{r,\[CapitalPhi]0}];
\[Tau]=Table[Position[s2,si],{si,s1}]//Flatten;
(*We now construct the change of basis matrix, which we denote C*)
(*For the h's we have Subscript[h, \[Tau](\[Lambda])^v]*)
Ch=Table[Array[a,Length[supca]]/.Solve[Array[a,Length[supca]].supca==(2t\[Lambda])/Flocci$ScalarProduct[supAlg][t\[Lambda],t\[Lambda]]][[1]],{t\[Lambda],\[CapitalDelta]0}];
(*For the e's we have Subscript[e, \[Lambda]]+Subscript[e, \[Sigma].\[Lambda]] if \[Lambda]\[NotEqual] \[Sigma]\[Lambda], or Subscript[e, \[Lambda]] otherwise*)
CeIndex=Flatten[Table[
t\[Lambda]=\[CapitalPhi]0[[\[Tau][[i]],2]];
If[t\[Lambda]== \[Sigma].t\[Lambda],{{i,Flatten[Position[supRoots,t\[Lambda]]][[1]]}-> 1},{{i,Flatten[Position[supRoots,t\[Lambda]]][[1]]}-> 1,{i,Flatten[Position[supRoots,\[Sigma].t\[Lambda]]][[1]]}-> 1,{i,Flatten[Position[supRoots,\[Sigma].\[Sigma].t\[Lambda]]][[1]]}-> 1}]
,{i,1,Length[roots]}],1];
Ce=SparseArray[CeIndex,{Length[roots],Length[supRoots]}]//Normal;
(*We now construct the full change of basis matrix*)
C={{Ch,0},{0,Ce}}//ArrayFlatten//SparseArray;

(*We construct the commutator matrix based on that of the sup algebra*)
AijkSup=Flocci$CommutatorD4;

(*We want to multiply C\[LeftDoubleBracket]i,i\[Prime]\[RightDoubleBracket] C\[LeftDoubleBracket]j,j\[Prime]\[RightDoubleBracket]AijkSup\[LeftDoubleBracket]i\[Prime],j\[Prime]\[RightDoubleBracket], but will do it by sparse arrays.*)
Asupp=SparseArray[AijkSup]["NonzeroPositions"];
AS2=SparseArray[(Asupp[[All,{1,2}]]//DeleteDuplicates)/. {x_,y_}:> {x,y}-> a[x,y],{Length[AijkSup],Length[AijkSup]}];
Aijk1=C.AS2.Transpose[C];

(*For the third index we need to solve equations*)
AijkToSolve=SparseArray[Aijk1]["NonzeroValues"]/. a[i_,j_]:> AijkSup[[i,j]];
AijkValues=Table[LinearSolve[Transpose[C],AijkToSolve[[i]]],{i,1,Length[AijkToSolve]}];
(*We make the matrix*)
Aijk=ConstantArray[0,{rank+Length[roots],rank+Length[roots],rank+Length[roots]}];
Do[Aijk[[SparseArray[Aijk1]["NonzeroPositions"][[i,1]],SparseArray[Aijk1]["NonzeroPositions"][[i,2]]]]=AijkValues[[i]],{i,1,Length[AijkValues]}];
Aijk
];



(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$Commutators"}];
Flocci$Commutators::input="A simple Lie algebra s of any type.";
Flocci$Commutators::output="A 3-tensor vauled in the integers.";
Flocci$Commutators::description="Let {h_i,e_i}={h_{Flocci$CartanMatrix[s]},e_{Flocci$Roots[s]}}, in that order. The output is the tensor Aijk defined by [vi,vj]=Aijk vk. See Mitzmann.";
Flocci$Commutators::tag="Commu";
Flocci$Commutators::clear="3";
Flocci$Commutators[s_]:=Flocci$Commutators[s]=Which[Flocci$TypeAQ[s]||Flocci$TypeDQ[s]||Flocci$TypeE6Q[s]||Flocci$TypeE7Q[s]||Flocci$TypeE8Q[s],Flocci$SimplyLacedCommutators[s],Flocci$TypeCQ[s]||Flocci$TypeBQ[s]||Flocci$TypeF4Q[s],Flocci$NonSimplyLacedCommutator[s],Flocci$TypeG2Q[s],Flocci$CommutatorG2];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$OuterJoin"}];
Flocci$OuterJoin::tag="Aut";
Flocci$OuterJoin::input="n: An integer";
Flocci$OuterJoin::output="A compiled function.";
Flocci$OuterJoin::description="The compiled function takes in {list1, list2,...,listn} and finds Flatten[Outer[Join,list1,list2,...,listn,1],n-1]";
Flocci$OuterJoin::clear="3";
Flocci$OuterJoin[n_]:=Flocci$OuterJoin[n]=Module[{lists,args2},

lists=Table[ToExpression["list"<>ToString[i]],{i,1,n}];
args2=Table[{l,_Integer,2},{l,lists}];
ReleaseHold@@(Hold[Compile[args,
f2[f1,lev]
,CompilationTarget->"C",Parallelization->True]]/.args-> args2/. f1-> f[Join,Evaluate@@Sequence[lists],1]/. f-> Outer/. f2-> Flatten /. lev-> n-1)

];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$OuterAutomorphismsSingleType","Flocci$OuterAutomorphisms"}];
Flocci$OuterAutomorphismsSingleType::tag="Aut";
Flocci$OuterAutomorphismsSingleType::input="Let g=s+s+s..+s.\nno: no. of s in g\n s:The standardized form of the algebra";
Flocci$OuterAutomorphismsSingleType::output="A list of lists";
Flocci$OuterAutomorphismsSingleType::description="A compiled function. Outputs the automorphisms of s+s...+s. See Flocci$OuterAutomorphisms.";
Flocci$OuterAutomorphismsSingleType=Compile[{{no,_Integer},{s,_Integer,1}},
Block[{P1,P1t,P1tt,P1old,BagOfOuterAuto,P2,P2t,P2tt,allPerm,intDigit,T12,pnew},
(*We find the reordering of rows, if no non-trivial outer automorphism*)
P1=Permutations[Range[no]];
P1t=Map[Range[(#-1)*s[[2]]+1, #*s[[2]]] &,P1,{2}];
P1old=P1t;
BagOfOuterAuto=Internal`Bag[P1old,3];
(*We take account of non-trivial outer automorphisms.*)
Which[
(*If the algebra is An for n\[GreaterEqual] 2*)
s[[1]]==1&&s[[2]]!= 1,
Do[(*We loop through each i in 2^no-1. The int digits base 2 give which automorphism to apply.*)
intDigit=IntegerDigits[i,2,no];
Do[ (*We loop over all automorphisms in P1old.*)
pnew=p;
Do[ (*We loop over the different s's and apply the automorphism.*)
If[intDigit[[j]]==1, pnew[[j]]=Reverse[pnew[[j]]]];
,{j,1,no}];
Internal`StuffBag[BagOfOuterAuto,pnew,3];
,{p,P1old}]
,{i,1,2^no-1}],(*Starting at 1 since have already got the identity*)

(*If the algebra is D4*)
s=={4,4},
Do[
intDigit=IntegerDigits[i,6,no];
Do[
pnew=p;
Do[
Which[intDigit[[j]]==1, pnew[[j]]=p[[j,{1,2,4,3}]];,
intDigit[[j]]==2,pnew[[j]]=p[[j,{3,2,1,4}]];,
intDigit[[j]]==3,pnew[[j]]=p[[j,{4,2,1,3}]];,
intDigit[[j]]==4,pnew[[j]]=p[[j,{3,2,4,1}]];,
intDigit[[j]]==5,pnew[[j]]=p[[j,{4,2,3,1}]];
];
,{j,1,no}];
Internal`StuffBag[BagOfOuterAuto,pnew,3];
,{p,P1old}]
,{i,1,6^no-1}],

(*If the algebra is Dn*)
s[[1]]==4,
Do[
intDigit=IntegerDigits[i,2,no];
Do[
pnew=p;
Do[
If[intDigit[[j]]==1, pnew[[j,-1]]=p[[j,-2]]; pnew[[j,-2]]=p[[j,-1]]];
,{j,1,no}];
Internal`StuffBag[BagOfOuterAuto,pnew,3];
,{p,P1old}]
,{i,1,2^no-1}],

(*If the algebra is E6*)
s=={5,6},
Do[(*We loop through each i in 2^list\[LeftDoubleBracket]1\[RightDoubleBracket]-1. The int digits base 2 give which automorphism to apply.*)
intDigit=IntegerDigits[i,2,no];
Do[ (*We loop over all automorphisms in P1old.*)
pnew=p;
Do[ (*We loop over the different s's and apply the automorphism.*)
If[intDigit[[j]]==1, pnew[[j]]=p[[j,{5,4,3,2,1,6}]]];
,{j,1,no}];
Internal`StuffBag[BagOfOuterAuto,pnew,3];
,{p,P1old}]
,{i,1,2^no-1}]
];
Partition[Internal`BagPart[BagOfOuterAuto,All],no*s[[2]]]
]
,CompilationTarget->"C",Parallelization->True]


Flocci$OuterAutomorphisms::tag="Aut";
Flocci$OuterAutomorphisms::input="g: A semi-simple Lie algebra.";
Flocci$OuterAutomorphisms::output="A list of lists";
Flocci$OuterAutomorphisms::description="The output are the outer automorphisms of g such that: We will denote an outer permutation O, by the ordered list of columns with non-zero entries. Supposing that p is the list of columns corresponding to O, then O.\[Beta]=\[Beta]\[LeftDoubleBracket]p\[RightDoubleBracket].  For \!\(\*FormBox[\(\[CapitalLambda]O^\(-1\) = \(\[CapitalLambda] . \*SuperscriptBox[\(O\), \(T\)] = \[CapitalLambda]\[LeftDoubleBracket]All, p\[RightDoubleBracket]\)\),
TraditionalForm]\).  O.i = Transpose[Transpose[i]\[LeftDoubleBracket]All,p\[RightDoubleBracket]]]. \!\(\*
StyleBox[\"(\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"Check\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\")\",\nFontColor->RGBColor[1, 0, 0]]\) ";
Flocci$OuterAutomorphisms::clear="3";
Flocci$OuterAutomorphisms[g_List]:=Flocci$OuterAutomorphisms[g]=Module[{split,list,types,offset,tab,tups},
(*We first find the permutations in terms of identities*)  
split=Split[g]//Timing//Flocci$Timing["outer: 1"];
list=Map[{Length[#], Flocci$Rank[First[#]]}&,split];
offset=Prepend[Delete[Accumulate[Map[#[[1]]#[[2]]&,list]],-1],0];
tab=Table[Flocci$OuterAutomorphismsSingleType[list[[i,1]],Flocci$AlgStandard[split[[i,1]]]]+offset[[i]],{i,1,Length[list]}];
tups=Flocci$OuterJoin[Length[tab]][Evaluate@@Sequence[tab]];
tups
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$WeylGroup"}];
Flocci$WeylGroup::tag="Aut";
Flocci$WeylGroup::input="s: A simple Lie algebra";
Flocci$WeylGroup::output="A 3-tensor of integers.";
Flocci$WeylGroup::description="Outputs the Weyl group of s in the basis of fundamental weights.";
Flocci$WeylGroup::clear="3";
Flocci$WeylGroup[s_]:=Flocci$WeylGroup[s]=Module[{Proots,matrixForm,level,P,full}, 
(*Working in the basis of the fundamental weights*)
Proots=Flocci$PositiveRoots[s];
P=Table[(l-2( Flocci$ScalarProduct[s][p,l]/ Flocci$ScalarProduct[s][p,p])p),{p,Proots},{l,IdentityMatrix[Flocci$Rank[s]]}];
matrixForm=Map[Transpose,P];
level[0]=matrixForm;
level[n_]:=level[n]=Complement[DeleteDuplicates[Flatten[Outer[Dot,level[0],level[ n-1],1],1]],Evaluate@@Sequence[Table[level[i],{i,0,n-1}]]];
c=1;
While[Length[level[c]]!= 0,
level[c];
(*Print[c," ",Length[level[c]]];*)
c++;
];
full=Join@@Table[level[i],{i,0,c}];
(*Print["Number of elements: ", Length[full]];*)
full
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$E7InnerAut"}];
Flocci$E7InnerAut::tag="Aut";
Flocci$E7InnerAut::input="-";
Flocci$E7InnerAut::output="A function.";
Flocci$E7InnerAut::description="The outputed function takes in a projection matrix for an embedding g->E7. It outputs the inner-automorphisms which take \[CapitalLambda] into a unique representative of the equivelence class defined by inner automorphisms of E7. This function has the same form as Flocci$E8InnerAut. This is on delayed evaluation so it will only generate the function if needed.";
Flocci$E7InnerAut::clear="0";

Flocci$E7InnerAut:=Flocci$E7InnerAut=Module[{Flocci$E7ws,LexMin,Proots,ProotsM,level,Flocci$E7ws126,Flocci$E7Min126,P,matrixForm,Flocci$E7Weyl126,c,\[Lambda]List,bool,Mlist,set,Flocci$matrixListE7,E7inner,level1,level2},
(*We find the weight system of the (1,0,0,0,0,0) rep*)
Flocci$E7ws=Flocci$WeightSystem[E7,{1,0,0,0,0,0,0}]//DeleteDuplicates//Sort;
(*We get the lexicgoraphcially smallest weight*)
LexMin=Flocci$E7ws[[1]];
(*We find the orbit of LexMin under the Weyl group. This orbit is of size 126.*)
Proots=Flocci$PositiveRoots[E7];
ProotsM=Map[Flocci$MetricTensor[E7].#&,Proots];
level[0]=Table[(LexMin-2 ProotsM[[7]].LexMin/Proots[[i]].ProotsM[[i]] Proots[[i]]),{i,1,Length[Proots]}]//DeleteDuplicates;
level[1]=Select[DeleteDuplicates[Flatten[Table[(l-2 ProotsM[[i]].l/Proots[[i]].ProotsM[[i]] Proots[[i]]),{i,1,Length[Proots]},{l,level[0]}],1]],!MemberQ[level[0],#]&];
level[2]=Select[DeleteDuplicates[Flatten[Table[(l-2 ProotsM[[i]].l/Proots[[i]].ProotsM[[i]] Proots[[i]]),{i,1,Length[Proots]},{l,level[1]}],1]],!MemberQ[Join[level[0],level[1]],#]&];
level[3]=Select[DeleteDuplicates[Flatten[Table[(l-2 ProotsM[[i]].l/Proots[[i]].ProotsM[[i]] Proots[[i]]),{i,1,Length[Proots]},{l,level[2]}],1]],!MemberQ[Join[level[0],level[1],level[2]],#]&];
If[level[3]//Length!= 0, Print["Error"]];
Flocci$E7ws126=Join[level[0],level[1],level[2]]//Sort;
(*We want the lexicographically smallest weight in Flocci$E7ws126*)
Flocci$E7Min126=Flocci$E7ws126[[1]]; 
(*We want the subgroup of Weyl(E7) which stabalizes the weight Flocci$E7Min126*)
P=Table[(l-2( Flocci$ScalarProduct[E7][p,l]/ Flocci$ScalarProduct[E7][p,p])p),{p,Proots},{l,IdentityMatrix[7]}];
matrixForm=Map[Transpose,P];
level1[0]=Select[matrixForm,#.Flocci$E7Min126==Flocci$E7Min126 &];
level1[n_]:=level1[n]=Complement[DeleteDuplicates[Flatten[Outer[Dot,level1[0],level1[ n-1],1],1]],Evaluate@@Sequence[Table[level1[i],{i,0,n-1}]]];
c=1;
While[Length[level1[c]]!= 0,
level1[c];
(*Print[c," ",Length[level[c]]];*)
c++;
];
Flocci$E7Weyl126=Join@@Table[level1[i],{i,0,c}];
(*The list of inner-automorphisms of E7 which take the corresponding weight in Flocci$E7ws126 to (-2,1,0,0,0,0,0).*)
\[Lambda]List=Flocci$E7ws126;
P=Table[(l-2( Flocci$ScalarProduct[E7][p,l]/ Flocci$ScalarProduct[E7][p,p])p),{p,Proots},{l,IdentityMatrix[7]}];
matrixForm=Map[Transpose,P];
level2[0]=matrixForm;
level2[n_]:=level2[n]=Complement[DeleteDuplicates[Flatten[Outer[Dot,level2[0],level2[ n-1],1],1]],Evaluate@@Sequence[Table[level2[i],{i,0,n-1}]]];
c=0;
bool=ConstantArray[False,Length[\[Lambda]List]];
Mlist=ConstantArray[0,Length[\[Lambda]List]];
While[!AllTrue[bool,Identity],
level[c];

(*Print["Next iteration."];*)
Monitor[Do[
If[bool[[j]],Continue[]];
set=Select[level2[c],#.\[Lambda]List[[j]]==Flocci$E7Min126&];
If[Length[set]!= 0, 
Mlist[[j]]=set[[1]];
bool[[j]]=True;
]
,{j,1,Length[\[Lambda]List]}],j];
(*Print[c," ",Count[bool,True]];*)
c++;

];
Flocci$matrixListE7=Mlist;
(*We make the function which will test the inner automorphism*)
E7inner=Function[\[CapitalLambda],Module[{wsSort,pos,inn,innMin2160,innAll,minv},
 (*Find the weights in w1(126) which gives the minimum lexicographically, call this/these \[Lambda]'*)
wsSort=MinimalBy[Flocci$E7ws126,\[CapitalLambda].# &];
pos=Map[Position[Flocci$E7ws126,#][[1,1]]&,wsSort];
minv=Table[Inverse[Flocci$matrixListE7[[p]]],{p,pos}];
 (*Find the inner automorphisms of E7 which take \[Lambda]' to Subscript[\[Lambda], min]*)
inn=Flatten[Table[m.w,{m,minv},{w,Flocci$E7Weyl126}],1];
(*Of these inner-automorphisms select those that act `minimally' on Flocci$E7ws126. We do a partial check initally to reduce the size of the list*)
innMin2160=MinimalBy[inn,Take[Flocci$E7ws126,{1,10}].Transpose[\[CapitalLambda].#]&];
innMin2160=MinimalBy[innMin2160,Flocci$E7ws126.Transpose[\[CapitalLambda].#]&];
(*Of the remaining inner-automorphisms we select those which act minimally on the full weight system corresponding to (1,0,0,0,0,0,0)*)
innAll=MinimalBy[innMin2160,Flocci$E7ws.Transpose[\[CapitalLambda].#]&];
innAll
]];
E7inner
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$E8InnerAut"}];
Flocci$E8InnerAut::tag="Aut";
Flocci$E8InnerAut::input="-";
Flocci$E8InnerAut::output="A function.";
Flocci$E8InnerAut::description="The outputed function takes in a projection matrix for an embedding g->E8. It outputs the inner-automorphisms which take \[CapitalLambda] into a unique representative of the equivelence class defined by inner automorphisms of E8. This function has the same form as Flocci$E8InnerAut. This is on delayed evaluation so it will only generate the function if needed.";
Flocci$E8InnerAut::clear="0";

Flocci$E8InnerAut:=Flocci$E8InnerAut=Module[{Flocci$E8ws,LexMin,Proots,ProotsM,level,Flocci$E8ws2160,Flocci$E8Min2160,P,matrixForm,Flocci$E8WeylE82160,c,\[Lambda]List,bool,Mlist,set,Flocci$matrixListE8,E8inner,level1,level2},
(*We find the weight system of the (1,0,0,0,0,0) rep*)
Flocci$E8ws=Flocci$WeightSystem[E8,{1,0,0,0,0,0,0,0}]//DeleteDuplicates//Sort;
(*We get the lexicgoraphcially smallest weight*)
LexMin=Flocci$E8ws[[1]];
(*We find the orbit of LexMin under the Weyl group. This orbit is of size 2160.*)
Proots=Flocci$PositiveRoots[E8];
ProotsM=Map[Flocci$MetricTensor[E8].#&,Proots];
level[0]=Table[(LexMin-2 ProotsM[[i]].LexMin/Proots[[i]].ProotsM[[i]] Proots[[i]]),{i,1,Length[Proots]}]//DeleteDuplicates;
level[1]=Select[DeleteDuplicates[Flatten[Table[(l-2 ProotsM[[i]].l/Proots[[i]].ProotsM[[i]] Proots[[i]]),{i,1,Length[Proots]},{l,level[0]}],1]],!MemberQ[level[0],#]&];
level[2]=Select[DeleteDuplicates[Flatten[Table[(l-2 ProotsM[[i]].l/Proots[[i]].ProotsM[[i]] Proots[[i]]),{i,1,Length[Proots]},{l,level[1]}],1]],!MemberQ[Join[level[0],level[1]],#]&];
level[3]=Select[DeleteDuplicates[Flatten[Table[(l-2 ProotsM[[i]].l/Proots[[i]].ProotsM[[i]] Proots[[i]]),{i,1,Length[Proots]},{l,level[2]}],1]],!MemberQ[Join[level[0],level[1],level[2]],#]&];
Flocci$E8ws2160=Join[level[0],level[1],level[2]]//Sort;
(*We want the lexicographically smallest weight in Flocci$E8ws2160*)
Flocci$E8Min2160=Flocci$E8ws2160[[1]];
(*We want the subgroup of Weyl(E8) which stabalizes the weight Flocci$E8Min2160*)
P=Table[(l-2( Flocci$ScalarProduct[E8][p,l]/ Flocci$ScalarProduct[E8][p,p])p),{p,Proots},{l,IdentityMatrix[8]}];
matrixForm=Map[Transpose,P];

level1[0]=Select[matrixForm,#.Flocci$E8Min2160==Flocci$E8Min2160 &];

level1[n_]:=level1[n]=Complement[DeleteDuplicates[Flatten[Outer[Dot,level1[0],level1[n-1],1],1]],Evaluate@@Sequence[ Table[level1[i],{i,0,n-1}]]];

c=1;
While[Length[level1[c]]!= 0,
level1[c];
(*Print[c," ",Length[level[c]]];*)
c++;
];
Flocci$E8WeylE82160=Join@@Table[level1[i],{i,0,c}];

(*The list of inner-automorphisms of E7 which take the corresponding weight in Flocci$E7ws126 to (-2,1,0,0,0,0,0).*)
\[Lambda]List=Flocci$E8ws2160;
P=Table[(l-2( Flocci$ScalarProduct[E8][p,l]/ Flocci$ScalarProduct[E8][p,p])p),{p,Proots},{l,IdentityMatrix[8]}];
matrixForm=Map[Transpose,P];
level2[0]=matrixForm;
level2[n_]:=level2[n]=Complement[DeleteDuplicates[Flatten[Outer[Dot,level2[0],level2[ n-1],1],1]],Evaluate@@Sequence[Table[level2[i],{i,0,n-1}]]];
c=0;
bool=ConstantArray[False,Length[\[Lambda]List]];
Mlist=ConstantArray[0,Length[\[Lambda]List]];
While[!AllTrue[bool,Identity],
level2[c];

(*Print["Next iteration."];*)
Monitor[Do[
If[bool[[j]],Continue[]];
set=Select[level2[c],#.\[Lambda]List[[j]]==Flocci$E8Min2160&];
If[Length[set]!= 0, 
Mlist[[j]]=set[[1]];
bool[[j]]=True;
]
,{j,1,Length[\[Lambda]List]}],j];
(*Print[c," ",Count[bool,True]];*)
c++;
];
Flocci$matrixListE8=Mlist;
(*We make the function which will test the inner automorphism*)
E8inner=Function[\[CapitalLambda],Module[{wsSort,pos,inn,innMin2160,innAll,minv},
wsSort=MinimalBy[Flocci$E8ws2160,\[CapitalLambda].# &];
pos=Map[Position[Flocci$E8ws2160,#][[1,1]]&,wsSort];
minv=Table[Inverse[Flocci$matrixListE8[[p]]],{p,pos}];
inn=Flatten[Table[m.w,{m,minv},{w,Flocci$E8WeylE82160}],1];
innMin2160=MinimalBy[inn,Take[Flocci$E8ws2160,{1,10}].Transpose[\[CapitalLambda].#]&];

innMin2160=MinimalBy[innMin2160,Flocci$E8ws2160.Transpose[\[CapitalLambda].#]&];
innAll=MinimalBy[innMin2160,Flocci$E8ws.Transpose[\[CapitalLambda].#]&];
innAll
]];
E8inner
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$LinearEquivWeightSystms"}];
Flocci$LinearEquivWeightSystms::tag="Aut";
Flocci$LinearEquivWeightSystms::input="s: A simple Lie algebra.";
Flocci$LinearEquivWeightSystms::output="A list of two sorted weight systems.";
Flocci$LinearEquivWeightSystms::description="Outputs the weightsystem of the irreps given in Theorem 1.3 of Dynkin's Semisimple subalgebras of semisimple Lie algebras. This is for tests of linear equivelence";
Flocci$LinearEquivWeightSystms::clear="3";
Flocci$LinearEquivWeightSystms[s_]:=Flocci$LinearEquivWeightSystms[s]=Module[{v1,v2},
(*This function is based on Theorem 1.3 of Dynkin "Semisimple subalgebras of semisimple Lie algebras"*)
v1=ConstantArray[0,Flocci$Rank[s]];
v2=ConstantArray[0,Flocci$Rank[s]];
If[Flocci$TypeAQ[s]||Flocci$TypeBQ[s]||Flocci$TypeCQ[s]||Flocci$TypeE6Q[s],
v1[[1]]=1;
];
If[Flocci$TypeG2Q[s]||Flocci$TypeF4Q[s],
v1[[-1]]=1;
];
If[Flocci$TypeDQ[s],
v1[[1]]=1;
v2[[-1]]=1;
];
If[Flocci$TypeE7Q[s]||Flocci$TypeE8Q[s],
v1[[1]]=1;
v2[[-2]]=1;
];
{Sort[Flocci$WeightSystem[s,v1]],Sort[Flocci$WeightSystem[s,v2]]}
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$InnerAutThroughWeyl"}];
Flocci$InnerAutThroughWeyl::tag="Aut";
Flocci$InnerAutThroughWeyl::input="\[CapitalLambda]: A projection matrix g'->s.\n Weylt: The Weyl group of s. \n \[CapitalPhi]t: the first weight system of Flocci$LinearEquivWeightSystms[s]\[LeftDoubleBracket]1\[RightDoubleBracket]";
Flocci$InnerAutThroughWeyl::output="A integer 3-tensor.";
Flocci$InnerAutThroughWeyl::description="Finds the inner automrophisms of s which take \[CapitalLambda] to a representative based on equivelence classes defined by inner-automorphisms of s.";
Flocci$InnerAutThroughWeyl=Compile[{{\[CapitalLambda],_Integer,2},{Weylt,_Integer,3},{\[CapitalPhi]t,_Integer,2}},
Block[{pos,\[CapitalPhi]min,\[CapitalPhi]tem,posP},
\[CapitalPhi]min=Map[\[CapitalLambda].Weylt[[1]].#&,\[CapitalPhi]t];
pos=Internal`Bag@Most[{0}];
Internal`StuffBag[pos,1];
Do[
\[CapitalPhi]tem=Map[\[CapitalLambda].Weylt[[i]].#&,\[CapitalPhi]t];
Which[OrderedQ[{\[CapitalPhi]tem,\[CapitalPhi]min}]&&OrderedQ[{\[CapitalPhi]min,\[CapitalPhi]tem}],
Internal`StuffBag[pos,i];,OrderedQ[{\[CapitalPhi]tem,\[CapitalPhi]min}],
pos=Internal`Bag@Most[{0}];
Internal`StuffBag[pos,i];
\[CapitalPhi]min=\[CapitalPhi]tem;
];
,{i,2,Length[Weylt]}];
posP=Internal`BagPart[pos,All]; 
Weylt[[posP]]

],CompilationTarget->"C",Parallelization->True];


(* ::Input::Initialization:: *)

Flocci$SetDescription["Flocci$innerAutsMap\[CapitalLambda]ToRepresentativeSimple",{"Aut","\[CapitalPhi]t: The first weight system from Flocci$LinearEquivWeightSystms.\n \[CapitalLambda]: a projection matrix g'->s.\n typeAlg: The algebra is standardized form.","An 3-tensor of integers.","A complied function for the classical algebras. Finds the inner automrophisms of s which take \[CapitalLambda] to a representative based on equivelence classes defined by inner-automorphisms of s. The technique used is based on the permutaiton code."}];
Flocci$innerAutsMap\[CapitalLambda]ToRepresentativeClassical=Compile[{{\[CapitalPhi]t,_Integer,2},{\[CapitalLambda],_Integer,2},{typeAlg,_Integer,1}},
Block[{\[CapitalLambda]\[CapitalPhi],\[CapitalLambda]\[CapitalPhi]S,cList,blockParent,n},
\[CapitalLambda]\[CapitalPhi]=Map[\[CapitalLambda].# &,\[CapitalPhi]t];
\[CapitalLambda]\[CapitalPhi]S=Ordering[\[CapitalLambda]\[CapitalPhi]];
n=typeAlg[[2]];
cList={Map[{#}&,\[CapitalLambda]\[CapitalPhi]S]};
blockParent={1};
Do[
If[\[CapitalLambda]\[CapitalPhi][[\[CapitalLambda]\[CapitalPhi]S[[i]]]]==\[CapitalLambda]\[CapitalPhi][[\[CapitalLambda]\[CapitalPhi]S[[i-1]]]],blockParent[[-1]]+=1,AppendTo[blockParent,1]];
,{i,2 ,Length[\[CapitalLambda]\[CapitalPhi]S]}];

(*The input is:
1) A list of charges e.g. { {{1,-1},{2,-3},{4,-6}}, {{2,-3},{1,-1},{4,-6}} }
 2) A list of the sizes of parent bocks e.g. {2,1}. It is within these parent blocks which we find permutations.
3) A list of charges which should be prepend onto our charges. e.g. {{{0,0}},{{1,1}}}.

The output for the above example is: {{{0,0},{1,-1},{2,-3},{4,-6}},{{0,0},{2,-3},{1,-1},{4,-6}},{{1,1},{2,-3},{1,-1},{4,-6}}}
*)
Block[{cpos,cpos1,toAdvanceTo,cnew,accParent,currentblockEnd,tobreak,cbag,lengthPerCharge,counter,equalpairsBool,cJoined,max,sele,counter2,solved,ctemp,cToSolv}, 
accParent=Accumulate[blockParent];
cbag=Internal`Bag@Most[{0}];
counter=0;
Do[
cnew=c;
counter++;
counter2=0;
While[cnew!= {{-1}},
(*We test the equal pairs condition. If it fails, we skip all permutation which will change the point it fails at. - JTS:31/12/22 *)
equalpairsBool=-1;
counter2+=1;
cJoined=cnew;

(*The conditions we impose for different types of algebras start here*)
(*If[typeAlg\[LeftDoubleBracket]1\[RightDoubleBracket]\[Equal]4,If[Mod[Length[sele],2]\[Equal]1,equalpairsBool=n;];];*)
If[typeAlg[[1]]==4||typeAlg[[1]]==3,If[equalpairsBool==-1,
Do[
If[!(cnew[[i,1]]==2n+1-cnew[[2n+1-i,1]]||2n+1-cnew[[i,1]]==cnew[[2n+1-i,1]]),equalpairsBool=2n+1-i; ]
,{i,1,n}];
];];
If[typeAlg[[1]]==2,If[equalpairsBool==-1,
Do[
If[!(cnew[[i,1]]==2n+2-cnew[[2n+2-i,1]]||2n+2-cnew[[i,1]]==cnew[[2n+2-i,1]]),equalpairsBool=2n+2-i; ]
,{i,1,n}];
];];
(*If it does not satisfy the equal pairs condition, we put cnew in it's minimal lexicographic configuration past the point equalpairsBool*)
 If[equalpairsBool!= -1,
ctemp=cnew;
(*We find the end of the block we are currently in.*)
currentblockEnd=Select[accParent,#>= equalpairsBool&][[1]];(*Get the last position*)

(*We then sort the list from equalpairsBool+1 to currentblockEnd*)
If[equalpairsBool!=currentblockEnd,
 cnew[[Range[equalpairsBool+1,currentblockEnd]]]=Reverse[cnew[[Range[equalpairsBool+1,currentblockEnd]]]]];
(*We now reverse the remaining blocks.*)
Do[(*reverse the b-b+1 block - would probably be faster if went the other way*)
If[accParent[[b]]<currentblockEnd,Continue[]];
cnew[[Range[accParent[[b]]+1,accParent[[b+1]]]]]=Reverse[cnew[[Range[accParent[[b]]+1,accParent[[b+1]]]]]];(*reverse the list after k+1*) 
,{b,1, Length[blockParent]-1}];
];
If[equalpairsBool==-1,
cToSolv=cnew;
If[typeAlg[[1]]==4,
sele=Select[Take[cnew,{1,n}],#[[1]]>n&];
If[Mod[Length[sele],2]==1,cToSolv[[n]]=cnew[[n+1]];cToSolv[[n+1]]=cnew[[n]];];
];
solved=Transpose[LinearSolve[\[CapitalPhi]t,\[CapitalPhi]t[[Flatten[cToSolv]]]]];
Internal`StuffBag[cbag,solved,2];
];
(*We start at the end of the vector and move backwards*)
cpos=Length[cnew];
tobreak=False;
While[True,
(*We want to find the first cpos which can be advanced. This means, it satisfies cnew\[LeftDoubleBracket]cpos\[RightDoubleBracket]<cnew\[LeftDoubleBracket]cpo+1\[RightDoubleBracket] and is not the end of a block.*)
cpos1=cpos;
--cpos;
If[cnew[[cpos]]!=  cnew[[cpos1]]&&OrderedQ[{cnew[[cpos]],cnew[[cpos1]]}]&&!MemberQ[accParent,cpos],(*Find the largest k for which v[k]<v[k+1] and k not an end.*)
(*We find the end of the block we are currently in.*)
currentblockEnd=Select[accParent,#>cpos&][[1]];(*Get the last position*)
(*We find the smallest value in the block which we can use to advance our current position*)
toAdvanceTo=currentblockEnd;
While[OrderedQ[{cnew[[toAdvanceTo]],cnew[[cpos]]}], --toAdvanceTo;]; (*Find the largest l such that a[k]<a[l]*)
(*We swap the cpos and toAdvanceTo position.*)
cnew[[{toAdvanceTo,cpos}]]=cnew[[{cpos,toAdvanceTo}]]; (*swap a[k] and a[l]*)
(*We then sort the list from cpos1 to currentblockEnd*)
cnew[[Range[cpos1,currentblockEnd]]]=Reverse[cnew[[Range[cpos1,currentblockEnd]]]];(*reverse the list after k+1*) 
(*We now want to reverse the remaining blocks*)
(*We now reverse the remaining blocks.*)
Do[(*reverse the b-b+1 block - would probably be faster if went the other way*)
If[accParent[[b]]<currentblockEnd,Continue[]];
cnew[[Range[accParent[[b]]+1,accParent[[b+1]]]]]=Reverse[cnew[[Range[accParent[[b]]+1,accParent[[b+1]]]]]];(*reverse the list after k+1*) 
,{b,1, Length[blockParent]-1}];
(*We now break out of the loop of k*)
Break[];
];
(* If cpos is {-1} at this point, then we have reached the end and our list is in reverse lexicographic ordering. We stop.*)
If[cpos==1,cnew={{-1}};Break[];];
];
];

,{c,cList}];
(*Partition[Internal`BagPart[cbag,All],Length[cList\[LeftDoubleBracket]1\[RightDoubleBracket]]+Length[prependCharges\[LeftDoubleBracket]1\[RightDoubleBracket]]]*)

Partition[Partition[Internal`BagPart[cbag,All],typeAlg[[2]]],typeAlg[[2]]]//DeleteDuplicates
]

]
,CompilationTarget->"C",Parallelization->True];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$innerAutsMap\[CapitalLambda]ToRepresentativeSimple",{"Aut","s: A simple Lie algebra.\n \[CapitalLambda]: a projection matrix g'->s.","An 3-tensor of integers.","Finds the inner automrophisms of s which take \[CapitalLambda] to a representative based on equivelence classes defined by inner-automorphisms of s."}];

Flocci$innerAutsMap\[CapitalLambda]ToRepresentativeSimple[s_,\[CapitalLambda]_]:= Module[{\[CapitalPhi],\[CapitalLambda]\[CapitalPhi],\[CapitalLambda]\[CapitalPhi]S,n,\[CapitalLambda]\[CapitalPhi]Split,index,tuples,permutations,allowedPermutations,y,eqs,P,Pp,inner,intsort,intsplit,oddoreven,leftinverse,gcd},
(*Outputs the set of inner automorphisms which take \[CapitalLambda] to one which preseves ordering*)
\[CapitalPhi]=Flocci$LinearEquivWeightSystms[s][[1]];

If[Flocci$classicalQ[s],
inner=Flocci$innerAutsMap\[CapitalLambda]ToRepresentativeClassical[\[CapitalPhi],\[CapitalLambda],Flocci$AlgStandard[s]];
];

If[Flocci$TypeG2Q[s],
(*We want the members of the Weyl group which minimize the order of \[CapitalPhi]*)
inner=Flocci$InnerAutThroughWeyl[\[CapitalLambda],Flocci$WeylGroup[G2],\[CapitalPhi]];
];
If[Flocci$TypeF4Q[s],
(*We want the members of the Weyl group which minimize the order of \[CapitalPhi]*)
inner=Flocci$InnerAutThroughWeyl[\[CapitalLambda],Flocci$WeylGroup[F4],\[CapitalPhi]];
];
If[Flocci$TypeE6Q[s],
(*We want the members of the Weyl group which minimize the order of \[CapitalPhi]*)
inner=Flocci$InnerAutThroughWeyl[\[CapitalLambda],Flocci$WeylGroup[E6],\[CapitalPhi]];
];
If[Flocci$TypeE7Q[s],
inner=Flocci$E7InnerAut[\[CapitalLambda]];
];
If[Flocci$TypeE8Q[s],
inner=Flocci$E8InnerAut[\[CapitalLambda]];
];
inner
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$innerAutsMap\[CapitalLambda]ToRepresentative"}];
Flocci$innerAutsMap\[CapitalLambda]ToRepresentative::tag="Aut";
Flocci$innerAutsMap\[CapitalLambda]ToRepresentative::input="g: A semi-simple Lie algebra.\n \[CapitalLambda]: a projection matrix g'->g.";
Flocci$innerAutsMap\[CapitalLambda]ToRepresentative::output="A integer 3-tensor.";
Flocci$innerAutsMap\[CapitalLambda]ToRepresentative::description="Finds the inner automrophisms of g which take \[CapitalLambda] to a representative based on equivelence classes defined by inner-automorphisms of g.";

Flocci$innerAutsMap\[CapitalLambda]ToRepresentative[g_List,\[CapitalLambda]_]:=Module[{ranklist,\[CapitalLambda]parts,listinner,tuples},(*We find the inner-automorphisms which put \[CapitalLambda] into a minimal form*)
ranklist=Flocci$Rank[g];
\[CapitalLambda]parts=Map[Transpose[#]&,FoldPairList[TakeDrop,Transpose[\[CapitalLambda]],ranklist]];
listinner=Table[ Flocci$innerAutsMap\[CapitalLambda]ToRepresentativeSimple[g[[i]], \[CapitalLambda]parts[[i]]],{i,1,Length[g]}];
tuples=Tuples[listinner];
Map[(DiagonalMatrix[Hold/@#]//ReleaseHold//ArrayFlatten)&,tuples]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$OuterAutTakeWsToMinAndGroupPreserveMin"}];
Flocci$OuterAutTakeWsToMinAndGroupPreserveMin::tag="Aut";
Flocci$OuterAutTakeWsToMinAndGroupPreserveMin::input="out: The outer-autmorphisms of g.\n \[CapitalPhi]: A weight system of g.";
Flocci$OuterAutTakeWsToMinAndGroupPreserveMin::output="A pair {or,out\[Beta]} where or is a list of integers, and out\[Beta] is a list of lists of integers.";
Flocci$OuterAutTakeWsToMinAndGroupPreserveMin::description="or is an outer automorphrism which takes \[CapitalPhi] to its minimum form (after sorting). out\[Beta] is the group of outer automorphisms which perserve \[CapitalPhi]\[LeftDoubleBracket]All,or\[RightDoubleBracket] (not point-wise). ";

Flocci$OuterAutTakeWsToMinAndGroupPreserveMin[out_,\[CapitalPhi]_]:=Module[{or,out\[Beta],rot,\[CapitalLambda]\[Alpha]t,\[CapitalLambda]\[Rho]t,aut\[CapitalLambda]\[Alpha]},
or=MinimalBy[out,Function[ot,Sort[\[CapitalPhi][[All,ot]]]]][[1]];
rot=Sort[\[CapitalPhi][[All,or]]];
out\[Beta]=Sort[Select[out,Function[s,rot==Sort[rot[[All,s]]]]]];
{or,out\[Beta]}
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$ProjectionMatricesUniqueForm"}];
Flocci$ProjectionMatricesUniqueForm::tag="Aut";
Flocci$ProjectionMatricesUniqueForm::input="\[CapitalLambda]\[Alpha]sub: The projection matrix of the child algebra to the input.\n \[CapitalLambda]\[Rho]in:The projection matrix from the parent to the child.\n out) Outer-automorphisms which preserve \[Beta] of the parent.\ng) The parent algebra.\nAutIn) The group of automorphisms which preserves \[CapitalLambda]\[Alpha]t.";
Flocci$ProjectionMatricesUniqueForm::output="A quadruple.\n 1) The projection matrix \[CapitalLambda]\[Alpha] of the parent in a unique form.\n 2) The morphisms \[CapitalLambda]\[Rho] in a unique form.\n 3) The group of automorphisms which preserve \[CapitalLambda]\[Alpha]. \n 4) The automorphism used to change \[CapitalLambda]\[Alpha]'s form.";
Flocci$ProjectionMatricesUniqueForm::description= "This takes in \[CapitalLambda]\[Alpha]t, \[CapitalLambda]\[Rho], the list of outerautomorphisms of g which preserve \[Beta], and the list of automorphisms which preserves \[CapitalLambda]\[Alpha]t. It outputs a unique represenative of the equivelence class \[LeftDoubleBracket]\[CapitalLambda]\[Alpha]\[RightDoubleBracket]
defined by automorphism of g. And a unique represenative of \[LeftDoubleBracket]\[CapitalLambda]\[Rho]\[RightDoubleBracket] defined by automorphisms of gt and g, such that the relation \[CapitalLambda]\[Alpha]t.\[CapitalLambda]\[Rho]=\[CapitalLambda]\[Alpha] is preserved.";
Flocci$ProjectionMatricesUniqueForm[\[CapitalLambda]\[Alpha]sub_,\[CapitalLambda]\[Rho]in_,out_,g_,AutIn_]:=Module[{\[CapitalLambda]\[Alpha],\[CapitalLambda]\[Rho],AutAll,\[CapitalPhi]pa,ranklist,AutAllSort,Aut\[CapitalLambda]\[Alpha],Aut\[CapitalLambda]\[Alpha]Sort,Aut\[CapitalLambda]\[Alpha]\[CapitalLambda]\[Rho],AutSub\[CapitalLambda]\[Rho]Sort,AutSub\[CapitalLambda]\[Rho],Aut\[CapitalLambda]\[Alpha]PresT,Aut\[CapitalLambda]\[Alpha]Pres,Mi,outused,R},
(*Input: 
\[CapitalLambda]\[Alpha]sub: Which is \[CapitalLambda]\[Alpha] of the sub algebra gt.
\[CapitalLambda]\[Rho]in: which is the projection matrix of \[Rho]:gt\[Rule]g
out: The outer-automorphisms of g which preserve the corresponding \[Beta].
Output:
a pair (\[CapitalLambda]\[Alpha],\[CapitalLambda]\[Rho]) which are unique represenatives of their respective equivelence classes. 
*)
(*We from the projection matrix for the parent node.*)
\[CapitalLambda]\[Alpha]=\[CapitalLambda]\[Alpha]sub.\[CapitalLambda]\[Rho]in;
\[CapitalLambda]\[Rho]=\[CapitalLambda]\[Rho]in;
 (*We find all automorphisms which put \[CapitalLambda]\[Alpha] into a minimal form*)
(*We find the set of automorphisms o of g such that o preserves \[Beta] and \[CapitalLambda]\[Alpha].o minimizes lexicographically its value on the set weight systems, for a given projectoin Inn\[Rule]Out.*)
R=Range[Length[out[[1]]]]; (* R is needed to `invert' the outer automorphism*)
AutAll=Map[Map[Function[i,i[[Sort[Transpose[{#,R}]][[All,2]]]]],Flocci$innerAutsMap\[CapitalLambda]ToRepresentative[g,\[CapitalLambda]\[Alpha][[All,#]]]]&,out]//Timing//Flocci$Timing["projMatrix: 2"];

(*We form the weight system \[CapitalPhi]pa which is the direct sum of the irreps of w1 for each gi.*)
ranklist=Flocci$Rank[g];
\[CapitalPhi]pa=Flatten[Table[
Map[Join[ConstantArray[0,Total[Take[ranklist,{1,i-1}]]],#,ConstantArray[0,Total[Take[ranklist,{i+1,-1}]]]]&,Flocci$LinearEquivWeightSystms[g[[i]]][[1]]]
,{i,1,Length[g]}],1]//Sort;
(*We choose the set the automorphisms which put \[CapitalLambda]\[Alpha] the form which minimizes \[CapitalPhi]pa*)
AutAllSort=SortBy[Flatten[AutAll,1],Transpose[\[CapitalLambda]\[Alpha].#.Transpose[\[CapitalPhi]pa]]&];
Aut\[CapitalLambda]\[Alpha]=SplitBy[AutAllSort,Transpose[\[CapitalLambda]\[Alpha].#.Transpose[\[CapitalPhi]pa]]&][[1]];

 (*Given these, we the one which puts \[CapitalLambda]\[Rho] into the minimal form*)
Aut\[CapitalLambda]\[Alpha]Sort=SortBy[Aut\[CapitalLambda]\[Alpha],Transpose[\[CapitalLambda]\[Rho].#.Transpose[\[CapitalPhi]pa]]&];
Aut\[CapitalLambda]\[Alpha]\[CapitalLambda]\[Rho]=SplitBy[Aut\[CapitalLambda]\[Alpha]Sort,Transpose[\[CapitalLambda]\[Rho].#.Transpose[\[CapitalPhi]pa]]&][[1]];
\[CapitalLambda]\[Rho]= \[CapitalLambda]\[Rho].Aut\[CapitalLambda]\[Alpha]\[CapitalLambda]\[Rho][[1]];
\[CapitalLambda]\[Alpha]=\[CapitalLambda]\[Alpha].Aut\[CapitalLambda]\[Alpha]\[CapitalLambda]\[Rho][[1]];
outused=Aut\[CapitalLambda]\[Alpha]\[CapitalLambda]\[Rho][[1]];
(*We find the group of automorphisms which preserve \[CapitalLambda]\[Alpha]*)
(Mi=Inverse[Aut\[CapitalLambda]\[Alpha][[1]]];
Aut\[CapitalLambda]\[Alpha]Pres=Map[Mi.# &, Aut\[CapitalLambda]\[Alpha]];//Timing)//Flocci$Timing["projMatrix: 4"];



(*We want to do automorphisms on the other side of \[CapitalLambda]\[Rho]*)
AutSub\[CapitalLambda]\[Rho]Sort=SortBy[AutIn,Transpose[#.\[CapitalLambda]\[Rho].Transpose[\[CapitalPhi]pa]]&];
AutSub\[CapitalLambda]\[Rho]=SplitBy[AutSub\[CapitalLambda]\[Rho]Sort,Transpose[#.\[CapitalLambda]\[Rho].Transpose[\[CapitalPhi]pa]]&][[1]];

(*We can then take any automorhpism in Aut\[CapitalLambda]\[Alpha]\[CapitalLambda]\[Rho]*)
{\[CapitalLambda]\[Alpha],AutSub\[CapitalLambda]\[Rho][[1]].\[CapitalLambda]\[Rho],Aut\[CapitalLambda]\[Alpha]Pres,outused}
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$NonSSEmbeddingAn"}];
Flocci$NonSSEmbeddingAn::tag="Embed";
Flocci$NonSSEmbeddingAn::input="rank: rank of the parent A algebra as an integer, e.g. 4 for A4"; 
Flocci$NonSSEmbeddingAn::output="List of non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(A\), \(rank\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(A\), \(rank\)]\),{\!\(\*SubscriptBox[\(A\), \(child1\)]\),...},projection Matrix},...}";
Flocci$NonSSEmbeddingAn::description="Returns all non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(A\), \(rank\)]\)";
Flocci$NonSSEmbeddingAn[rank_]:=Module[{origAlg,resultList},
If[rank<=1,Return[{}]];
origAlg=ToExpression["A"<>ToString[rank]];
resultList={{origAlg,{ToExpression["A"<>ToString[rank-1]]},PadRight[IdentityMatrix[rank-1],{rank-1,rank}]}};
resultList=Join[resultList,Table[{origAlg,{ToExpression["A"<>ToString[rank-r-1]],ToExpression["A"<>ToString[r]]},ArrayFlatten[{{IdentityMatrix[rank-r-1],0,0},{0,0,IdentityMatrix[r]}}]},{r,Ceiling[(rank-1)/2],rank-2}]];
Return[resultList];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$NonSSEmbeddingBn"}];
Flocci$NonSSEmbeddingBn::tag="Embed";
Flocci$NonSSEmbeddingBn::input="rank: rank of the parent B algebra as an integer, e.g. 4 for B4"; 
Flocci$NonSSEmbeddingBn::output="List of non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(B\), \(rank\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(B\), \(rank\)]\),{child1,...},projection Matrix},...}";
Flocci$NonSSEmbeddingBn::description="Returns all non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(B\), \(rank\)]\)";
Flocci$NonSSEmbeddingBn[rank_]:=Module[{origAlg,resultList},
If[rank<=2,Return[{}]];
origAlg=ToExpression["B"<>ToString[rank]];
If[rank==3,Return[{{B3,{C2},{{0,0,1},{0,1,0}}}}],
Return[{{origAlg,{ToExpression["B"<>ToString[rank-1]]},PadLeft[IdentityMatrix[rank-1],{rank-1,rank}]}}]];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$NonSSEmbeddingCn"}];
Flocci$NonSSEmbeddingCn::tag="Embed";
Flocci$NonSSEmbeddingCn::input="rank: rank of the parent C algebra as an integer, e.g. 4 for C4"; 
Flocci$NonSSEmbeddingCn::output="List of non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(C\), \(rank\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(C\), \(rank\)]\),{child1,...},projection Matrix},...}";
Flocci$NonSSEmbeddingCn::description="Returns all non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(C\), \(rank\)]\)";
Flocci$NonSSEmbeddingCn[rank_]:=Module[{origAlg,resultList},
If[rank<=2,Return[{}]];
origAlg=ToExpression["C"<>ToString[rank]];
Return[{{origAlg,{ToExpression["A"<>ToString[rank-1]]},PadRight[IdentityMatrix[rank-1],{rank-1,rank}]}}];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$NonSSEmbeddingDn"}];
Flocci$NonSSEmbeddingDn::tag="Embed";
Flocci$NonSSEmbeddingDn::input="rank: rank of the parent D algebra as an integer, e.g. 4 for D4"; 
Flocci$NonSSEmbeddingDn::output="List of non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(D\), \(rank\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(D\), \(rank\)]\),{child1,...},projection Matrix},...}";
Flocci$NonSSEmbeddingDn::description="Returns all non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(D\), \(rank\)]\)";
Flocci$NonSSEmbeddingDn[rank_]:=Module[{origAlg,resultList},
If[rank<=1,Return[{}]];
If[rank==4,Return[{{D4,{A3},{{1,0,0,0},{0,1,0,0},{0,0,1,0}}}}]];
If[rank==5,Return[{{D5,{A4},{{0,0,0,1,0},{0,0,1,0,0},{0,1,0,0,0},{1,0,0,0,0}}},{D5,{D4},PadLeft[IdentityMatrix[4],{4,5}]}}],
origAlg=ToExpression["D"<>ToString[rank]];
Return[{{origAlg,{ToExpression["A"<>ToString[rank-1]]},PadRight[IdentityMatrix[rank-1],{rank-1,rank}]},{origAlg,{ToExpression["D"<>ToString[rank-1]]},PadLeft[IdentityMatrix[rank-1],{rank-1,rank}]}}]];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$NonSSEmbeddingE6","Flocci$NonSSEmbeddingE7"}];
Flocci$NonSSEmbeddingE6::tag="Embed";
Flocci$NonSSEmbeddingE7::tag="Embed";
Flocci$NonSSEmbeddingE6::input="-"; 
Flocci$NonSSEmbeddingE6::output="List of non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(E\), \(6\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(E\), \(6\)]\),{child1,...},projection Matrix},...}";
Flocci$NonSSEmbeddingE6::description="Returns all non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(E\), \(6\)]\)";
Flocci$NonSSEmbeddingE7::input="-"; 
Flocci$NonSSEmbeddingE7::output="List of non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(E\), \(7\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(E\), \(7\)]\),{child1,...},projection Matrix},...}";
Flocci$NonSSEmbeddingE7::description="Returns all non semi-simple regular embeddings (without U(1)) into \!\(\*SubscriptBox[\(E\), \(7\)]\)";
Flocci$NonSSEmbeddingE6={{{E6,{D5},{{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,1,0,0,0},{0,0,0,0,0,1},{0,0,0,1,0,0}}},{{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,1,0,0,0},{0,0,0,0,0,1},{0,0,0,1,0,0}}},{{E6,{D5},{{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,1,0,0,0},{0,0,0,1,0,0},{0,0,0,0,0,1}}},{{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,1,0,0,0},{0,0,0,1,0,0},{0,0,0,0,0,1}}}};
Flocci$NonSSEmbeddingE7={{{E7,{E6},{{1,0,0,0,0,0,0},{0,1,0,0,0,0,0},{0,0,1,0,0,0,0},{0,0,0,1,0,0,0},{0,0,0,0,1,0,0},{0,0,0,0,0,0,1}}},{{1,0,0,0,0,0,0},{0,1,0,0,0,0,0},{0,0,1,0,0,0,0},{0,0,0,1,0,0,0},{0,0,0,0,1,0,0},{-1,-2,-3,-2,-1,0,-1}}}};


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$SSEmbeddingBn"}];
Flocci$SSEmbeddingBn::tag="Embed";
Flocci$SSEmbeddingBn::input="rank: rank of the parent B algebra as an integer, e.g. 4 for B4"; 
Flocci$SSEmbeddingBn::output="List of semi-simple regular embeddings into \!\(\*SubscriptBox[\(B\), \(rank\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(B\), \(rank\)]\),{\!\(\*SubscriptBox[\(child\), \(1\)]\),...},projection Matrix},...}";
Flocci$SSEmbeddingBn::description="Returns all semi-simple regular embeddings into \!\(\*SubscriptBox[\(B\), \(rank\)]\)";
Flocci$SSEmbeddingBn[rank_]:=Module[{origAlg,resultList},
origAlg=ToExpression["B"<>ToString[rank]];
Which[
rank<=2,
Return[{}],
rank==3,
Return[{{B3,{A1,A1,A1},{{1,0,0},{-1,-2,-1},{0,0,1}}},{B3,{A3},{{1,0,0},{0,1,0},{-1,-2,-1}}}}],
rank==4,
Return[{{B4,{A1,A1,C2},{{1,0,0,0},{-1,-2,-2,-1},{0,0,0,1},{0,0,1,0}}},{B4,{A1,A3},{{0,0,0,1},{1,0,0,0},{0,1,0,0},{-1,-2,-2,-1}}},{B4,{D4},{{0,0,1,0},{0,1,0,0},{1,0,0,0},{-1,-2,-2,-1}}}}],
rank==5,
Return[{{B5,{A1,A1,B3},{{1,0,0,0,0},{-1,-2,-2,-2,-1},{0,0,1,0,0},{0,0,0,1,0},{0,0,0,0,1}}},{B5,{A3,C2},{{1,0,0,0,0},{0,1,0,0,0},{-1,-2,-2,-2,-1},{0,0,0,0,1},{0,0,0,1,0}}},{B5,{A1,D4},{{0,0,0,0,1},{0,0,1,0,0},{0,1,0,0,0},{-1,-2,-2,-2,-1},{1,0,0,0,0}}},{B5,{D5},{{0,0,0,1,0},{0,0,1,0,0},{0,1,0,0,0},{1,0,0,0,0},{-1,-2,-2,-2,-1}}}}],
True,
Return[Join[
{{origAlg,{A1,A1,ToExpression["B"<>ToString[rank-2]]},Join[{PadRight[{1},rank]},{Join[{-1},ConstantArray[-2,rank-2],{-1}]},PadLeft[IdentityMatrix[rank-2],{rank-2,rank}]]}},
{{origAlg,{A3,ToExpression["B"<>ToString[rank-3]]},Join[PadRight[IdentityMatrix[2],{2,rank}],{Join[{-1},ConstantArray[-2,rank-2],{-1}]},PadLeft[IdentityMatrix[rank-3],{rank-3,rank}]]}},
Table[{origAlg,{ToExpression["B"<>ToString[rank-k]],ToExpression["D"<>ToString[k]]},Join[PadLeft[IdentityMatrix[rank-k],{rank-k,rank}],PadRight[Reverse[IdentityMatrix[k-1]],{k-1,rank}],{Join[{-1},ConstantArray[-2,rank-2],{-1}]}]},{k,4,rank-3}],
{{origAlg,{C2,ToExpression["D"<>ToString[rank-2]]},Join[PadLeft[Reverse[IdentityMatrix[2]],{2,rank}],PadRight[Reverse[IdentityMatrix[rank-3]],{rank-3,rank}],{Join[{-1},ConstantArray[-2,rank-2],{-1}]}]}},
{{origAlg,{A1,ToExpression["D"<>ToString[rank-1]]},Join[{PadLeft[{1},rank]},PadLeft[PadRight[Reverse[IdentityMatrix[rank-3]],{rank-3,rank-1}],{rank-3,rank}],{Join[{-1},ConstantArray[-2,rank-2],{-1}]},{PadRight[{1},rank]}]}},
{{origAlg,{ToExpression["D"<>ToString[rank]]},Join[PadRight[Reverse[IdentityMatrix[rank-1]],{rank-1,rank}],{Join[{-1},ConstantArray[-2,rank-2],{-1}]}]}}]]
];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$SSEmbeddingCn"}];
Flocci$SSEmbeddingCn::tag="Embed";
Flocci$SSEmbeddingCn::input="rank: rank of the parent C algebra as an integer, e.g. 4 for C4"; 
Flocci$SSEmbeddingCn::output="List of semi-simple regular embeddings into \!\(\*SubscriptBox[\(C\), \(rank\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(C\), \(rank\)]\),{\!\(\*SubscriptBox[\(child\), \(1\)]\),...},projection Matrix},...}";
Flocci$SSEmbeddingCn::description="Returns all semi-simple regular embeddings into \!\(\*SubscriptBox[\(C\), \(rank\)]\)";
Flocci$SSEmbeddingCn[rank_]:=Module[{origAlg,resultList},
origAlg=ToExpression["C"<>ToString[rank]];
Which[
rank<2,
Return[{}],
rank==2,
Return[{{C2,{A1,A1},{{1,1},{0,1}}}}],
True,
Return[Join[
{{origAlg,{A1,ToExpression["C"<>ToString[rank-1]]},Join[{ConstantArray[1, rank]}, PadLeft[IdentityMatrix[rank-1],{rank-1,rank}]]}},
Table[{origAlg,{ToExpression["C"<>ToString[k]],ToExpression["C"<>ToString[rank-k]]},Join[PadRight[IdentityMatrix[k-1],{k-1,rank}],{Join[ConstantArray[0,k-1],ConstantArray[1,rank-k+1]]},PadLeft[IdentityMatrix[rank-k],{rank-k,rank}]]},{k,2,Floor[rank/2]}]]]
];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$SSEmbeddingDn"}];
Flocci$SSEmbeddingDn::tag="Embed";
Flocci$SSEmbeddingDn::input="rank: rank of the parent D algebra as an integer, e.g. 4 for D4"; 
Flocci$SSEmbeddingDn::output="List of semi-simple regular embeddings into \!\(\*SubscriptBox[\(D\), \(rank\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(D\), \(rank\)]\),{\!\(\*SubscriptBox[\(child\), \(1\)]\),...},projection Matrix},...}";
Flocci$SSEmbeddingDn::description="Returns all semi-simple regular embeddings into \!\(\*SubscriptBox[\(D\), \(rank\)]\)";
Flocci$SSEmbeddingDn[rank_]:=Module[{origAlg,resultList},
origAlg=ToExpression["D"<>ToString[rank]];
Which[
rank<=3,
Return[{}],
rank==4,
Return[{{D4,{A1,A1,A1,A1},{{1,0,0,0},{-1,-2,-1,-1},{0,0,1,0},{0,0,0,1}}}}],
rank==5,
Return[{{D5,{A1,A1,A3},{{1,0,0,0,0},{-1,-2,-2,-1,-1},{0,0,0,1,0},{0,0,1,0,0},{0,0,0,0,1}}}}],
rank==6,
Return[{{D6,{A1,A1,D4},{{1,0,0,0,0,0},{-1,-2,-2,-2,-1,-1},{0,0,1,0,0,0},{0,0,0,1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}}},{D6,{A3,A3},{{1,0,0,0,0,0},{0,1,0,0,0,0},{-1,-2,-2,-2,-1,-1},{0,0,0,0,1,0},{0,0,0,1,0,0},{0,0,0,0,0,1}}}}],
True,
Return[Join[
{{origAlg,{A1,A1,ToExpression["D"<>ToString[rank-2]]},Join[{PadRight[{1},rank]},{Join[{-1},ConstantArray[-2,rank-3],{-1,-1}]}, PadLeft[IdentityMatrix[rank-2],{rank-2,rank}]]}},{{origAlg,{A3,ToExpression["D"<>ToString[rank-3]]},Join[PadRight[IdentityMatrix[2],{2,rank}],{Join[{-1},ConstantArray[-2,rank-3],{-1,-1}]}, PadLeft[IdentityMatrix[rank-3],{rank-3,rank}]]}},
Table[{origAlg,{ToExpression["D"<>ToString[k]],ToExpression["D"<>ToString[rank-k]]},Join[PadLeft[PadRight[Reverse[IdentityMatrix[k-2]],{k-2,rank-1}],{k-2,rank}],{Join[{-1},ConstantArray[-2,rank-3],{-1,-1}]},{PadRight[{1},rank]}, PadLeft[IdentityMatrix[rank-k],{rank-k,rank}]] },{k,4,Floor[rank/2]}]]]
];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$SSEmbeddingE6","Flocci$SSEmbeddingE7","Flocci$SSEmbeddingE8","Flocci$SSEmbeddingG2","Flocci$SSEmbeddingF4"}];
Flocci$SSEmbeddingE6::tag="Embed";
Flocci$SSEmbeddingE7::tag="Embed";
Flocci$SSEmbeddingE8::tag="Embed";
Flocci$SSEmbeddingG2::tag="Embed";
Flocci$SSEmbeddingF4::tag="Embed";
Flocci$SSEmbeddingE6::input="-"; 
Flocci$SSEmbeddingE6::output="List of semi-simple regular embeddings into \!\(\*SubscriptBox[\(E\), \(6\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(E\), \(6\)]\),{\!\(\*SubscriptBox[\(child\), \(1\)]\),...},projection Matrix},...}";
Flocci$SSEmbeddingE6::description="Returns all semi-simple regular embeddings into \!\(\*SubscriptBox[\(E\), \(6\)]\)";
Flocci$SSEmbeddingE7::input="-"; 
Flocci$SSEmbeddingE7::output="List of semi-simple regular embeddings into \!\(\*SubscriptBox[\(E\), \(7\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(E\), \(7\)]\),{\!\(\*SubscriptBox[\(child\), \(1\)]\),...},projection Matrix},...}";
Flocci$SSEmbeddingE7::description="Returns all semi-simple regular embeddings into \!\(\*SubscriptBox[\(E\), \(7\)]\)";
Flocci$SSEmbeddingE8::input="-"; 
Flocci$SSEmbeddingE8::output="List of semi-simple regular embeddings into \!\(\*SubscriptBox[\(E\), \(8\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(E\), \(8\)]\),{\!\(\*SubscriptBox[\(child\), \(1\)]\),...},projection Matrix},...}";
Flocci$SSEmbeddingE8::description="Returns all semi-simple regular embeddings into \!\(\*SubscriptBox[\(E\), \(8\)]\)";
Flocci$SSEmbeddingG2::input="-"; 
Flocci$SSEmbeddingG2::output="List of semi-simple regular embeddings into \!\(\*SubscriptBox[\(G\), \(2\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(G\), \(2\)]\),{\!\(\*SubscriptBox[\(child\), \(1\)]\),...},projection Matrix},...}";
Flocci$SSEmbeddingG2::description="Returns all semi-simple regular embeddings into \!\(\*SubscriptBox[\(G\), \(2\)]\)";
Flocci$SSEmbeddingF4::input="-"; 
Flocci$SSEmbeddingF4::output="List of semi-simple regular embeddings into \!\(\*SubscriptBox[\(F\), \(4\)]\) with one representative projection matrix in the format {{\!\(\*SubscriptBox[\(F\), \(4\)]\),{\!\(\*SubscriptBox[\(child\), \(1\)]\),...},projection Matrix},...}";
Flocci$SSEmbeddingF4::description="Returns all semi-simple regular embeddings into \!\(\*SubscriptBox[\(F\), \(4\)]\)";

Flocci$SSEmbeddingE6={{{E6,{A1,A5},{{-1,-2,-3,-2,-1,-2},{0,0,0,0,1,0},{0,0,0,1,0,0},{0,0,1,0,0,0},{0,1,0,0,0,0},{1,0,0,0,0,0}}},{{1,0,0,0,0,0},{1,2,2,1,0,1},{-1,-2,-3,-2,-1,-2},{0,0,0,0,0,1},{0,0,1,0,0,0},{0,0,0,1,0,0}}},{{E6,{A1,A5},{{-1,-2,-3,-2,-1,-2},{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,1,0,0,0},{0,0,0,1,0,0},{0,0,0,0,1,0}}},{{1,0,0,0,0,0},{1,2,2,1,0,1},{0,0,0,0,1,0},{0,0,0,1,0,0},{0,0,1,0,0,0},{0,0,0,0,0,1}}},{{E6,{A2,A2,A2},{{-1,-2,-3,-2,-1,-2},{0,0,0,0,0,1},{0,0,0,0,1,0},{0,0,0,1,0,0},{0,1,0,0,0,0},{1,0,0,0,0,0}}},{{1,0,0,0,0,0},{0,1,0,0,0,0},{1,2,3,2,1,1},{-1,-2,-3,-2,-1,-2},{0,0,0,-1,-1,0},{0,0,0,1,0,0}}},{{E6,{A2,A2,A2},{{-1,-2,-3,-2,-1,-2},{0,0,0,0,0,1},{0,0,0,0,1,0},{0,0,0,1,0,0},{1,0,0,0,0,0},{0,1,0,0,0,0}}},{{1,0,0,0,0,0},{0,1,0,0,0,0},{1,2,3,2,1,1},{-1,-2,-3,-2,-1,-2},{0,0,0,-1,-1,0},{0,0,0,0,1,0}}},{{E6,{A2,A2,A2},{{-1,-2,-3,-2,-1,-2},{0,0,0,0,0,1},{0,0,0,1,0,0},{0,0,0,0,1,0},{0,1,0,0,0,0},{1,0,0,0,0,0}}},{{1,0,0,0,0,0},{0,1,0,0,0,0},{1,2,3,2,1,1},{0,0,0,0,0,1},{0,0,0,-1,-1,0},{0,0,0,1,0,0}}},{{E6,{A2,A2,A2},{{-1,-2,-3,-2,-1,-2},{0,0,0,0,0,1},{0,0,0,1,0,0},{0,0,0,0,1,0},{1,0,0,0,0,0},{0,1,0,0,0,0}}},{{1,0,0,0,0,0},{0,1,0,0,0,0},{1,2,3,2,1,1},{0,0,0,0,0,1},{0,0,0,-1,-1,0},{0,0,0,0,1,0}}},{{E6,{A2,A2,A2},{{-1,-2,-3,-2,-1,-2},{0,0,0,0,0,1},{0,1,0,0,0,0},{1,0,0,0,0,0},{0,0,0,0,1,0},{0,0,0,1,0,0}}},{{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,0,-1,-1,0},{0,0,0,1,0,0},{1,2,3,2,1,1},{-1,-2,-3,-2,-1,-2}}},{{E6,{A2,A2,A2},{{-1,-2,-3,-2,-1,-2},{0,0,0,0,0,1},{0,1,0,0,0,0},{1,0,0,0,0,0},{0,0,0,1,0,0},{0,0,0,0,1,0}}},{{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,0,-1,-1,0},{0,0,0,1,0,0},{1,2,3,2,1,1},{0,0,0,0,0,1}}},{{E6,{A2,A2,A2},{{-1,-2,-3,-2,-1,-2},{0,0,0,0,0,1},{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,0,0,1,0},{0,0,0,1,0,0}}},{{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,0,-1,-1,0},{0,0,0,0,1,0},{1,2,3,2,1,1},{-1,-2,-3,-2,-1,-2}}},{{E6,{A2,A2,A2},{{-1,-2,-3,-2,-1,-2},{0,0,0,0,0,1},{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,0,1,0,0},{0,0,0,0,1,0}}},{{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,0,-1,-1,0},{0,0,0,0,1,0},{1,2,3,2,1,1},{0,0,0,0,0,1}}}};
Flocci$SSEmbeddingE7={{{E7,{A7},{{-2,-3,-4,-3,-2,-1,-2},{1,0,0,0,0,0,0},{0,1,0,0,0,0,0},{0,0,1,0,0,0,0},{0,0,0,1,0,0,0},{0,0,0,0,1,0,0},{0,0,0,0,0,1,0}}},{{1,0,0,0,0,0,0},{0,1,0,0,0,0,0},{0,0,1,0,0,0,0},{0,0,0,1,0,0,0},{0,0,0,0,1,0,0},{0,0,0,0,0,1,0},{1,2,3,2,1,0,2}}},{{E7,{A1,D6},{{0,0,0,0,0,1,0},{-2,-3,-4,-3,-2,-1,-2},{1,0,0,0,0,0,0},{0,1,0,0,0,0,0},{0,0,1,0,0,0,0},{0,0,0,0,0,0,1},{0,0,0,1,0,0,0}}},{{1,0,0,0,0,0,0},{0,0,-1,-1,-1,-1,-1},{0,0,0,0,0,1,0},{0,0,0,0,1,0,0},{0,0,0,1,0,0,0},{0,0,1,0,0,0,0},{-1,-2,-3,-3,-2,-1,-1}}},{{E7,{A1,D6},{{0,0,0,0,0,1,0},{-2,-3,-4,-3,-2,-1,-2},{1,0,0,0,0,0,0},{0,1,0,0,0,0,0},{0,0,1,0,0,0,0},{0,0,0,1,0,0,0},{0,0,0,0,0,0,1}}},{{1,0,0,0,0,0,0},{0,0,-1,-1,-1,-1,-1},{0,0,0,0,0,1,0},{0,0,0,0,1,0,0},{0,0,0,1,0,0,0},{-1,-2,-3,-3,-2,-1,-1},{0,0,1,0,0,0,0}}},{{E7,{A2,A5},{{0,0,0,0,0,1,0},{0,0,0,0,1,0,0},{-2,-3,-4,-3,-2,-1,-2},{1,0,0,0,0,0,0},{0,1,0,0,0,0,0},{0,0,1,0,0,0,0},{0,0,0,0,0,0,1}}},{{1,0,0,0,0,0,0},{0,1,0,0,0,0,0},{0,0,0,0,0,0,-1},{1,2,3,2,1,0,2},{0,0,0,0,0,1,0},{0,0,0,0,1,0,0},{0,0,0,1,0,0,0}}},{{E7,{A2,A5},{{0,0,0,0,0,1,0},{0,0,0,0,1,0,0},{0,0,0,0,0,0,1},{0,0,1,0,0,0,0},{0,1,0,0,0,0,0},{1,0,0,0,0,0,0},{-2,-3,-4,-3,-2,-1,-2}}},{{1,0,0,0,0,0,0},{0,1,0,0,0,0,0},{0,0,0,0,0,0,-1},{-1,-2,-3,-3,-2,-1,-1},{0,0,0,1,0,0,0},{0,0,0,0,1,0,0},{0,0,0,0,0,1,0}}}};
Flocci$SSEmbeddingE8={{{E8,{A4,A4},{{-2,-4,-6,-5,-4,-3,-2,-3},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0},{0,0,0,0,1,0,0,0},{0,0,0,0,0,0,0,1},{0,0,1,0,0,0,0,0},{0,1,0,0,0,0,0,0},{1,0,0,0,0,0,0,0}}},{{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,0},{0,0,0,1,0,0,0,0},{1,2,3,3,3,2,1,1},{1,2,3,2,1,0,0,2},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0}}},{{E8,{A4,A4},{{-2,-4,-6,-5,-4,-3,-2,-3},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0},{0,0,0,0,1,0,0,0},{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,0},{0,0,0,0,0,0,0,1}}},{{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,0},{0,0,0,1,0,0,0,0},{1,2,3,3,3,2,1,1},{-2,-4,-6,-5,-4,-3,-2,-3},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0}}},{{E8,{D8},{{-2,-4,-6,-5,-4,-3,-2,-3},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0},{0,0,0,0,1,0,0,0},{0,0,0,1,0,0,0,0},{0,0,1,0,0,0,0,0},{0,0,0,0,0,0,0,1},{0,1,0,0,0,0,0,0}}},{{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,0},{0,0,0,1,0,0,0,0},{0,0,0,0,1,0,0,0},{0,0,0,0,0,1,0,0},{1,2,3,2,1,0,0,2},{0,0,0,0,0,0,1,0}}},{{E8,{D8},{{-2,-4,-6,-5,-4,-3,-2,-3},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0},{0,0,0,0,1,0,0,0},{0,0,0,1,0,0,0,0},{0,0,1,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,0,0,0,0,0,1}}},{{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,0},{0,0,0,1,0,0,0,0},{0,0,0,0,1,0,0,0},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0},{1,2,3,2,1,0,0,2}}},{{E8,{A8},{{-2,-4,-6,-5,-4,-3,-2,-3},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0},{0,0,0,0,1,0,0,0},{0,0,0,1,0,0,0,0},{0,0,1,0,0,0,0,0},{0,1,0,0,0,0,0,0},{1,0,0,0,0,0,0,0}}},{{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,0},{0,0,0,1,0,0,0,0},{0,0,0,0,1,0,0,0},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0},{-2,-4,-6,-5,-4,-3,-2,-3}}},{{E8,{A1,E7},{{-2,-4,-6,-5,-4,-3,-2,-3},{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,0},{0,0,0,1,0,0,0,0},{0,0,0,0,1,0,0,0},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,0,1}}},{{1,0,0,0,0,0,0,0},{2,4,5,4,3,2,1,2},{-2,-4,-6,-5,-4,-3,-2,-3},{0,0,0,0,0,0,1,0},{0,0,0,0,0,1,0,0},{0,0,0,0,1,0,0,0},{0,0,0,1,0,0,0,0},{1,2,4,3,2,1,0,2}}},{{E8,{A2,E6},{{-2,-4,-6,-5,-4,-3,-2,-3},{0,0,0,0,0,0,1,0},{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,0},{0,0,0,1,0,0,0,0},{0,0,0,0,1,0,0,0},{0,0,0,0,0,0,0,1}}},{{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,0,0,0,0,0,-1},{1,2,3,2,1,0,0,2},{0,0,0,0,0,1,0,0},{0,0,0,0,0,0,1,0},{-2,-4,-6,-5,-4,-3,-2,-3},{0,0,0,0,1,0,0,0}}},{{E8,{A2,E6},{{0,0,0,0,0,0,1,0},{-2,-4,-6,-5,-4,-3,-2,-3},{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,0},{0,0,0,1,0,0,0,0},{0,0,0,0,1,0,0,0},{0,0,0,0,0,0,0,1}}},{{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{0,0,0,0,0,0,0,-1},{1,2,3,2,1,0,0,2},{0,0,0,0,0,1,0,0},{0,0,0,0,1,0,0,0},{0,0,0,1,0,0,0,0},{0,0,0,0,0,0,1,0}}}};
Flocci$SSEmbeddingF4={{{F4,{B4},{{-2,-3,-2,-1},{1,0,0,0},{0,1,0,0},{0,0,1,0}}},{{1,0,0,0},{0,1,0,0},{1,2,2,1},{-2,-4,-3,-2}}},{{F4,{A1,C3},{{-2,-3,-2,-1},{0,0,0,1},{0,0,1,0},{0,1,0,0}}},{{1,0,0,0},{2,4,2,1},{-2,-4,-3,-2},{1,2,2,1}}},{{F4,{A2,A2},{{-2,-3,-2,-1},{1,0,0,0},{0,0,0,1},{0,0,1,0}}},{{1,0,0,0},{0,1,0,0},{2,4,3,1},{0,0,0,1}}},{{F4,{A2,A2},{{-2,-3,-2,-1},{1,0,0,0},{0,0,1,0},{0,0,0,1}}},{{1,0,0,0},{0,1,0,0},{2,4,3,1},{-2,-4,-3,-2}}},{{F4,{A2,A2},{{0,0,0,1},{0,0,1,0},{-2,-3,-2,-1},{1,0,0,0}}},{{2,2,1,0},{0,0,0,1},{-1,-3,-2,-1},{1,2,2,1}}},{{F4,{A2,A2},{{0,0,0,1},{0,0,1,0},{1,0,0,0},{-2,-3,-2,-1}}},{{2,2,1,0},{0,0,0,1},{-1,-3,-2,-1},{0,1,0,0}}}};
Flocci$SSEmbeddingG2={{{G2,{A2},{{-1,-2},{0,1}}},{{1,1},{-1,-2}}},{{G2,{A1,A1},{{-1,-2},{1,0}}},{{1,1},{-1,-3}}},{{G2,{A1,A1},{{1,0},{-1,-2}}},{{1,0},{1,2}}}};


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$FindProjMatrix"}];
Flocci$FindProjMatrix::tag="Embed";
Flocci$FindProjMatrix::input="parent: parent algebra, e.g. A7. child: child algebra in the format {alg}, e.g. {D4} or {A1,A3}. repChild: representation of child algebra that embedds into parent in the format {rep1,rep2,...}, e.g. {{1,0,0,0}} for D4 or {{1},{1,0,0}} for {A1,A3}. repParent:(optional) representation into which the embedding occurs in the format {rep}. The default is the fundamental representation, i.e. {{1,0,...}}."; 
Flocci$FindProjMatrix::output="projection matrix.";
Flocci$FindProjMatrix::description="Returns one representative projection matrix for the special embedding child->parent through given representations.";
Flocci$FindProjMatrix[parent_,child_,repChild_,repParent_:False]:= Module[{rkParent,rkChild,projMatrixAnsatz,p,projSol,wsParent,wsChild,repTarget},
(* Computes the projection matrix for the embedding child -> parent via the representations repChild -> repParent. If no repParent is specified it is assumed to be the fundamental representation. The output is a projection matrix or False if finding the projection matrix was unseccessful *)
rkParent=Flocci$Rank[parent];
rkChild=Total[Flocci$Rank[child]];
If[repParent===False,
repTarget={PadRight[{1},rkParent]},
repTarget=repParent
];
If[Flocci$Dim[child,{Flatten[repChild]}]!=Flocci$Dim[{parent},{Flatten[repTarget]}],(*Print["Irrep Dimensions don't match"]*)Return[{}];];
wsChild=Flocci$WeightSystem[child,repChild]//Timing//Flocci$Timing["FindProj: wsChild"];
wsParent=Flocci$WeightSystem[{parent},repTarget]//Timing//Flocci$Timing["FindProj: wsParent"];
projMatrixAnsatz=Array[p,{rkChild,rkParent}];
projSol=Solve[wsParent.Transpose[projMatrixAnsatz]==wsChild]//Timing//Flocci$Timing["FindProj: solveProjMatrix"];
If[Length[projSol]>0,
Return[projMatrixAnsatz/.projSol[[1]]],
Return[False]
]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$SpecialEmbeddings"}];
Flocci$SpecialEmbeddings::tag="Embed";
Flocci$SpecialEmbeddings::input="userWS: weightsystem in format {weight1,weight2,...}."; 
Flocci$SpecialEmbeddings::output="list of special embeddings in the format {{parent,{child1,child2,...},projection matrix},...}.";
Flocci$SpecialEmbeddings::description="Returns all maximal special embeddings into parent algebras whose lowest dimensional non-anomalous representation has dimension \[LessEqual] dim(userWS). Embeddings are only added to the list if they satisfy the constraints of Flocci$checkAlgebraEmbedding.";
Flocci$SpecialEmbeddings[userWS_,check_:True]:=Module[{rank,irreps,wsParent,wsChild,algChild,projMatrixAnsatz,projMatrix,algParent,testVec,projSol,algList,alg,childRep,dim,res},
(* Finds all maximal special embeddings with irreducible representation <= dim
  Input:    - dim: maximal dimension of irreducible representation (integer) 
Output:   - list of embeddings of the form {{parentAlgebra,{child1,child2,...},Projection Matrix},...}
*)
(* Special embeddings map the fundamental representation of parent algebra to N dim irrep of child *)

(* list of algebra types and minimal ranks *)
dim=Length[userWS];

algList={{"A",1},{"B",3},{"C",2},{"D",4},{"E",6},{"E",7},{"E",8},{"F",4},{"G",2}};
(* go through all algebras in algList *)
res=Reap[
(******  maximal simple embeddings ******)
(*Print["Doing simple S-embeddings"];*)

Do[
(* initialize current algebra and starting rank *)
alg=algList[[i,1]];
rank=algList[[i,2]];

(* Go through alg until there is no irrep with dimension <= dim *)
While[True,
(* define child algebra *)
algChild=ToExpression[alg<>ToString[rank]];
(*Print["Current Child algebra ",algChild];*)

(* Get all irreps of child algebra with dimension <= dim *)
irreps=Drop[Flocci$SimpleIrrepsWithDim[algChild,dim],1];

(* if there is no irrep exit the loop *)
If[Length[irreps]==0,Break[]];

(* define testvector for bilinear form for each algebra *)
Which[Flocci$TypeAQ[algChild],
testVec=Table[k*(rank-k+1),{k,1,rank}],
Flocci$TypeBQ[algChild],
testVec=Join[Table[(rank+k)*(rank-k+1),{k,rank,2,-1}],{1/2rank(rank+1)}],
Flocci$TypeCQ[algChild],
testVec=Join[Table[(rank-k+1)*(rank+k+1),{k,rank,2,-1}],{rank^2*1/2rank(rank-1)}],
Flocci$TypeDQ[algChild],
testVec=Join[Table[(rank-k+1)*(rank+k-2),{k,rank,3,-1}],{1/2rank(rank-1),1/2rank(rank-1)}],
Flocci$TypeG2Q[algChild],
testVec={10,6},
Flocci$TypeF4Q[algChild],
testVec={22,42,30,16},
Flocci$TypeE6Q[algChild],
testVec={16,30,42,30,16,22},
Flocci$TypeE7Q[algChild],
testVec={34,66,96,75,52,27,49},
Flocci$TypeE8Q[algChild],
testVec={92,182,270,220,168,114,58,270}
];

(* Go through all irreps and find maximal embeddings *)
Do[

(* first check special cases *)
(* An < A_{1/2(n-1)(n+2)} for n > 3 *)
If[Flocci$TypeAQ[algChild]&&rank>3&&MatchQ[ir[[2]],{1,0,1,Repeated[0]}],

(*Print["Exception 1"];*)
Continue[];
];

(* An < A_{1/2n(n+3)} for n > 1 *)
If[Flocci$TypeAQ[algChild]&&rank>1&&MatchQ[ir[[2]],{2,1,RepeatedNull[0]}],

(*Print["Exception 2"];*)
Continue[];
];

(* B_{2n+1} < D_{2n+2} for n > 1, k>=1 *)
If[Flocci$TypeBQ[algChild]&&rank>1&&OddQ[rank]&&MatchQ[ir[[2]],{Repeated[0],x_}/;IntegerQ[x]&&x>0],

(*Print["Exception 3"];*)
Continue[];
];

(* G_{2} < B_3 for n > 1, k>=1, note: LG hw assignment for G2 is swapped *)
If[Flocci$TypeG2Q[algChild]&&MatchQ[ir[[2]],{x_,0}/;IntegerQ[x]&&x>1],

(*Print["Exception 4"];*)
Continue[];
];

(* A1 < G2 via {6} into {0,1} *)
If[Flocci$TypeAQ[algChild]&&rank==1&&ir[[2]]=={6},

(*Print["Exception 5"];*)
Continue[];
];

(* A5 < C10 via {0,1,0,1,0} into {0,1,0,0,...} *)
If[Flocci$TypeAQ[algChild]&&rank==5&&ir[[2]]=={0,1,0,1,0},

(*Print["Exception 6"];*)
Continue[];
];

(* B4 < D8 via {1,0,0,1} into {0,0,0,0,...,0,1,0} *)
If[Flocci$TypeBQ[algChild]&&rank==4&&ir[[2]]=={1,0,0,1},

(*Print["Exception 7"];*)
Continue[];
];

(* C3 < C7 via {0,2,0} into {0,1,0,0,...} *)
If[Flocci$TypeCQ[algChild]&&rank==3&&ir[[2]]=={0,2,0},

(*Print["Exception 8"];*)
Continue[];
];

(* C3 < C7 via {1,2,0} into {0,0,1,0,0,...} *)
If[Flocci$TypeCQ[algChild]&&rank==3&&ir[[2]]=={1,2,0},

(*Print["Exception 9"];*)
Continue[];
];

(* D5 < A15 via {0,1,0,1,0} into {0,0,1,0,0,...} *)
If[Flocci$TypeDQ[algChild]&&rank==5&&ir[[2]]=={0,1,0,1,0},

(*Print["Exception 10"];*)
Continue[];
];

(* D6 < C16 via {0,0,0,1,0,0} into {0,1,0,0,...} *)
If[Flocci$TypeDQ[algChild]&&rank==6&&ir[[2]]=={0,0,0,1,0,0},

(*Print["Exception 11"];*)
Continue[];
];

(* D6 < C16 via {0,0,1,0,0,0} into {0,0,1,0,0,...} *)
If[Flocci$TypeDQ[algChild]&&rank==6&&ir[[2]]=={0,0,1,0,0,0},

(*Print["Exception 12"];*)
Continue[];
];

(* E6 < A26 via {0,1,0,0,0,0} into {0,1,0,0,0,...} *)
If[Flocci$TypeE6Q[algChild]&&ir[[2]]=={0,1,0,0,0,0},

(*Print["Exception 13"];*)
Continue[];
];

(* E6 < A26 via {0,0,0,1,0,1} into {0,0,0,1,0,...} *)
If[Flocci$TypeE6Q[algChild]&&ir[[2]]=={0,0,0,1,0,1},

(*Print["Exception 14"];*)
Continue[];
];

(* E7 < C28 via {0,0,0,0,1,0,0} into {0,1,0,0,...} *)
If[Flocci$TypeE7Q[algChild]&&ir[[2]]=={0,0,0,0,1,0,0},

(*Print["Exception 15"];*)
Continue[];
];

(* E7 < C28 via {0,0,0,1,0,0,0} into {0,0,1,0,0,...} *)
If[Flocci$TypeE7Q[algChild]&&ir[[2]]=={0,0,0,1,0,0,0},

(*Print["Exception 16"];*)
Continue[];
];

(* E7 < C28 via {0,0,1,0,0,0,0} into {0,0,0,1,0,0,...} *)
If[Flocci$TypeE7Q[algChild]&&ir[[2]]=={0,0,1,0,0,0,0},

(*Print["Exception 17"];*)
Continue[];
];

(* E7 < C28 via {0,1,0,0,0,0,1} into {0,0,0,...,0,1,0} *)
If[Flocci$TypeE7Q[algChild]&&ir[[2]]=={0,1,0,0,0,0,1},

(*Print["Exception 18"];*)
Continue[];
];

(* does algebra have a bilinear form ? *)
If[(Flocci$TypeAQ[algChild]&&ir[[2,1]]==Reverse[ir[[2,1]]])||Flocci$TypeBQ[algChild]||Flocci$TypeCQ[algChild]||(Flocci$TypeDQ[algChild]&&EvenQ[rank])||(Flocci$TypeDQ[algChild]&&!EvenQ[rank]&&ir[[2,1,-1]]==ir[[2,1,-2]]&&ir[[2,1,1;;-2]]==Reverse[ir[[2,1,1;;-2]]])||Flocci$TypeG2Q[algChild]||Flocci$TypeF4Q[algChild]||(Flocci$TypeE6Q[algChild]&&ir[[2,1,1;;-2]]==Reverse[ir[[2,1,1;;-2]]])||Flocci$TypeE7Q[algChild]||Flocci$TypeE8Q[algChild],

(* Print["has bilinear form"];*)

(* Check if bilinear form is symmetric or antisymmetric *)
If[EvenQ[testVec.ir[[2,1]]],

(* symmetric bilinear form => contained in Bn if N=2n+1 and Dn if N=2n *)
(*Print["symmetric"];*)
If[EvenQ[ir[[1]]],
(*embedding into Dn*)
algParent=ToExpression["D"<>ToString[ir[[1]]/2]];
,
(*embedding into Bn*)
algParent=ToExpression["B"<>ToString[(ir[[1]]-1)/2]];
];
,

(* antisymmetric bilinear form => contained in Cn with N=2n*)
(*Print["antisymmetric"];*)
algParent=ToExpression["C"<>ToString[ir[[1]]/2]];
],

(* no bilinear form => contained in An with N=n+1 *)
(*Print["has no bilinear form"];*)
algParent=ToExpression["A"<>ToString[ir[[1]]-1]];
];
(* take into account isomorphisms *)
algParent=algParent/. {B1->A1,C1->A1,D1->A1,B2->C2,D3->A3};
(* if embedding is into same algebra the maximal embedding is into An with N=n+1 or nothing for An *)
If[algParent===algChild,
If[Flocci$TypeAQ[algChild]&&(rank==ir[[1]]-1),(*Print["A algebra embedding into itself"];*)Continue[],algParent=ToExpression["A"<>ToString[ir[[1]]-1]]]
];
(*Print["Embedding into "<>ToString[algParent]];*)

(* if algParent is an A-type algebra we do not have to consider rank > (dim-1)/2 due to anomaly cancelation *)
If[Flocci$TypeAQ[algParent]&&rank>(dim-1)/2,Continue[]];

(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[algParent,userWS]],Continue[]];

(* Find the projection matrix *)
projMatrix=Flocci$FindProjMatrix[algParent,{algChild},ir[[2]]];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[ir]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,{algChild},projMatrix}]];
];
,{ir,irreps}];
(* increase the rank by one unit or directly move on to next algebra type if exceptionial *)
If[Flocci$TypeG2Q[algChild]||Flocci$TypeE6Q[algChild]||Flocci$TypeE7Q[algChild]||Flocci$TypeE8Q[algChild]||Flocci$TypeF4Q[algChild],Break[]];
rank+=1;
]
,{i,1,Length[algList]}];

(******  maximal semi-simple embeddings ******)
(*Print["Finding semi-simple S-embeddings"];
Print["Type I: Subscript[A, n]+Subscript[A, m] \[Subset] Subscript[A, (n+1)(m+1)-1] with 1<= n <= m"];*)
(* Consider two cases for each algebra pair: {1,0,...}+{1,0,...} and {1,0,0,...}+{0,...,0,1}, both embedded into {1,0,...} *)
Do[
Do[
algChild={ToExpression["A"<>ToString[n]],ToExpression["A"<>ToString[m]]};
algParent=ToExpression["A"<>ToString[(n+1)(m+1)-1]];

(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[algParent,userWS]],Continue[]];

projMatrix=Flocci$FindProjMatrix[algParent,algChild,{PadRight[{1},n],PadRight[{1},m]}];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[{PadRight[{1},n],PadRight[{1},m]}]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,algChild,projMatrix}]];
];
projMatrix=Flocci$FindProjMatrix[algParent,algChild,{PadRight[{1},n],PadLeft[{1},m]}];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[{PadRight[{1},n],PadLeft[{1},m]}]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,algChild,projMatrix}]];
];
,{n,1,Min[dim/(m+1)-1,m]}]
,{m,1,dim/2-1}];

(*Print["Type II a: Subscript[C, n]+Subscript[D, m] \[Subset] Subscript[C, 2nm] with 1<= n, 3<= m"];*)
(* Consider one cases for each algebra pair: {1,0,...}+{1,0,...} embedded into {1,0,...} *)
Do[
Do[
algChild={ToExpression["C"<>ToString[n]],ToExpression["D"<>ToString[m]]}/.{C1->A1,D3->A3};
algParent=ToExpression["C"<>ToString[2n*m]];

(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[algParent,userWS]],Continue[]];

If[algChild[[2]]===A3,
projMatrix=Flocci$FindProjMatrix[algParent,algChild,{PadRight[{1},n],{0,1,0}}],
projMatrix=Flocci$FindProjMatrix[algParent,algChild,{PadRight[{1},n],PadRight[{1},m]}]
];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[{PadRight[{1},n],PadRight[{1},m]}]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,algChild,projMatrix}]];
];
,{n,1,dim/(4m)}]
,{m,3,dim/4}];

(*Print["Type II b i): Subscript[A, 1]+Subscript[C, n] \[Subset] Subscript[C, 3n] with 1<= n, 3<= m"];*)
Do[
algChild={A1,ToExpression["C"<>ToString[n]]}/.{C1->A1};
algParent=ToExpression["C"<>ToString[3n]];

(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[algParent,userWS]],Continue[]];

projMatrix=Flocci$FindProjMatrix[algParent,algChild,{{2},PadRight[{1},n]}];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[{{2},PadRight[{1},n]}]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,algChild,projMatrix}]];
];
,{n,1,dim/(6)}];

(*Print["Type II b ii): Subscript[B, n]+Subscript[C, m] \[Subset] Subscript[C, m(2n+1)] with 1<=m, 2<=n"];*)
Do[
Do[
algChild={ToExpression["B"<>ToString[n]],ToExpression["C"<>ToString[m]]}/.{B2-> C2,C1->A1};
algParent=ToExpression["C"<>ToString[m*(2n+1)]];

(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[algParent,userWS]],Continue[]];

If[algChild[[1]]===C2,
projMatrix=Flocci$FindProjMatrix[algParent,algChild,{{0,1},PadRight[{1},m]}],
projMatrix=Flocci$FindProjMatrix[algParent,algChild,{PadRight[{1},n],PadRight[{1},m]}]
];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[{PadRight[{1},n],PadRight[{1},m]}]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,algChild,projMatrix}]];
];
,{m,1,dim/(2(2n+1))}]
,{n,2,(dim-2)/4}];

(*Print["Type II b iii): Subscript[A, 1]+Subscript[A, 1]+Subscript[A, 1] \[Subset] Subscript[C, 4] "];*)
If[dim>=8, Sow[{C4,{A1,A1,A1},{{1,2,3,4},{1,0,1,0},{1,2,1,0}}}]];

(*Print["Type III: Subscript[C, n]+Subscript[C, m]\[Subset]Subscript[C, 2nm] n,m >= 1"];*)
Do[
Do[
algChild={ToExpression["C"<>ToString[n]],ToExpression["C"<>ToString[m]]}/.{C1->A1};
algParent=ToExpression["D"<>ToString[2m*n]];

(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[algParent,userWS]],Continue[]];

projMatrix=Flocci$FindProjMatrix[algParent,algChild,{PadRight[{1},n],PadRight[{1},m]}];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[{PadRight[{1},n],PadRight[{1},m]}]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,algChild,projMatrix}]];
];
,{n,1,Min[m,dim/(4m)]}]
,{m,2,(dim)/4}];

(*Print["Type IV a: Subscript[D, n]+Subscript[D, m]\[Subset]Subscript[D, 2nm] n,m >= 3"];*)
Do[
Do[
algChild={ToExpression["D"<>ToString[n]],ToExpression["D"<>ToString[m]]}/.{D3->A3};
algParent=ToExpression["D"<>ToString[2m*n]];

(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[algParent,userWS]],Continue[]];

childRep={PadRight[{1},n],PadRight[{1},m]};
If[algChild[[1]]===A3,childRep[[1]]={0,1,0}];
If[algChild[[2]]===A3,childRep[[2]]={0,1,0}];
projMatrix=Flocci$FindProjMatrix[algParent,algChild,childRep];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[childRep]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,algChild,projMatrix}]];
];
,{n,3,Min[m,dim/(4m)]}]
,{m,3,(dim)/4}];

(*Print["Type IV b i): Subscript[B, n]+Subscript[D, m]\[Subset]Subscript[D, m(2n+1)] m>=3 n>= 2"];*)
Do[
Do[
algChild={ToExpression["B"<>ToString[n]],ToExpression["D"<>ToString[m]]}/.{D3->A3,B2->C2};
algParent=ToExpression["D"<>ToString[m(2n+1)]];

(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[algParent,userWS]],Continue[]];

childRep={PadRight[{1},n],PadRight[{1},m]};
If[algChild[[1]]===C2,childRep[[1]]={0,1}];
If[algChild[[2]]===A3,childRep[[2]]={0,1,0}];
projMatrix=Flocci$FindProjMatrix[algParent,algChild,childRep];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[childRep]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,algChild,projMatrix}]];
];
,{n,2,(dim-2m)/(4m)}]
,{m,3,(dim)/10}];

(*Print["Type IV b ii): Subscript[A, 1]+Subscript[D, n]\[Subset]Subscript[D, 3n] n>=3"];*)
Do[
algChild={A1,ToExpression["D"<>ToString[n]]}/.{D3->A3,B2->C2};
algParent=ToExpression["D"<>ToString[3n]];

(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[algParent,userWS]],Continue[]];

childRep={{2},PadRight[{1},n]};
If[algChild[[2]]===A3,childRep[[2]]={0,1,0}];
projMatrix=Flocci$FindProjMatrix[algParent,algChild,childRep];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[childRep]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,algChild,projMatrix}]];
];
,{n,3,dim/(6)}];

(*Print["Type IV c i): Subscript[A, 1]+Subscript[B, n]\[Subset]Subscript[B, 3n+1] n>=2"];*)
Do[
algChild={A1,ToExpression["B"<>ToString[n]]}/.{D3->A3,B2->C2};
algParent=ToExpression["B"<>ToString[3n+1]];

(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[algParent,userWS]],Continue[]];

childRep={{2},PadRight[{1},n]};
If[algChild[[2]]===C2,childRep[[2]]={0,1}];
projMatrix=Flocci$FindProjMatrix[algParent,algChild,childRep];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[childRep]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,algChild,projMatrix}]];
];
,{n,2,(dim-3)/(6)}];

(*Print["Type IV c i): Subscript[A, 1]+Subscript[A, 1]\[Subset]Subscript[B, 4]"];*)
If[dim>=9,
Sow[{B4,{A1,A1},{{2,4,6,3},{2,2,0,1}}}];
];

(*Print["Type IV c iii): Subscript[B, n]+Subscript[B, m]\[Subset]Subscript[B, 2n m+n+m] m>=n>=2"];*)
Do[
Do[
algChild={ToExpression["B"<>ToString[n]],ToExpression["B"<>ToString[m]]}/.{D3->A3,B2->C2};
algParent=ToExpression["B"<>ToString[2m*n+m+n]];

(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[algParent,userWS]],Continue[]];

childRep={PadRight[{1},n],PadRight[{1},m]};
If[algChild[[1]]===C2,childRep[[1]]={0,1}];
If[algChild[[2]]===C2,childRep[[2]]={0,1}];
projMatrix=Flocci$FindProjMatrix[algParent,algChild,childRep];
If[projMatrix===False,
Print["Could not find the projection matrix for " <>ToString[algChild]<>"->"<>ToString[algParent]<>" with the representation "<>ToString[childRep]],
(* add result to list *)
If[Length[projMatrix]>0,Sow[{algParent,algChild,projMatrix}]];
];
,{n,2,Min[(dim-2m-1)/(4m+2),m]}]
,{m,2,(dim-5)/10}];

(*Print["Exception Subscript[B, n]+Subscript[B, m]\[Subset]Subscript[D, n+m+1] m>=n>=1 and n+m>=4"];*)
(* These are all taken from LieArt *)
(*Print["Exception i) Subscript[A, 1]+Subscript[B, n]\[Subset]Subscript[D, n+2] n>=3"];*)
Do[
(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[ToExpression["D"<>ToString[n+2]],userWS]],Continue[]];Sow[{ToExpression["D"<>ToString[n+2]],{A1,ToExpression["B"<>ToString[n]]},Join[{PadRight[ConstantArray[2,n],n+2,1]},PadRight[PadLeft[IdentityMatrix[n-1],{n-1,n}],{n-1,n+2}],{PadLeft[{1,1},n+2]}]}]
,{n,3,(dim-4)/2}];

(*Print["Exception ii) Subscript[C, 2]+Subscript[B, m]\[Subset]Subscript[D, m+3] m>=3"];*)
Do[
(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[ToExpression["D"<>ToString[m+3]],userWS]],Continue[]];
projMatrix=Join[PadRight[IdentityMatrix[1],{1,m+3}],{PadLeft[Join[ConstantArray[2,m],{1,1}],m+3]},PadLeft[PadRight[IdentityMatrix[m-1],{m-1,m+1}],{m-1,m+3}],{PadLeft[{1,1},m+3]}];
projMatrix[[{1,2}]]=projMatrix[[{2,1}]];
Sow[{ToExpression["D"<>ToString[m+3]],{C2,ToExpression["B"<>ToString[m]]},projMatrix}]
,{m,3,(dim-6)/2}];

(*Print["Exception iii) Subscript[C, 2]+Subscript[C, 2]\[Subset]Subscript[D, 5]"];*)
If[dim>=10,
Sow[{D5,{C2,C2},{{0,2,2,1,1},{1,0,0,0,0},{0,0,0,-1,1},{0,0,0,1,0}}}];
];

(*Print["Exception iv) Subscript[B, n]+Subscript[B, m]\[Subset]Subscript[D, n+m+1] n,m>=3"];*)
Do[
Do[
(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[ToExpression["D"<>ToString[n+m+1]],userWS]],Continue[]];
projMatrix=Join[PadRight[IdentityMatrix[n-1],{n-1,n+m+1}],{PadLeft[Join[ConstantArray[2,m],{1,1}],n+m+1]},PadLeft[PadRight[IdentityMatrix[m-1],{m-1,m+1}],{m-1,m+n+1}],{PadLeft[{1,1},n+m+1]}];
Sow[{ToExpression["D"<>ToString[n+m+1]],{ToExpression["B"<>ToString[n]],ToExpression["B"<>ToString[m]]},projMatrix}]
,{n,3,Min[(dim-2m-2)/2,m]}];
,{m,3,(dim-8)/2}];

(******  Exceptional Algebras ********)
(*Print["Going through exceptional algebras:"];*)

(* Special embeddings into exceptional algebras are now handled separately in the function Flocci$GenerateMaxEmbeddingList *)

(****** add exceptions ******)
(*Print["Going through all exceptions:"];*)

(* Note all but exception 3 and 19 do not give new embeddings *)

(* B_{2n+1} < D_{2n+2} for n > 1, k>=1 *)
(*Print["Exception 3: Subscript[B, 2n+1]\[Subset]Subscript[D, 2n+2] n>0"];*)
If[dim>=8,
Sow[{D4,{B3},{{0,0,0,1},{0,1,0,0} ,{1,0,1,0}}}];
];

Do[
(* if parent algebra does not satisfy embedding check continue *)
If[!Or[!check,Flocci$CheckAlgebraEmbedding[ToExpression["D"<>ToString[2n+2]],userWS]],Continue[]];
Sow[{ToExpression["D"<>ToString[2n+2]],{ToExpression["B"<>ToString[2n+1]]},Join[PadRight[IdentityMatrix[2n],{2n,2n+2}],{PadLeft[{1,1},2n+2]}]}]
,{n,2,(dim-4)/4}];

][[2]];
If[Length[res]>0,Return[res[[1]]],Return[res]];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$SpecialEmbeddG2","Flocci$SpecialEmbeddF4","Flocci$SpecialEmbeddE6","Flocci$SpecialEmbeddE7","Flocci$SpecialEmbeddE8"}];
Flocci$SpecialEmbeddG2::tag="Embed";
Flocci$SpecialEmbeddF4::tag="Embed";
Flocci$SpecialEmbeddE6::tag="Embed";
Flocci$SpecialEmbeddE7::tag="Embed";
Flocci$SpecialEmbeddE8::tag="Embed";
Flocci$SpecialEmbeddG2::input="-"; 
Flocci$SpecialEmbeddG2::output="list of special embeddings into G2 in the format {{G2,{child1,child2,...},projection matrix},...}.";
Flocci$SpecialEmbeddG2::description="Returns all maximal special embeddings into G2.";
Flocci$SpecialEmbeddF4::input="-"; 
Flocci$SpecialEmbeddF4::output="list of special embeddings into F4 in the format {{F4,{child1,child2,...},projection matrix},...}.";
Flocci$SpecialEmbeddF4::description="Returns all maximal special embeddings into F4.";
Flocci$SpecialEmbeddE6::input="-"; 
Flocci$SpecialEmbeddE6::output="list of special embeddings into E6 in the format {{E6,{child1,child2,...},projection matrix},...}.";
Flocci$SpecialEmbeddE6::description="Returns all maximal special embeddings into E6.";
Flocci$SpecialEmbeddE7::input="-"; 
Flocci$SpecialEmbeddE7::output="list of special embeddings into E7 in the format {{E7,{child1,child2,...},projection matrix},...}.";
Flocci$SpecialEmbeddE7::description="Returns all maximal special embeddings into E7.";
Flocci$SpecialEmbeddE8::input="-"; 
Flocci$SpecialEmbeddE8::output="list of special embeddings into E8 in the format {{E8,{child1,child2,...},projection matrix},...}.";
Flocci$SpecialEmbeddE8::description="Returns all maximal special embeddings into E8.";

Flocci$SpecialEmbeddG2={{{G2,{A1},{{4,2}}},{{4,2}}}};
Flocci$SpecialEmbeddF4={{{F4,{A1,G2},{{4,8,6,4},{1,0,1,0},{0,1,0,0}}},{{4,4,2,0},{1,0,0,1},{-1,-1,-1,-1}}},{{F4,{A1},{{22,42,30,16}}},{{18,14,6,2}}}};
Flocci$SpecialEmbeddE6={{{E6,{A2},{{2,2,5,2,2,1},{2,5,5,5,2,4}}},{{4,3,2,1,0,1},{-2,-3,-1,-2,0,-2}}},{{E6,{G2},{{2,2,5,2,2,1},{0,1,0,1,0,1}}},{{4,3,2,1,0,1},{-2,-2,-1,-1,0,-1}}},{{E6,{C4},{{0,1,0,1,0,0},{1,0,0,0,1,0},{0,1,2,1,0,0},{0,0,0,0,0,1}}},{{2,2,2,1,0,1},{-1,-2,-3,-2,0,-2},{0,0,0,1,0,1},{0,0,1,0,0,0}}},{{E6,{F4},{{0,0,0,0,0,1},{0,0,1,0,0,0},{0,1,0,1,0,0},{1,0,0,0,1,0}}},{{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,2,1,0,1},{-1,-2,-3,-2,0,-2}}},{{E6,{A2,G2},{{0,0,1,2,1,1},{1,2,1,0,0,1},{1,0,1,0,1,1},{0,1,1,1,0,0}}},{{2,2,2,1,0,1},{0,1,2,2,2,1},{0,-2,-3,-2,0,-2},{0,1,1,1,0,1}}},{{E6,{A2,G2},{{1,2,1,0,0,1},{0,0,1,2,1,1},{1,0,1,0,1,1},{0,1,1,1,0,0}}},{{2,2,2,1,0,1},{-2,-3,-4,-3,-2,-2},{0,-2,-3,-2,0,-2},{0,1,1,1,0,1}}}};
Flocci$SpecialEmbeddE7={{{E7,{A1},{{34,66,96,75,52,27,49}}},{{22,10,0,-3,-4,-3,-5}}},{{E7,{A1},{{26,50,72,57,40,21,37}}},{{16,6,-2,-3,-4,-3,-5}}},{{E7,{A2},{{4,6,11,7,6,0,4},{4,9,11,10,6,6,7}}},{{5,2,0,-1,-1,-1,-1},{-4,-4,-6,-1,-1,2,-4}}},{{E7,{A1,A1},{{2,2,0,3,4,3,1},{8,16,24,18,12,6,12}}},{{4,2,0,-1,-2,-1,-1},{2,0,0,2,6,2,0}}},{{E7,{A1,A1},{{8,16,24,18,12,6,12},{2,2,0,3,4,3,1}}},{{6,4,2,0,0,0,0},{-2,-6,-8,-3,-4,-3,-5}}},{{E7,{A1,G2},{{2,4,4,5,4,1,3},{2,2,4,4,1,0,1},{0,1,1,0,1,1,1}}},{{4,4,4,3,2,1,1},{-2,-6,-9,-8,-6,-3,-4},{1,3,4,4,3,1,2}}},{{E7,{A1,F4},{{2,4,6,5,4,3,3},{0,0,0,0,0,0,1},{0,0,1,0,0,0,0},{0,1,0,1,0,0,0},{1,0,0,0,1,0,0}}},{{0,-2,-4,-3,-2,-1,-3},{2,3,4,3,2,1,2},{-1,-2,-3,-3,-2,-1,-1},{0,0,1,2,1,0,0},{0,1,0,0,0,1,0}}},{{E7,{C3,G2},{{0,1,1,1,0,1,0},{1,0,1,1,1,0,0},{0,1,1,0,0,0,1},{1,2,1,1,2,1,0},{0,0,1,1,0,0,1}}},{{1,0,-1,-1,-1,-1,-1},{-1,-2,-2,-1,0,1,-1},{1,2,3,2,1,0,2},{2,4,4,3,2,2,2},{-1,-2,-2,-2,-1,-1,-1}}}};
Flocci$SpecialEmbeddE8={{{E8,{A1},{{72,142,210,172,132,90,46,106}}},{{38,30,24,16,10,6,2,4}}},{{E8,{A1},{{60,118,174,142,108,74,38,88}}},{{32,26,22,16,10,6,2,4}}},{{E8,{A1},{{92,182,270,220,168,114,58,136}}},{{48,38,30,20,12,6,2,4}}},{{E8,{C2},{{4,8,16,12,8,8,2,6},{4,8,9,8,7,3,3,6}}},{{6,4,2,0,0,0,0,0},{-2,-1,1,4,2,1,0,0}}},{{E8,{A1,A2},{{8,16,22,16,14,10,6,12},{2,4,5,6,4,1,1,3},{2,4,8,6,4,4,1,3}}},{{4,2,0,0,0,0,0,-2},{4,6,9,6,4,2,1,6},{-2,-3,-6,-3,-2,-1,-2,-3}}},{{E8,{F4,G2},{{0,0,0,1,1,1,0,0},{0,1,1,0,0,0,0,1},{1,0,1,1,1,0,0,0},{0,1,1,1,0,1,1,0},{1,2,1,1,2,1,1,0},{0,0,1,1,0,0,0,1}}},{{1,0,0,0,0,0,0,0},{0,1,0,0,0,0,0,0},{1,2,5,4,3,2,1,2},{-3,-6,-9,-8,-6,-4,-2,-4},{-2,-4,-6,-4,-4,-3,-2,-4},{1,2,3,2,2,1,1,2}}}};


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$Unique\[CapitalLambda]\[Rho]"}];
Flocci$Unique\[CapitalLambda]\[Rho]::tag="Embed";
Flocci$Unique\[CapitalLambda]\[Rho]::input="g: parent algebra in format {alg1,alg2,...}. \[CapitalLambda]\[Rho]: projection matrix"; 
Flocci$Unique\[CapitalLambda]\[Rho]::output="unique projection matrix.";
Flocci$Unique\[CapitalLambda]\[Rho]::description="Returns unique form of the projection matrix.";
(*Maybe move this function to the automorphism section*)
Flocci$Unique\[CapitalLambda]\[Rho][g_,\[CapitalLambda]\[Rho]_]:=Module[{ranklist,\[CapitalPhi]pa,outlist},
ranklist=Flocci$Rank[g];

\[CapitalPhi]pa=Flatten[Table[
Map[Join[ConstantArray[0,Total[Take[ranklist,{1,i-1}]]],#,ConstantArray[0,Total[Take[ranklist,{i+1,-1}]]]]&,Flocci$LinearEquivWeightSystms[g[[i]]][[1]]]
,{i,1,Length[g]}],1]//Sort;
outlist=Flatten[Table[Map[\[CapitalLambda]\[Rho][[All,o]].#&,Flocci$innerAutsMap\[CapitalLambda]ToRepresentative[g,\[CapitalLambda]\[Rho][[All,o]]]],{o,Flocci$OuterAutomorphisms[g]}],1];
MinimalBy[outlist,\[CapitalPhi]pa.Transpose[#]&][[1]]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$ApplyChildOutAutomorphisms"}];
Flocci$ApplyChildOutAutomorphisms::tag="Embed";
Flocci$ApplyChildOutAutomorphisms::input="embedding: embedding of the form {parent,{child},projection matrix}."; 
Flocci$ApplyChildOutAutomorphisms::output="unique projection matrix.";
Flocci$ApplyChildOutAutomorphisms::description="Applies all child outer automorphisms to projection matrix.";

Flocci$ApplyChildOutAutomorphisms[embedding_]:=Module[{outAutom,transResult,uniqueForm,duplicates},
(* applies all child outer automorphisms to projection matrix
Input:      - embedding of the form {parent,{child},projection matrix}
Output:   - list of resulting embeddings of the form {{parent,{child},O1.projection matrix},{parent,{child},O2.projection matrix},...}
 *)

(* generate outer automorphisms for child algebra *)
outAutom=Flocci$OuterAutomorphisms[embedding[[2]]];

(* apply all of the outer automorphisms to the projection matrix and return the result *)
transResult=Sort[DeleteDuplicates[Table[{embedding[[1]],embedding[[2]],Transpose[Transpose[embedding[[3]]][[All,out]]]},{out,outAutom}]]];
uniqueForm=Table[{transResult[[ml]][[1]],transResult[[ml]][[2]],Flocci$Unique\[CapitalLambda]\[Rho][Flatten[{transResult[[ml]][[1]]}],transResult[[ml]][[3]]]},{ml,1,Length[transResult]}];
duplicates=GatherBy[Range@Length[uniqueForm],uniqueForm[[#]]&];
Table[{transResult[[dup[[1]]]],uniqueForm[[dup[[1]],3]]},{dup,duplicates}]//DeleteDuplicates
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$MaximalRegularEmbeddings"}];
Flocci$MaximalRegularEmbeddings::tag="Embed";
Flocci$MaximalRegularEmbeddings::input="s: simple Lie algebra, e.g. A5."; 
Flocci$MaximalRegularEmbeddings::output="list of embeddings of the form {{parent,{child},projection matrix},...}.";
Flocci$MaximalRegularEmbeddings::description="Returns all maximal regular embeddings into s including ones obtained by outer automorphisms on the child algebra.";

Flocci$MaximalRegularEmbeddings[s_]:=Module[{rank},
(* Returns all maximal regular embeddings into s including ones obtained by outer automorphisms on the child algebra
Input:    - simple Lie algebra, e.g. A5
Output:   - list of embeddings of the form {{parent,{child},projection matrix},...}  
*)
rank=Flocci$Rank[s];
Which[
Flocci$TypeAQ[s],
Return[Join@@Map[Flocci$ApplyChildOutAutomorphisms,Flocci$NonSSEmbeddingAn[rank]]],
Flocci$TypeBQ[s],
Return[Join@@Map[Flocci$ApplyChildOutAutomorphisms,Join[Flocci$NonSSEmbeddingBn[rank],Flocci$SSEmbeddingBn[rank]]]],
Flocci$TypeCQ[s],
Return[Join@@Map[Flocci$ApplyChildOutAutomorphisms,Join[Flocci$NonSSEmbeddingCn[rank],Flocci$SSEmbeddingCn[rank]]]],
Flocci$TypeDQ[s],
Return[Join@@Map[Flocci$ApplyChildOutAutomorphisms,Join[Flocci$NonSSEmbeddingDn[rank],Flocci$SSEmbeddingDn[rank]]]],
Flocci$TypeG2Q[s],
Return[Flocci$SSEmbeddingG2],
Flocci$TypeE6Q[s],
Return[Join[Flocci$NonSSEmbeddingE6,Flocci$SSEmbeddingE6]],
Flocci$TypeE7Q[s],
Return[Join[Flocci$NonSSEmbeddingE7,Flocci$SSEmbeddingE7]],
Flocci$TypeE8Q[s],
Return[Flocci$SSEmbeddingE8],
Flocci$TypeF4Q[s],
Return[Flocci$SSEmbeddingF4]
]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$FindPairs"}];
Flocci$FindPairs::tag="Embed";
Flocci$FindPairs::input="ws: weightsystem in format {weight1,weight2,...}."; 
Flocci$FindPairs::output="number of weight pairs.";
Flocci$FindPairs::description="Returns number of (weight,-weight) pairs in weightsystem, including identical pairs, but excluding zero weight vectors.";

Flocci$FindPairs[ws_]:=Module[{woZero,i,wsDoubled,pairCount},
(* Drop zero rows *)
pairCount=0;
woZero=ws;
(*woZero=Select[ws,#!=Table[0,{i,1,Length[ws[[1]]]}]&];*)
For[i=1,i<=Length[woZero],i++,
If[MemberQ[woZero,-woZero[[i]]],pairCount=pairCount+1];
];
Return[pairCount/2];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$FindUniquePairs"}];
Flocci$FindUniquePairs::tag="Embed";
Flocci$FindUniquePairs::input="ws: weightsystem in format {weight1,weight2,...}."; 
Flocci$FindUniquePairs::output="number of unique weight pairs.";
Flocci$FindUniquePairs::description="Returns number of unique (weight,-weight) pairs in weightsystem, excluding zero weight vectors.";

Flocci$FindUniquePairs[ws_]:=Module[{woZero,i,wsDoubled,pairCount,uniqueList},
(* Drop zero rows *)
pairCount=0;
uniqueList=Cases[Tally[ws],{x_,1}:>x];
woZero=Select[uniqueList,#!=Table[0,{i,1,Length[uniqueList[[1]]]}]&];
For[i=1,i<=Length[woZero],i++,
If[MemberQ[woZero,-woZero[[i]]],pairCount=pairCount+1];
];
Return[pairCount/2];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$CheckAlgebraEmbedding"}];
Flocci$CheckAlgebraEmbedding::tag="Embed";
Flocci$CheckAlgebraEmbedding::input="alg: algebra. userWs: user specified weightsystem in format {weight1,weight2,...}."; 
Flocci$CheckAlgebraEmbedding::output="True or False.";
Flocci$CheckAlgebraEmbedding::description="Checks if the algebra alg contains irreps with dimension \[LessEqual] dim(userWS)/3 or dim(userWS) \[GreaterEqual] dimension \[GreaterEqual] dim(userWS)/3 and corresponding weightsystem has  # unique pairs \[LessEqual] pairs in userWS.";

Flocci$CheckAlgebraEmbedding[alg_,userWS_]:=Module[{userWSPairs,userWSDim,irrepList,currrep,bool},
(* checks if the algebra alg contains irreps with dimension <= dim(userWS)/3 or dim(userWS) >= dimension >= dim(userWS)/3 and corresponding weightsystem has  # unique pairs <= pairs in userWS
Output:  - True if there is such an irrep and False otherwise
 *)
userWSDim=Length[userWS];
userWSPairs=Flocci$FindPairs[userWS];
If[Or[Flocci$TypeAQ[alg],Flocci$TypeBQ[alg]]&&(Flocci$Rank[alg]>(userWSDim-1)/2),Return[False]];
If[Or[Flocci$TypeCQ[alg],Flocci$TypeDQ[alg]]&&(Flocci$Rank[alg]>(userWSDim)/2),Return[False]];
irrepList=Drop[Flocci$SimpleIrrepsWithDim[alg,userWSDim],1];
bool=False;
Do[
If[currrep[[1]]<=userWSDim/3,bool=True;Break[]];
If[Flocci$FindUniquePairs[Flocci$WeightSystem[alg,Flatten[currrep[[2]]]]]<=userWSPairs,bool=True;Break[]];
,{currrep,irrepList}];
Return[bool];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$GenerateMaxEmbeddingList"}];
Flocci$GenerateMaxEmbeddingList::tag="Embed";
Flocci$GenerateMaxEmbeddingList::input="userWs: user specified weightsystem in format {weight1,weight2,...}."; 
Flocci$GenerateMaxEmbeddingList::output="list of maximal embeddings of the form {{parent,{child},projection matrix},...}.";
Flocci$GenerateMaxEmbeddingList::description="Generates list of independent maximal embeddings for parent algebras with lowest dimensional irrep \[LessEqual] dim.";

Flocci$GenerateMaxEmbeddingList[userWS_]:=Module[{embeddList,currResults,algList,dim,specialEmbedd,message},
(* generates list of maximal embeddings for parent algebras with lowest dimensional irrep <= dim
  Input:      - upper bound on the lowest dimension of the parent algebra  
Output:     - list of maximal embeddings of the form {{parent,{child},projection matrix},...}
 *)

embeddList={};
dim=Length[userWS];
algList={{"A",1,(dim-1)/2},{"B",3,(dim-1)/2},{"C",2,dim/2},{"D",4,dim/2},{"G",2,Min[2,2+dim-7]},{"F",4,Min[4+dim-26,4]},{"E",6,Min[6+dim-27,6]},{"E",7,Min[7+dim-56,7]},{"E",8,Min[8+dim-248,8]}};
message=PrintTemporary["Generating minimal superalgebras..."];
(* Print["Go through regular embeddings..."];*)
Monitor[
Do[
(*Print[alg[[1]]<>" algebras up to rank "<>ToString[Max[alg[[2]],alg[[3]]]]];*)
Do[
If[!Flocci$CheckAlgebraEmbedding[ToExpression[alg[[1]]<>ToString[fpd]],userWS],Continue[]];
currResults=Flocci$MaximalRegularEmbeddings[ToExpression[alg[[1]]<>ToString[fpd]]];
embeddList=Join[embeddList,currResults];
,{fpd,alg[[2]],alg[[3]]}]
,{alg,algList}]
,{alg[[1]],fpd}]//Timing//Flocci$Timing["genList: regular"];

(*Print["Go through special embeddings..."];*)
specialEmbedd=Flocci$SpecialEmbeddings[userWS]//Timing//Flocci$Timing["genList: special"];
(*Print["Found Special Embeddings"];*)
embeddList=Join[embeddList,Join@@Map[Flocci$ApplyChildOutAutomorphisms,specialEmbedd]]//Timing//Flocci$Timing["genList: unique special"];
(* Add special embeddings for exceptional algebras *)
If[dim>=7&&Flocci$CheckAlgebraEmbedding[G2,userWS],
embeddList=Join[embeddList,Flocci$SpecialEmbeddG2];
];

(*Print["F4"];*)
If[dim >=26&&Flocci$CheckAlgebraEmbedding[F4,userWS],
embeddList=Join[embeddList,Flocci$SpecialEmbeddF4];
];

(*Print["E6"];*)
If[dim>=27&&Flocci$CheckAlgebraEmbedding[E6,userWS],
embeddList=Join[embeddList,Flocci$SpecialEmbeddE6];
];

(*Print["E7"];*)
If[dim>=56&&Flocci$CheckAlgebraEmbedding[E7,userWS],
embeddList=Join[embeddList,Flocci$SpecialEmbeddE7];
];

(*Print["E8"];*)
If[dim>=248&&Flocci$CheckAlgebraEmbedding[E8,userWS],
embeddList=Join[embeddList,Flocci$SpecialEmbeddE8];
];
NotebookDelete[message];
(* Return result *)
Return[DeleteDuplicates[embeddList,(#1[[1,1]]==#2[[1,1]]&&#1[[1,2]]==#2[[1,2]]&&#1[[2]]==#2[[2]])&][[All,1]]];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$MaximalSubAlgebraSimple"}];
Flocci$MaximalSubAlgebraSimple::tag="Embed";
Flocci$MaximalSubAlgebraSimple::input="parentAlg: simple Lie algebra s."; 
Flocci$MaximalSubAlgebraSimple::output="list of inequivalent maximal subalgebras of s with projection matrix in the format {{s,{child1,child2,...},Projection matrix},...}.";
Flocci$MaximalSubAlgebraSimple::description="Returns a list of inequivalent maximal subalgebras of s with projection matrices.";

Flocci$MaximalSubAlgebraSimple[parentAlg_]:=Module[{maxEmbeddList,parentRank,childRankList,algList,specialEmbeddtemp,specialEmbedd},
(* generate list of maximal embeddings into at most parentAlg *)
parentRank=Flocci$Rank[parentAlg];

(* generate regular embeddings *)
maxEmbeddList=Flocci$MaximalRegularEmbeddings[parentAlg](*//Timing//Flocci$Timing["MaximalSubAlgebraSimple: regular"]*);

(* generate special embeddings *)
If[Flocci$classicalQ[parentAlg],
specialEmbeddtemp=Flocci$SpecialEmbeddings[Flocci$WeightSystem[{parentAlg},{PadRight[{1},parentRank]}],False](*//Timing//Flocci$Timing["MaximalSubAlgebraSimple: special"]*);

specialEmbedd=Join@@Map[Flocci$ApplyChildOutAutomorphisms,specialEmbeddtemp](*//Timing//Flocci$Timing["MaximalSubAlgebraSimple: unique special"]*);

(* Add special embeddings for exceptional algebras *)
Which[
Flocci$TypeG2Q[parentAlg],
specialEmbedd=Flocci$SpecialEmbeddG2,
Flocci$TypeF4Q[parentAlg],
specialEmbedd=Flocci$SpecialEmbeddF4,
Flocci$TypeE6Q[parentAlg],
specialEmbedd=Flocci$SpecialEmbeddE6,
Flocci$TypeE7Q[parentAlg],
specialEmbedd=Flocci$SpecialEmbeddE7,
Flocci$TypeE8Q[parentAlg],
specialEmbedd=Flocci$SpecialEmbeddE8
]
];

(* Delete equivalent ones *)
maxEmbeddList=Join[maxEmbeddList,Select[specialEmbedd,#[[1,1]]==parentAlg&]];


(* Delete equivalent ones *)
maxEmbeddList=DeleteDuplicates[maxEmbeddList,(#1[[1,1]]==#2[[1,1]]&&#1[[1,2]]==#2[[1,2]]&&#1[[2]]==#2[[2]])&][[All,1]];

Return[maxEmbeddList]

]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$MaximalSubAlgebraSS"}];
Flocci$MaximalSubAlgebraSS::tag="Embed";
Flocci$MaximalSubAlgebraSS::input="parentAlg: semi-simple Lie algebra {s1,s2,...}."; 
Flocci$MaximalSubAlgebraSS::output="list of inequivalent maximal subalgebras of s with projection matrix in the format {{{s1,s2,...},{child1,child2,...},Projection matrix},...}.";
Flocci$MaximalSubAlgebraSS::description="Returns a list of inequivalent maximal subalgebras of {s1,s2,...} with projection matrices.";

Flocci$MaximalSubAlgebraSS[parentAlg_List]:=Module[{maxEmbeddtemp,maxEmbedd,maxEmbeddListstep1,i,idList,currList,diagF,maxEmbeddList,A1Pos,maxEmbeddListstep2,doubles,doublesPos,doub,maxEmbeddListstep3,RankList,currMat},
(* If parentAlg contains only one algebra, return the result of Flocci$MaximalSubAlgebraSimple *)
RankList=Flocci$Rank[parentAlg];
If[Length[parentAlg]==1,Return[Flocci$MaximalSubAlgebraSimple[parentAlg[[1]]]]];

(* 1. consider branching of one of the simple factors *)
idList=Table[{parentAlg[[i]],{parentAlg[[i]]},IdentityMatrix[Flocci$Rank[parentAlg[[i]]]]},{i,1,Length[parentAlg]}];
maxEmbeddListstep1=Join@@Table[Map[(currList=idList;currList[[i]]=#;currList)&,If[parentAlg[[i]]===A1,{{A1,{A1},{{1}}}},Flocci$MaximalSubAlgebraSimple[parentAlg[[i]]]]],{i,1,Length[parentAlg]}];

diagF=Normal[SparseArray[Band[{1,1}]->{##}]]&;
(* Reassamble embeddings *)
maxEmbeddListstep1=Map[{#[[All,1]],Flatten[#[[All,2]]],diagF@@#[[All,3]]}&,maxEmbeddListstep1];

(* 2. Delete A1's *)
A1Pos=Position[parentAlg,A1];
If[Length[A1Pos]>0,
maxEmbeddListstep2=Table[{parentAlg,Delete[parentAlg,A1Pos[[i]]],Delete[IdentityMatrix[Total[RankList]],A1Pos[[i]]]},{i,1,Length[A1Pos]}],
maxEmbeddListstep2={}];

(* 3. Diagonal Embeddings *)
doubles=Cases[Tally@parentAlg,{x_,n_/;n>1}:>x];
maxEmbeddListstep3=Table[doublesPos=Sort[Subsets[Flatten[Position[parentAlg,doub]],{2}][[1]]];
currMat=Join@@DeleteCases[Table[If[!MemberQ[doublesPos,i],PadRight[PadLeft[IdentityMatrix[RankList[[i]]],{RankList[[i]],Total[RankList[[1;;i]]]}],{RankList[[i]],Total[RankList]}],If[i==doublesPos[[1]],PadRight[ArrayFlatten[{{PadRight[PadLeft[IdentityMatrix[RankList[[i]]],{RankList[[i]],Total[RankList[[1;;i]]]}],{RankList[[i]],Total[RankList[[1;;doublesPos[[2]]-1]]]}],IdentityMatrix[RankList[[i]]]}}],{RankList[[i]],Total[RankList]}]]
],{i,1,Length[parentAlg]}],Null];
{parentAlg,Delete[parentAlg,doublesPos[[2]]],currMat}
,{doub,doubles}];

maxEmbeddtemp=DeleteDuplicates[Map[Flocci$CanonicalizeEmbedding,Join[maxEmbeddListstep1,maxEmbeddListstep2,maxEmbeddListstep3]]];
maxEmbedd=Join@@Map[Flocci$ApplyChildOutAutomorphisms,maxEmbeddtemp];

Return[DeleteDuplicates[maxEmbedd,(#1[[1,1]]==#2[[1,1]]&&#1[[1,2]]==#2[[1,2]]&&#1[[2]]==#2[[2]])&][[All,1]]];

]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$CanonicalizeEmbedding"}];
Flocci$CanonicalizeEmbedding::tag="Embed";
Flocci$CanonicalizeEmbedding::input="embedd: embedding of the form {parentAlg,{child1,child2,...},projection matrix}."; 
Flocci$CanonicalizeEmbedding::output="{parentAlg,{child1,child2,...},projection matrix} with child algebra lexicographically sorted and projection matrix adjusted.";
Flocci$CanonicalizeEmbedding::description="Sorts the child algebras lexicographically and adjusts the projection matrix accordingly.";

Flocci$CanonicalizeEmbedding[embedd_]:=Module[{sortList,indexList,algList,i,rankList},
algList=embedd[[2]];
rankList=Flocci$Rank[algList];
sortList=Ordering[algList];
indexList=Flatten[Table[Range[Total[rankList[[1;;i-1]]]+1,Total[rankList[[1;;i]]]],{i,1,Length[sortList]}][[sortList]]];
Return[{embedd[[1]],algList[[sortList]],embedd[[3,indexList]]}]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$MinimalSupAlgebras"}];
Flocci$MinimalSupAlgebras::tag="Embed";
Flocci$MinimalSupAlgebras::input="gt: algebra in format {s1,s2,...}."; 
Flocci$MinimalSupAlgebras::output="list of minimal superalgebras and projection matrix in the format {{parent,projection matrix},...}.";
Flocci$MinimalSupAlgebras::description="This takes in a gt, and a list of maximal embeddings into simple Lie algebras. It outputs the corresponding list of minimal super-algebras of gt.";
Flocci$MinimalSupAlgebras::clear="3";
Flocci$MinimalSupAlgebras[gt_,maxlist_]:=Flocci$MinimalSupAlgebras[gt,maxlist]=Module[{maximal,ranklist,rank,g, \[CapitalLambda],\[CapitalLambda]identity,\[CapitalLambda]p,format,gtmaxlist,si,\[CapitalLambda]i,subsets,gsub,gsubind,gsubSorted,\[CapitalLambda]sub,\[CapitalLambda]mPart,id,out},(*This assumes that gt is sorted*)
maximal={};
ranklist=Flocci$Rank[gt];
rank=Total[ranklist];
\[CapitalLambda]identity=Table[Join[ConstantArray[0,{Total[Take[ranklist,{1,i-1}]],ranklist[[i]]}],IdentityMatrix[ranklist[[i]]],ConstantArray[0,{Total[Take[ranklist,{i+1,-1}]],ranklist[[i]]}]],{i,1,Length[ranklist]}];

(*Step: We define a function which formats our pair (g,\[CapitalLambda]) which defines the minimal super algebra.*)
format[g_,\[CapitalLambda]p_]:=Module[{gsort, \[CapitalLambda]psort},
gsort=Sort[g];
\[CapitalLambda]psort=Sort[Table[{g[[i]],\[CapitalLambda]p[[i]]},{i,1,Length[g]}]][[All,2]];
{gsort,Map[Flatten,Transpose[\[CapitalLambda]psort]]} (*I'm confused why I don't have a transpose here*)

] ;
(*Step: We include in our list the embedding gt\[Rule]gt+A1 where gt\[Rule]A1 is the zero map.*)
g=Flatten[{gt,A1}];
\[CapitalLambda]p=Append[\[CapitalLambda]identity,ConstantArray[0,{rank,1}]];
AppendTo[maximal,format[g,\[CapitalLambda]p]];

(*Step: Let s be a simple ideal in gt. Then we include in our list the embedding gt\[Rule]gt+s, where s\[Rule]s+s is the diagonal embedding.*)
Do[
g=Append[gt, gt[[i]]];
\[CapitalLambda]p=Append[\[CapitalLambda]identity,\[CapitalLambda]identity[[i]]];
AppendTo[maximal,format[g,\[CapitalLambda]p]];
,{i, 1,Length[gt]}];


(*For each sit in gt, which sits maximally in si, then g has sit replaced with si.*)
(*Taking a subset {s1,s2,s3} of simple ideals of gt, and asking if there is a maximal embedding {s1,s2,s3}\[Rule] M for some simple M.
If there is, then replacing {s1,s2,s3} in gt with M gives a maximal embedding.
*)
(*Step: *)
subsets=Select[Subsets[Range[Length[gt]]],Length[#]> 0 &]; (*We need subsets of indices, rather thne subsets of the algebras themselves, as this is on gt, and *)

Do[
gsub=gt[[sub]] ;
gtmaxlist=Select[maxlist,Sort[#[[2]]]==Sort[gsub]&]; (* I'm assuming that maxlist has two embeddings for each e.g. A1x A1\[Rule] D4, which are inequivelent on swapping *)

Do[
gsubind=Table[{gsub[[i]],sub[[i]]}, {i,1,Length[sub]}];
gsubSorted=SortBy[gsubind,
Function[s,
Position[m[[2]],s[[1]]][[
Position[Select[gsubind, Function[p,p[[1]]==s[[1]]]],s][[1]]
]]]]; (*This sorts gsubind to match the ordering of m\[LeftDoubleBracket]2\[RightDoubleBracket], for example if m\[LeftDoubleBracket]2\[RightDoubleBracket]={A1,A2,A1}, then gsubSorted={{Subscript[A, 1],1},{Subscript[A, 2],3},{Subscript[A, 1],2}} or similar*)

\[CapitalLambda]mPart= TakeList[m[[3]],Flocci$Rank[m[[2]]]];(*We want to partition m\[LeftDoubleBracket]3\[RightDoubleBracket] into rows for each seperate simple ideal of the subalgebra.*)
(*We now want to from our new part of the projection matrix*)
\[CapitalLambda]i=Join@@Table[
If[MemberQ[sub,r],
id=Position[gsubSorted[[All,2]],r][[1,1]];
\[CapitalLambda]mPart[[id]]
,
ConstantArray[0,{Flocci$Rank[gt[[r]]],Length[m[[3]][[1]]]}]
]
,{r,Range[Length[gt]]}];
g=Append[Delete[gt,Map[{#}&,sub]],m[[1]]];
\[CapitalLambda]p=Append[Delete[\[CapitalLambda]identity,Map[{#}&,sub]],\[CapitalLambda]i];
AppendTo[maximal,format[g,\[CapitalLambda]p]];
,{m,gtmaxlist}]
,{sub,subsets}];
(*Step: We remove any embedding which is an automorphism.*)
maximal=Select[maximal,!(#[[1]]===gt) &];
(*Step: The code below puts \[CapitalLambda]\[Rho] into a unique form. As long as the inputed list of maximal algebras is in this form, however, I don't think we get any duplicates so we can ignore this step.*)
(*Map[{#\[LeftDoubleBracket]1\[RightDoubleBracket],Flocci$Unique\[CapitalLambda]\[Rho][#\[LeftDoubleBracket]1\[RightDoubleBracket],#\[LeftDoubleBracket]2\[RightDoubleBracket]]} &,maximal]//DeleteDuplicates;*)
maximal
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$PartitionsWithinBlocks"}];
Flocci$PartitionsWithinBlocks::tag="U1";
Flocci$PartitionsWithinBlocks::input="vecIn: A lexicographically sorted 2-tensor e.g. {{1,-1},{2,-3},{4,-6}}.\nblockParent: A 1-tensor e.g. {1,1,1}. \nchildBlock: A 1-tensor e.g. {2,1}. \nchildBlockRange: A 2-tensor e.g. {{1,2},{3,3}}.";
Flocci$PartitionsWithinBlocks::output="A 1-tensor of a stream of charges: {1,-1,2,-3,2,-3,1,-1,4,-6,8,2}";
Flocci$PartitionsWithinBlocks::description="Finds inequivelent partitions within blocks. 
Inequivelent permutations of vecIn are found within each childBlock. Permutations within blockParent are considered equivelent. The output is a stream of charges where permutations within each childBlock are placed next to each other.";
Flocci$PartitionsWithinBlocks=Compile[{{vecIn,_Integer,2},{blockParent,_Integer,1},{childBlock,_Integer,1},{childBlockRange,_Integer,2}},
(*The input to this code is:
A 2-tensor vecIn e.g. {{1,-1},{2,-3},{4,-6}}. This is the thing we want to permute. It is assumed this is sorted lexicographically.
A 1-tensor blockParent e.g. {1,1,1}. Permutations within these blocks are considered equivelent, and we only output one.
A 1-tensor blockChild e.g. {2,1}. Permutations within these blocks are considered seperatly. 
A 2-tensor childBlockRange. For the above example this would be {{1,2},{3,3}}. It indicates which parent blocks sit in which child blocks.

The output for the above example is: {1,-1,2,-3,2,-3,1,-1,4,-6,8,2}.
*)
Module[{accChild,vecList,lengthPerChild,vec,vecdim1,vecdim2,counter,blocksizes,acc,vecold,currentParentBlock,parentZero,parentEndp1,posInParent,posToSwap,vecnew,vecnew2,posToSwapStartP1,posSorting},
accChild=Accumulate[childBlock];
vecList=Internal`Bag@Most[{0}]; (*This will contain our stream of charges*)
lengthPerChild=Internal`Bag@Most[{0}]; (*This will contain a list of how long each stream is, for a given child*)
vecdim2=Length[vecIn[[1]]];
Do[(*We have a large loop over the child blocks. Since these are considered seperatly.*)
(*We extract the corresponding part of vecIn for this child.*)
vec=Take[vecIn,{If[currentChild==1,1,accChild[[currentChild-1]]+1],accChild[[currentChild]]}]; (*This is a 2-tensor.*)
(*We get the dimensions of vec. This helps us keep track of the counter, along with vecdim2.*)
vecdim1=Length[vec];
(*We insert vec into vecList. This is our first permutation. We also set our counter as the dimension of vec*)
Internal`StuffBag[vecList,vec,2];
counter=vecdim1;
(*We exctract the blocks for this child algebra. This is the reason we need childBlockRange as an input. *)
blocksizes=Take[blockParent,childBlockRange[[currentChild]]];
acc=Accumulate[blocksizes];
While[True,(*We now want to create all other permutations.*)
vecold=vec;
(*Starting at the second last parent block, we loop through them.*)
currentParentBlock=Length[blocksizes];
While[--currentParentBlock>= 0, 
(*If we reach currentParentBlock\[Equal]0, then we have generated all permutations, and we can stop.*)
If[currentParentBlock==0,vec={{-1}};Break[];];
parentZero=If[currentParentBlock==1,0,acc[[currentParentBlock-1]]];(*The index just before the start of the current parent block*)
parentEndp1=blocksizes[[currentParentBlock]]+parentZero+1;(*The index just after the end of the current parent block*)
(*We find the first position in the parent algebra which can be advanced.*)
posInParent=parentEndp1-1;
While[posInParent!= parentZero&&OrderedQ[ {vecold[[parentEndp1-1+blocksizes[[currentParentBlock+1]]]],vecold[[posInParent]]}],posInParent--];

If[posInParent==parentZero,
(*if posInParent\[Equal]parentZero we want to put the order back to lexicographic in the region {parentZero+1,-1}*)
vec[[Range[parentZero+1,vecdim1]]]=Sort[vec[[Range[parentZero+1,vecdim1]]]];
,
(*Else we want to start at the end of vec, and the first element we can advance by. This is the smallest element which is larger then vec\[LeftDoubleBracket]posInParent\[RightDoubleBracket] *)
posToSwap=vecdim1;
While[posToSwap>parentEndp1&&OrderedQ[{vec[[posInParent]],vec[[posToSwap-1]]}]&&vec[[posInParent]]!= vec[[posToSwap-1]],posToSwap--];

(*We now want to rearange the output *)
vecnew=vec;
(*We swap posInParent and posToSwap*)
vecnew[[posInParent]]=vec[[posToSwap]];
vecnew[[posToSwap]]=vec[[posInParent]];
vecnew2=vecnew;
(*We now want to sort collectively {posInParent+1,parentEndp1-1} and {posToSwap+1,vecLen}*)
posSorting=++posInParent;
posToSwapStartP1=++posToSwap;
If[posSorting==parentEndp1,posSorting=posToSwapStartP1];
While[posSorting!= vecdim1+1,
If[posInParent==parentEndp1||(posToSwap!= vecdim1+1&&vecnew[[posToSwap]]!= vecnew[[posInParent]]&&OrderedQ[{vecnew[[posToSwap]],vecnew[[posInParent]]}]),vecnew2[[posSorting]]=vecnew[[posToSwap++]];,vecnew2[[posSorting]]=vecnew[[posInParent++]];];
If[(++posSorting)==parentEndp1,posSorting=posToSwapStartP1];
];
vec=vecnew2;
Break[];
];
];
(*We save the new permutation.*)
If[vec=={{-1}},Break[]];
Internal`StuffBag[vecList,vec,2];
counter+=vecdim1;
];
(*We save the counter for this child*)
Internal`StuffBag[lengthPerChild,counter];
,{currentChild,1,Length[childBlock]}];

Join[Internal`BagPart[vecList,All],Internal`BagPart[lengthPerChild,All]]
],CompilationTarget->"C",Parallelization->True];

Flocci$PartitionsWithinBlocks[{{1},{2},{4}},{1,1,1},{2,1},{{1,2},{3,3}}]//RepeatedTiming


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$PermutationsWithinBlocks"}];
Flocci$PermutationsWithinBlocks::tag="U1";
Flocci$PermutationsWithinBlocks::input="cList) A 3-Tensor of charges where each element is a list Transpose[{c1,c2,...,cn}] e.g. { {{1,-1},{2,-3},{4,-6}}, {{2,-3},{1,-1},{4,-6}} }.\nblockParent) A 1-tensor with lists of sizes of blocks e.g. {2,1}. \nprependcharges) A 3-vector of charges to prepend e.g. {{{0,0}},{{1,1}}} of the same length as cList or {}.";
Flocci$PermutationsWithinBlocks::output="A 3-tensor of integeres. For the example in the input: \!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"0\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"0\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"1\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"-\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"1\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"2\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"-\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"3\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"4\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"-\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"6\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"0\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"0\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"2\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"-\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"3\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"1\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"-\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"1\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"4\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"-\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"6\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"1\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"1\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"2\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"-\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"3\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"1\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"-\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"1\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"{\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"4\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\",\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"-\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"6\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)\!\(\*
StyleBox[\"}\",\nFontColor->GrayLevel[0.5]]\)";

Flocci$PermutationsWithinBlocks::description="For each Ei in cList permutations in each block in blockParent are found. The charges in prependCharges are prepended to each permutation.";
Flocci$PermutationsWithinBlocks=Compile[{{cList,_Integer,3},{blockParent,_Integer,1},{prependCharges,_Integer,3}},
(*The input is:
1) A list of charges e.g. { {{1,-1},{2,-3},{4,-6}}, {{2,-3},{1,-1},{4,-6}} }
 2) A list of the sizes of parent bocks e.g. {2,1}. It is within these parent blocks which we find permutations.
3) A list of charges which should be prepend onto our charges. e.g. {{{0,0}},{{1,1}}}.

The output for the above example is: {{{0,0},{1,-1},{2,-3},{4,-6}},{{0,0},{2,-3},{1,-1},{4,-6}},{{1,1},{2,-3},{1,-1},{4,-6}}}
*)
Block[{cpos,cpos1,toAdvanceTo,cnew,accParent,currentblockEnd,tobreak,cbag,lengthPerCharge,counter}, 
accParent=Accumulate[blockParent];
cbag=Internal`Bag@Most[{0}];
counter=0;
Do[
cnew=c;
counter++;
While[cnew!= {{-1}},
If[Length[prependCharges]!= 0,Internal`StuffBag[cbag,prependCharges[[counter]],2]];
Internal`StuffBag[cbag,cnew,2];
(*We start at the end of the vector and move backwards*)
cpos=Length[cnew];
tobreak=False;
While[True,
(*We want to find the first cpos which can be advanced. This means, it satisfies cnew\[LeftDoubleBracket]cpos\[RightDoubleBracket]<cnew\[LeftDoubleBracket]cpo+1\[RightDoubleBracket] and is not the end of a block.*)
cpos1=cpos;
--cpos;
If[cnew[[cpos]]!=  cnew[[cpos1]]&&OrderedQ[{cnew[[cpos]],cnew[[cpos1]]}]&&!MemberQ[accParent,cpos],(*Find the largest k for which v[k]<v[k+1] and k not an end.*)
(*We find the end of the block we are currently in.*)
currentblockEnd=Select[accParent,#>cpos&][[1]];(*Get the last position*)
(*We find the smallest value in the block which we can use to advance our current position*)
toAdvanceTo=currentblockEnd;
While[OrderedQ[{cnew[[toAdvanceTo]],cnew[[cpos]]}], --toAdvanceTo;]; (*Find the largest l such that a[k]<a[l]*)
(*We swap the cpos and toAdvanceTo position.*)
cnew[[{toAdvanceTo,cpos}]]=cnew[[{cpos,toAdvanceTo}]]; (*swap a[k] and a[l]*)
(*We then sort the list from cpos1 to currentblockEnd*)
cnew[[Range[cpos1,currentblockEnd]]]=Reverse[cnew[[Range[cpos1,currentblockEnd]]]];(*reverse the list after k+1*) 
(*We now want to reverse the remaining blocks*)
(*We now reverse the remaining blocks.*)
Do[(*reverse the b-b+1 block - would probably be faster if went the other way*)
If[accParent[[b]]<currentblockEnd,Continue[]];
cnew[[Range[accParent[[b]]+1,accParent[[b+1]]]]]=Reverse[cnew[[Range[accParent[[b]]+1,accParent[[b+1]]]]]];(*reverse the list after k+1*) 
,{b,1, Length[blockParent]-1}];
(*We now break out of the loop of k*)
Break[];
];
(* If cpos is {-1} at this point, then we have reached the end and our list is in reverse lexicographic ordering. We stop.*)
If[cpos==1,cnew={{-1}};Break[];];
];
];

,{c,cList}];
(*Partition[Internal`BagPart[cbag,All],Length[cList\[LeftDoubleBracket]1\[RightDoubleBracket]]+Length[prependCharges\[LeftDoubleBracket]1\[RightDoubleBracket]]]*)
Partition[Partition[Internal`BagPart[cbag,All],Length[cList[[1,1]]]],Length[cList[[1]]]+If[Length[prependCharges]!= 0,Length[prependCharges[[1]]],0]]
]
,CompilationTarget->"C",Parallelization->True];
Flocci$PermutationsWithinBlocks[ { {{1,-1},{2,-3},{4,-6}}, {{2,-3},{1,-1},{4,-6}} },{2,1},{{{0,0}},{{1,1}}}]//StandardForm


(* ::Input::Initialization:: *)

Flocci$PermutationsWithinBlocksConditional=Compile[{{cList,_Integer,3},{blockParent,_Integer,1},{prependCharges,_Integer,3},{equalpairs,_Integer,2}},
(*The input is:
1) A list of charges e.g. { {{1,-1},{2,-3},{4,-6}}, {{2,-3},{1,-1},{4,-6}} }
 2) A list of the sizes of parent bocks e.g. {2,1}. It is within these parent blocks which we find permutations.
3) A list of charges which should be prepend onto our charges. e.g. {{{0,0}},{{1,1}}}.

The output for the above example is: {{{0,0},{1,-1},{2,-3},{4,-6}},{{0,0},{2,-3},{1,-1},{4,-6}},{{1,1},{2,-3},{1,-1},{4,-6}}}
*)

Block[{cpos,cpos1,toAdvanceTo,cnew,accParent,currentblockEnd,tobreak,cbag,lengthPerCharge,counter,equalpairsBool,cdeBag,cJoined,max}, 
accParent=Accumulate[blockParent];
cbag=Internal`Bag@Most[{0}];
counter=0;
Do[
cnew=c;
counter++;
While[cnew!= {{-1}},
(*We test the equal pairs condition. If it fails, we skip all permutation which will change the point it fails at. - JTS:31/12/22 *)
equalpairsBool=-1;

cJoined=If[Length[prependCharges]!=0,Join[prependCharges[[counter]],cnew],cnew];

Do[
If[cJoined[[pair[[1]]]]!= cJoined[[pair[[2]]]],
max=Max[pair];
If[Length[prependCharges]==0||max-Length[prependCharges[[counter]]]>0,
equalpairsBool=If[Length[prependCharges]!=0,max-Length[prependCharges[[counter]]],max];
 Break[];
];
];
,{pair,equalpairs}];

(*If it does not satisfy the equal pairs condition, we put cnew in it's minimal lexicographic configuration past the point equalpairsBool*)
 If[equalpairsBool!= -1,
(*We find the end of the block we are currently in.*)
currentblockEnd=Select[accParent,#>= equalpairsBool&][[1]];(*Get the last position*)
(*We then sort the list from equalpairsBool+1 to currentblockEnd*)
If[equalpairsBool!=currentblockEnd,
 cnew[[Range[equalpairsBool+1,currentblockEnd]]]=Reverse[cnew[[Range[equalpairsBool+1,currentblockEnd]]]]];
(*We now reverse the remaining blocks.*)
Do[(*reverse the b-b+1 block - would probably be faster if went the other way*)
If[accParent[[b]]<currentblockEnd,Continue[]];
cnew[[Range[accParent[[b]]+1,accParent[[b+1]]]]]=Reverse[cnew[[Range[accParent[[b]]+1,accParent[[b+1]]]]]];(*reverse the list after k+1*) 
,{b,1, Length[blockParent]-1}];
];
(*We add to our list, if it satisfies the equal pair condition *)
If[equalpairsBool==-1,
If[Length[prependCharges]!= 0,Internal`StuffBag[cbag,prependCharges[[counter]],2]];
Internal`StuffBag[cbag,cnew,2];
];
(*We start at the end of the vector and move backwards*)
cpos=Length[cnew];
tobreak=False;
While[True,
(*We want to find the first cpos which can be advanced. This means, it satisfies cnew\[LeftDoubleBracket]cpos\[RightDoubleBracket]<cnew\[LeftDoubleBracket]cpo+1\[RightDoubleBracket] and is not the end of a block.*)
cpos1=cpos;
--cpos;
If[cnew[[cpos]]!=  cnew[[cpos1]]&&OrderedQ[{cnew[[cpos]],cnew[[cpos1]]}]&&!MemberQ[accParent,cpos],(*Find the largest k for which v[k]<v[k+1] and k not an end.*)
(*We find the end of the block we are currently in.*)
currentblockEnd=Select[accParent,#>cpos&][[1]];(*Get the last position*)
(*We find the smallest value in the block which we can use to advance our current position*)
toAdvanceTo=currentblockEnd;
While[OrderedQ[{cnew[[toAdvanceTo]],cnew[[cpos]]}], --toAdvanceTo;]; (*Find the largest l such that a[k]<a[l]*)
(*We swap the cpos and toAdvanceTo position.*)
cnew[[{toAdvanceTo,cpos}]]=cnew[[{cpos,toAdvanceTo}]]; (*swap a[k] and a[l]*)
(*We then sort the list from cpos1 to currentblockEnd*)
cnew[[Range[cpos1,currentblockEnd]]]=Reverse[cnew[[Range[cpos1,currentblockEnd]]]];(*reverse the list after k+1*) 
(*We now want to reverse the remaining blocks*)
(*We now reverse the remaining blocks.*)
Do[(*reverse the b-b+1 block - would probably be faster if went the other way*)
If[accParent[[b]]<currentblockEnd,Continue[]];
cnew[[Range[accParent[[b]]+1,accParent[[b+1]]]]]=Reverse[cnew[[Range[accParent[[b]]+1,accParent[[b+1]]]]]];(*reverse the list after k+1*) 
,{b,1, Length[blockParent]-1}];
(*We now break out of the loop of k*)
Break[];
];
(* If cpos is {-1} at this point, then we have reached the end and our list is in reverse lexicographic ordering. We stop.*)
If[cpos==1,cnew={{-1}};Break[];];
];
];

,{c,cList}];
(*Partition[Internal`BagPart[cbag,All],Length[cList\[LeftDoubleBracket]1\[RightDoubleBracket]]+Length[prependCharges\[LeftDoubleBracket]1\[RightDoubleBracket]]]*)

cdeBag=Internal`BagPart[cbag,All];
If[Length[cdeBag]!= 0,Partition[Partition[cdeBag,Length[cList[[1,1]]]],Length[cList[[1]]]+If[Length[prependCharges]!= 0,Length[prependCharges[[1]]],0]],{{{-199}}}]
]
,CompilationTarget->"C",Parallelization->True];




(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$OuterPlus"}];
Flocci$OuterPlus::input="l: A 3-tensor of integers.\np: A 2-tensor of integers. \nf: A 2-tensor of integers.";
Flocci$OuterPlus::output="A 2-tensor of integer positions.";
Flocci$OuterPlus::description="Position[Outer[Plus,Take[l,p\[LeftDoubleBracket]1\[RightDoubleBracket]],Take[l,p\[LeftDoubleBracket]2\[RightDoubleBracket]],...,],f]. \!\(\*
StyleBox[\"This\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"somehow\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"needs\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"generalizing\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\".\",\nFontColor->RGBColor[1, 0, 0]]\)";
Flocci$OuterPlus::tag="U1";
Flocci$OuterPlus=ReleaseHold@(Hold[Compile[{{l,_Integer,3},{p,_Integer,2},{f,_Integer,2}},
T1;
{{1}}
,CompilationTarget->"C",Parallelization->True]]/.T1->WhichT@@Join[{LengthT[p]==1,ReturnT[PositionT[l,f]]},Flatten[Table[{EqualT[LengthT[p],np],ReturnT[PositionT[(OuterT@@Append[Prepend[Table[TakeT[l,PartT[p,i]],{i,1,np}],Plus],1]),f]]},{np,2,30}],1]]/. OuterT->Outer/. PositionT-> Position/. PartT-> Part/. TakeT-> Take/. EqualT-> Equal/. LengthT-> Length/. WhichT-> Which/. ReturnT-> Return)(*The number 10 here may need generalizing*)


(* ::Input::Initialization:: *)
(*Step 1: We go through each child block indivdually: i) Find permutations based on parent blocks. ii) Find the vector X when each permutation is dotted with XiXj. iii) We add to the list Xlist, the counter of what permutations we actually need in terms of their permutation sequence.*)

(*Step 2: We do a multi-index loop over the list ValList, based on the length of the array sizes. We collect a list of lists of values which added together give zero.*) 

(*Step 3: We then go through this list of list of values, and recombine the allowed permutations with them*)
Flocci$anomalyFreeU1Addition::input="childCharges) A 3-tensor of integers where each entry is a set of charges Transpose[{c1,c2,...cn}].\nchild\[CapitalPhi]) The weight system of the child algebra.\nparent\[CapitalPhi]) The weight system of the parent algebra.\n\[CapitalLambda]\[Rho]) The projection matrix from the parent to the child.";
Flocci$anomalyFreeU1Addition::output="A 3-tensor of charges.";
Flocci$anomalyFreeU1Addition::description="childCharges are the charges which work frm the child algebra. Considers all permutations of charges in childCharges within childblocks. Charges related by perumtations within parentblocks are considered equivelent, and only a representative is formed. Let c be such a set of charges. Then we output if Tr[XiXjck]=0 for all Xi, Xj and ck. \!\(\*
StyleBox[\"Should\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"also\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"do\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\" \",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"Tr\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"[\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"Xicjck\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\"]\",\nFontColor->RGBColor[1, 0, 0]]\)\!\(\*
StyleBox[\".\",\nFontColor->RGBColor[1, 0, 0]]\)";
Flocci$FunctionListAdd[{"Flocci$anomalyFreeU1Addition"}];
Flocci$anomalyFreeU1Addition::tag="U1";
Flocci$anomalyFreeU1Addition=Compile[{{childCharges,_Integer,3},{child\[CapitalPhi],_Integer,2},{parent\[CapitalPhi],_Integer,2},{\[CapitalLambda]\[Rho],_Integer,2}},
Block[{ord,\[CapitalPhi]\[Beta]s,XiXj,blockChild,accChild,blockParent,accParent,childBlockRangec,childBlockRange,posChildParentBlocks,constChild,varChild,XiXj1,XiXj2,bool1,posij,childCharges1,allValidSol,constPositionsc,constPositions,childChargesv,blockChildv,blockParentv,childBlockRangev,childBlockRangecv,ord2,ord3,c,chargeStreamRaw,chargeStream,dimraw,chargeStreamDim,currentChildBlock,XSol,chargeList,XiXj2c,XiXj2v,childBlockXiXj,childXiXjCha,childXiXjChadd,mulInVec,mulIndexZero,corresondingChargesChild,ordInv},
(*We find the ordering of the parent\[CapitalPhi] which maps onto child\[CapitalPhi].*)
ord=Ordering[Table[Join[\[CapitalLambda]\[Rho].p,p],{p,parent\[CapitalPhi]}]];(*A list of numbers*)
ord3=ord;
(*We find the matrix XiXj, which appears in our Tr(XiXjY)*)
\[CapitalPhi]\[Beta]s=Transpose[parent\[CapitalPhi][[ord]]];
XiXj=Flatten[Outer[Times,\[CapitalPhi]\[Beta]s, \[CapitalPhi]\[Beta]s,1],1]//DeleteDuplicates;
(*For the child node, we find the lengths of the blocks of similar weights*)
accChild=Append[Flatten[Position[Table[If[child\[CapitalPhi][[i]]==child\[CapitalPhi][[i+1]],1,0],{i,1,Length[child\[CapitalPhi]]-1}],0]],Length[child\[CapitalPhi]]];
blockChild=accChild-Prepend[Drop[accChild,-1],0];
childBlockRangec=Transpose[{Prepend[Drop[accChild,-1],0]+1,accChild}];
(*For the parent node, we find the lengths of the blocks of similar weights*)
accParent=Append[Flatten[Position[Table[If[parent\[CapitalPhi][[ord[[i]]]]==parent\[CapitalPhi][[ord[[i+1]]]],1,0],{i,1,Length[parent\[CapitalPhi]]-1}],0]],Length[parent\[CapitalPhi]]];
blockParent=accParent-Prepend[Drop[accParent,-1],0];
(*We determine how the parent blocks sit in the child blocks.*)
posChildParentBlocks=Flatten[Map[Position[accParent,# ]&,accChild]];
childBlockRange=Transpose[{Prepend[Drop[posChildParentBlocks,-1],0]+1,posChildParentBlocks}];
(*We extract the child blocks which are constant. These either have the parent length equal to the child length, or constant charges*)
constChild=Select[Range[Length[blockChild]],childBlockRange[[#,1]]==childBlockRange[[#,2]]||Length[DeleteDuplicates[Flatten[ Take[childCharges,All,{If[#==1,1,accChild[[#-1]]+1],accChild[[#]]}],1]]]==1&]; 
varChild=Complement[Range[Length[blockChild]],constChild];
(*We want to split XiXj into 2 types of rows: 
1) Those which are independent of permutations within varChild.
2) Those which depend on permutations within varChild.*)
posij=Position[Table[Length[DeleteDuplicates[Take[row,childBlockRangec[[v]]]]],{row,XiXj},{v,varChild}],Table[1,{i,1,Length[varChild]}]]//Flatten;
XiXj1=If[Length[posij]!= 0,XiXj[[posij]],{ConstantArray[0,Length[childCharges[[1]]]]}];

(*We first deal with XiXj1, and select only those child charges which satisfy the conditions on this*)
childCharges1=Select[childCharges,Count[XiXj1.#,0,{2}]==Length[childCharges[[1,1]]]*Length[XiXj1]&];
(*We now turn to XiXj2. We split this situation into 3 cases:
1) varChild={}. In which cases, there are no permutations to do.
2) XiXj2={}, In which case all permutations are valid.
3) Generic
*)
allValidSol={childCharges[[1]]};

(*Case 1: varChild={}. There are no permutations to do. The if statement here extends to the bottom*)
If[Length[childCharges1]!= 0,If[ Length[varChild]==0,allValidSol=Join[allValidSol,childCharges1];,

(*Case 2&3*)
childChargesv=childCharges1;
blockParentv=blockParent;
blockChildv=blockChild;
childBlockRangecv=childBlockRangec;
childBlockRangev=childBlockRange;
constPositionsc=Drop[{0},1];

If[Length[childCharges1]!= 0&& Length[varChild]!= 0&&Length[constChild]!= 0,
(*We get the ranges in c, and the parent blocks corresponding to constant positions.*)
constPositions=Drop[{0},1];
Do[
constPositionsc=Join[constPositionsc,Range[childBlockRangec[[v,1]],childBlockRangec[[v,2]]]];
constPositions=Join[constPositions,Range[childBlockRange[[v,1]],childBlockRange[[v,2]]]];
,{v,constChild}];

(*We extract the parts of the charges which are varible. We likewise get the blocks of the childs and parents.*)
childChargesv=childCharges1[[All,Complement[Range[Length[childCharges1[[1]]]],constPositionsc]]];
blockChildv=blockChild[[varChild]];
blockParentv=blockParent[[Complement[Range[Length[blockParent]],constPositions]]];
childBlockRangev=Transpose[{Drop[Prepend[Accumulate[childBlockRange[[varChild]][[All,2]]-childBlockRange[[varChild]][[All,1]]+1],0],-1]+1,Accumulate[childBlockRange[[varChild]][[All,2]]-childBlockRange[[varChild]][[All,1]]+1]}];
childBlockRangecv=Transpose[{Drop[Prepend[Accumulate[childBlockRangec[[varChild]][[All,2]]-childBlockRangec[[varChild]][[All,1]]+1],0],-1]+1,Accumulate[childBlockRangec[[varChild]][[All,2]]-childBlockRangec[[varChild]][[All,1]]+1]}];
(*We find the ord2: Sort(\[Phi]')\[Rule] Sort(\[Phi]')| ordering. ord3: Sort(\[Phi])\[Rule]Sort(\[Phi]\[Prime])|*)
ord2=Join[constPositionsc,Complement[Range[Length[childCharges1[[1]]]],constPositionsc]];
ord3=ord[[ord2]];


];


(*Case 2:  XiXj1=XiXj, In which case all permutations are valid.*)
If[Length[childCharges1]!= 0&& Length[varChild]!= 0&&Length[XiXj]==Length[XiXj1],
Do[
c=childChargesv[[cid]];
(*We create the chargestream.*)
chargeStreamRaw=Flocci$PartitionsWithinBlocks[c,blockParentv,blockChildv,childBlockRangev];
chargeStream=Partition[Take[chargeStreamRaw,{1,-Length[blockChildv]-1}],Length[c[[1]]]];
dimraw=Accumulate[Take[chargeStreamRaw,{-Length[blockChildv],-1}]];
chargeStreamDim=Transpose[{Drop[Prepend[dimraw,0],-1]+1,dimraw,childBlockRangecv[[All,2]]-childBlockRangecv[[All,1]]+1}];
(*We combine the stream.*)
(*We from Xsol, currently containing the constant charges.*)
XSol=If[Length[constPositionsc]!= 0,{childCharges1[[cid,constPositionsc]]},Drop[{childCharges1[[cid]]},1]];
Do[
(*We form the corresponding charges lists. And append them to our solution.*)
chargeList=Partition[Take[chargeStream,{chargeStreamDim[[currentChildBlock,1]],chargeStreamDim[[currentChildBlock,2]]}],chargeStreamDim[[currentChildBlock,3]]];
XSol=If[Length[XSol]!= 0,Flatten[Outer[Join,XSol,chargeList,1],1],chargeList];
,{currentChildBlock,1, Length[blockChildv]}];
allValidSol=Join[allValidSol,XSol];
,{cid,1,Length[childChargesv]}];
];

(*Case 3:  XiXj1=XiXj, In which case all permutations are valid.*)
If[Length[childCharges1]!= 0&& Length[varChild]!= 0&&Length[XiXj]!= Length[XiXj1],

XiXj2=Complement[XiXj,XiXj1];
XiXj2v=XiXj2;
XiXj2c=Table[0,{i1,1,Length[childCharges1]},{i2,1,Length[XiXj2]},{i3,1,Length[childCharges1[[1,1]]]}];
If[Length[constChild]!= 0,
XiXj2c=Map[XiXj2[[All,constPositionsc]].#&,childCharges1[[All,constPositionsc]]];
XiXj2v=XiXj2[[All,Complement[Range[Length[XiXj2[[1]]]],constPositionsc]]];
];

Block[{XarraysBag,XarraysUniBag,Xsepm1,XsepPosBag,XsepPos,XarrysUni,XnoSep,Xcounter},
(*The code in this block takes in from the code above: XiXj2v,  XiXj2c, blockParentv, blockChildv, childBlockRangev*)
Do[
c=childChargesv[[cid]];
(*We create the chargestream.*)
chargeStreamRaw=Flocci$PartitionsWithinBlocks[c,blockParentv,blockChildv,childBlockRangev];
chargeStream=Partition[Take[chargeStreamRaw,{1,-Length[blockChildv]-1}],Length[c[[1]]]];
dimraw=Accumulate[Take[chargeStreamRaw,{-Length[blockChildv],-1}]];
chargeStreamDim=Transpose[{Drop[Prepend[dimraw,0],-1]+1,dimraw,childBlockRangecv[[All,2]]-childBlockRangecv[[All,1]]+1}];
(*Step:........................................................................................................................................................*)
(*We consider permutations within each child block*)
XarraysBag=Internal`Bag@Most[{0}];
XarraysUniBag=Internal`Bag@Most[{0}];
Xsepm1=0;
XsepPosBag=Internal`Bag[Xsepm1];
Do[
(*We get the rows of XiXj2v corresponding to the given child block.*)
childBlockXiXj=Take[Transpose[XiXj2v],childBlockRangecv[[currentChildBlock]]]//Transpose;
(*We get the charge permutations within this childblock*)
chargeList=Partition[Take[chargeStream,{chargeStreamDim[[currentChildBlock,1]],chargeStreamDim[[currentChildBlock,2]]}],chargeStreamDim[[currentChildBlock,3]]];
(*For each charge permutation, we want the matrix childBlockXiXj.chargeperm *)
childXiXjCha=Map[childBlockXiXj.#&,Partition[Take[chargeStream,{chargeStreamDim[[currentChildBlock,1]],chargeStreamDim[[currentChildBlock,2]]}],chargeStreamDim[[currentChildBlock,3]]]];
(*We delete duplicates of these *)
childXiXjChadd={childXiXjCha[[1]]}; (*This and the line below ahre essentially delete duplicates*)
Do[If[!MemberQ[childXiXjChadd,v],AppendTo[childXiXjChadd,v]],{v,childXiXjCha}];
(*Step 4.2: We do all permutations of childBlockCharges not caring about permutations within childBlockParentBlocks.*)
Internal`StuffBag[XarraysBag,childXiXjCha,3];
Internal`StuffBag[XarraysUniBag,childXiXjChadd,3];
(*We save how many duplicates we have.*)
Xsepm1+=Length[childXiXjChadd];
Internal`StuffBag[XsepPosBag,Xsepm1];
,{currentChildBlock,1,Length[blockChildv]}];
XsepPos=Internal`BagPart[XsepPosBag,All];
(*Step:........................................................................................................................................................*)
(*We want to select all inequivelent combinations of Xarrays which add to zero.*)
(*We reform a list of XarrysUni*)
XarrysUni=Partition[Partition[Internal`BagPart[XarraysUniBag,All],Length[c[[1]]]],Length[XiXj2]];
mulInVec=Table[{XsepPos[[i]]+1,XsepPos[[i+1]]},{i,1,Length[XsepPos]-1}];
If[Length[mulInVec]>30,Print["Error. Flocci$OuterPlus needs to be defined on a larger range of lengths."]; Quit[]];
mulIndexZero=Flocci$OuterPlus[XarrysUni,mulInVec,-XiXj2c[[cid]]];

If[Length[mulIndexZero]==0,Continue[]];
mulIndexZero=Transpose[mulIndexZero];
Do[mulIndexZero[[i]]=mulIndexZero[[i]]+XsepPos[[i]];, {i,1,Length[XsepPos]-1}];
mulIndexZero=Transpose[mulIndexZero];
(*Step:........................................................................................................................................................*)

XnoSep=Partition[Partition[Internal`BagPart[XarraysBag,All],Length[c[[1]]]],Length[XiXj2]];
Do[
Xcounter=0;
XSol=If[Length[constPositionsc]!= 0,{childCharges1[[cid,constPositionsc]]},Drop[{childCharges1[[cid]]},1]];

Do[
chargeList=Partition[Take[chargeStream,{chargeStreamDim[[currentChildBlock,1]],chargeStreamDim[[currentChildBlock,2]]}],chargeStreamDim[[currentChildBlock,3]]];
corresondingChargesChild=Drop[Table[1,{i1,1,1},{i2,1,chargeStreamDim[[currentChildBlock,3]]},{i3,1,Length[c[[1]]]}],1];
Do[ 
If[XnoSep[[++Xcounter]]==XarrysUni[[xcomb[[currentChildBlock]]]],AppendTo[corresondingChargesChild,childBlockCharges]];
,{childBlockCharges,chargeList}];
XSol=If[Length[XSol]!= 0,Flatten[Outer[Join,XSol,corresondingChargesChild,1],1],corresondingChargesChild];
,{currentChildBlock,1, Length[blockChildv]}];
allValidSol=Join[allValidSol,XSol];
,{xcomb,mulIndexZero}];

(*Step:........................................................................................................................................................*)
,{cid,1,Length[childChargesv]}];
];(*End of Block*)

];(*End of case 4 if*)
];(*End of case 1 if*)
];(*End of if for charges1\[Equal]{}*)
(*We do the check if Tr[Xicjck]*)
Block[{newList,testBool,\[CapitalPhi]\[Beta]s3},
newList={allValidSol[[1]]};
(*The correct ordering for the parent ws now is based on ord3*)
\[CapitalPhi]\[Beta]s3=Transpose[parent\[CapitalPhi][[ord3]]];
Do[
testBool=True;
Do[If[Xi.(ci*cj)!= 0,testBool=False;Break[];],{Xi,\[CapitalPhi]\[Beta]s3},{ci,Transpose[s]},{cj,Transpose[s]}];
If[testBool,AppendTo[newList,s]];
,{s,Take[allValidSol,{2,-1}]}];
allValidSol=newList;
];

ordInv=Range[Length[child\[CapitalPhi]]];
Do[ordInv[[ord3[[i]]]]=i,{i,1,Length[child\[CapitalPhi]]}];
Drop[allValidSol[[All,ordInv]],1]
]
,CompilationTarget->"C",CompilationOptions->{"InlineExternalDefinitions" -> True},Parallelization->True];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$chargeAlignmentComplied",{"U1","There is only one algebra at play here\nchargeList) The charges which pass the anomaly free condition.\n parent\[CapitalPhi]) The weight system of the algebra. \n \[Beta]) The highst weights of the algebra.. \n \[CapitalLambda]\[Alpha]) The projection matrix for the parent algebra.\n Flocci$User$IrrepWeightLocation) See there.\n repList) A list of integers indicating which irrep each weight comes from.","A 3-tensor of integers.","Outputs those charges which align correctly with irreps of the algebra, after taking account of permutations within identical blocks of weights in parent\[CapitalPhi]."}];


Flocci$chargeAlignmentComplied=Compile[{{chargeList,_Integer,3},{parent\[CapitalPhi],_Integer,2},{\[CapitalLambda]\[Alpha],_Integer,2},{Flocci$User$IrrepWeightLocation,_Integer,2},{repList,_Integer,1},{ord,_Integer,1}},
Block[{blockParent,count,f,cpos,cpos1,toAdvanceTo,cnew,accParent,currentblockEnd,tobreak,LabeledParent\[CapitalPhi],acountedFor,f2,toAdd,passOrNot,cNewList,constParent,varParent,chargeListc,chargeListv,constPosition,varPosition,blockLengthv,chargeStream,chargeStreamLengths,chargeStreamRaw,parentReOrd,parentReOrdIn,hwBlock,pos,chargeStreamRep,TchargeStream,l1,l2,l3,ordIn,np,zero,boolPass,cNewListdeBag,posHWs,pairsSame,posRep,noHWs,lenReps},
(*Step 1: For the parent node, we find the lengths of the blocks of similar weights. We will do `nextpermutation' based on these block sizes.*)
accParent=Append[Flatten[Position[Table[If[parent\[CapitalPhi][[i]]==parent\[CapitalPhi][[i+1]],1,0],{i,1,Length[parent\[CapitalPhi]]-1}],0]],Length[parent\[CapitalPhi]]];
blockParent=accParent-Prepend[Drop[accParent,-1],0];
(*Step 2: We find the blocks which are `constant' and those which are `var'.*)
constParent=Select[Range[Length[blockParent]],blockParent[[#]]==1||Length[DeleteDuplicates[Flatten[ Take[chargeList,All,{If[#==1,1,accParent[[#-1]]+1],accParent[[#]]}]]]]==1&];
varParent=Complement[Range[Length[blockParent]],constParent];
(*We now want to go through the steps of creating chargeStream in the cases when Length[varParent]\[Equal]0 and when it is not*)
If[Length[varParent]!= 0,
constPosition=Most[{0}];
Do[constPosition=Join[constPosition,Range[If[c==1,1,accParent[[c-1]]+1],accParent[[c]]]],{c,constParent}];
varPosition=Complement[Range[Length[chargeList[[1]]]],constPosition];
parentReOrd=Join[constPosition,varPosition];
parentReOrdIn=Range[Length[parent\[CapitalPhi]]];
Do[parentReOrdIn[[parentReOrd[[i]]]]=i,{i,1,Length[parent\[CapitalPhi]]}];
(*Step: We split the charges into `constant' and `var'*)
chargeListc=If[Length[constPosition]!= 0,chargeList[[All,constPosition]],Drop[{{{1}}},1]];
chargeListv=chargeList[[All,varPosition]];
blockLengthv=blockParent[[varParent]];
(*Step: We create a list of pairs of charge positions which must be equal, if the test will work - JTS:31/12/22, JTS:12/01/23*)
(*As a crude, first attempt, we get the positions of the representations which branch down to precisely one irrep.*) 
(*We first get the locations of the highest weights*)
posHWs=Prepend[Flatten[Position[Flocci$User$IrrepWeightLocation,{-1,-1}]],0]+1;
lenReps=Append[Flatten[Position[Flocci$User$IrrepWeightLocation,{-1,-1}]],Length[Flocci$User$IrrepWeightLocation]+1]-(Prepend[Flatten[Position[Flocci$User$IrrepWeightLocation,{-1,-1}]],0]+1);
(*We get those irrep id's which branch down to only one irrep*)
pairsSame=Drop[{{0,0}},1];
Do[
posRep=Flatten[Position[repList,r]];
noHWs=0;
Do[
If[Flocci$User$IrrepWeightLocation[[posHWs[[pHW]],1]]<= p&&p<=Flocci$User$IrrepWeightLocation[[posHWs[[pHW]],2]]&&lenReps[[pHW]]==Length[posRep],noHWs=1]
,{p,posRep},{pHW,1,Length[posHWs]}];
If[noHWs==1,
pairsSame=Join[pairsSame,Partition[posRep,2,1]];
];
,{r,DeleteDuplicates[repList]}];
(*We then need to map to the correct ordering*)
ordIn=Range[Length[ord]];
Do[ordIn[[ord[[i]]]]=i,{i,1,Length[ord]}];
(*Let us expand on how pairsSame must be adjusted to take account of reordering. Elements of p\in posRep are positions in X\[LeftDoubleBracket]ord\[RightDoubleBracket]. The corresponding position in X is ord\[LeftDoubleBracket]p\[RightDoubleBracket]. The charges are in the order C\[LeftDoubleBracket]parentReOrd\[RightDoubleBracket], a position parentReOrdIn\[LeftDoubleBracket]k\[RightDoubleBracket] gives the same element as C\[LeftDoubleBracket]k\[RightDoubleBracket] *)
If[Length[pairsSame]!= 0,
 pairsSame=Map[ord[[#]]&,pairsSame,{2}];
pairsSame=Map[parentReOrdIn[[#]]&,pairsSame,{2}];
pairsSame=SortBy[pairsSame,Max[#]&];
pairsSame=pairsSame;
;];
(*Step: We want to create the charge list.*)
chargeStream=Flocci$PermutationsWithinBlocksConditional[chargeListv,blockLengthv,chargeListc,pairsSame];
If[chargeStream=={{{-199}}},Return[Drop[{{{0}}},1]]];
chargeStream=chargeStream[[All,parentReOrdIn]];

,
chargeStream=chargeList;
];
(*We now cyclce through the charge stream, and check the rep condition*)


(*Flocci$User$IrrepWeightLocation contains a list e.g. {{31,32},{1,2},{3,4},{7,8},{25,26},{27,28},{-1,-1},{17,20},{9,12},{21,24},{-1,-1},{29,30},{5,6},{-1,-1},{13,16}}*)
(*The {-1,-1} split the different representations. The first number e.g. {31,32} is the location of the highest weight, and the numbers which follow are the positions of the other weights for that representation (in no real order).*)

pos=Append[Prepend[Flatten[Position[Flocci$User$IrrepWeightLocation,{-1,-1}]],0],Length[Flocci$User$IrrepWeightLocation]+1]+1;
np=Length[pos]-1;
zero=Table[0,{i,1,Length[repList]}];

cNewList=Internal`Bag@Most[{0}];
Do[
acountedFor=zero;
toAdd=True;
Do[(*Loop through irreps*)
Do[(*Loop through different highest weights of the irrep.*)
If[acountedFor[[hw]]!= 0,Continue[]];
Do[(*Loop through different weights.*)
boolPass=False;
Do[(*Loop through different instances of said weight.*)
(*We ask three conditions of these weights: 1) Have they been accounted for before. 2) Does the representation match the highest weight. 3) Does the charge match the highest weight.*)
If[acountedFor[[wi]]!= 0,Continue[]];
If[repList[[wi]]!= repList[[hw]],Continue[]];
If[ c[[ord[[wi]]]]!= c[[ord[[hw]]]],Continue[]];
acountedFor[[wi]]=1;
boolPass=True;
Break[];
,{wi,Flocci$User$IrrepWeightLocation[[weight,1]],Flocci$User$IrrepWeightLocation[[weight,2]]}];
If[!boolPass,toAdd=False;Break[];]
,{weight,pos[[irrep]]+1,pos[[irrep+1]]-2}];
If[!toAdd,Break[]];
,{hw,Flocci$User$IrrepWeightLocation[[pos[[irrep]],1]],Flocci$User$IrrepWeightLocation[[pos[[irrep]],2]]}];
If[!toAdd,Break[]];
,{irrep,1,np}];
If[toAdd,Internal`StuffBag[cNewList,c,2]];
,{c,chargeStream}];

(*We output our solution.*)
cNewListdeBag=Internal`BagPart[cNewList,All];
If[Length[cNewListdeBag]!= 0,Partition[Partition[cNewListdeBag,Length[chargeList[[1,1]]]],Length[chargeStream[[1]]]],Drop[{{{0}}},1]]
],CompilationTarget->"C",CompilationOptions->{"InlineExternalDefinitions" -> True},Parallelization->True];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$chargeAlignment",{"U1","There is only one algebra at play here\nchargeList) The charges which pass the anomaly free condition.\n parent\[CapitalPhi]) The weight system of the algebra. \n \[Beta]) The highst weights of the algebra.\n parentg) The algebra. \n \[CapitalLambda]\[Alpha]) The projection matrix for the parent algebra.\n Flocci$User$IrrepWeightLocation) See there.","A 3-tensor of integers.","Outputs those charges which align correctly with irreps of the algebra, after taking account of permutations within identical blocks of weights in parent\[CapitalPhi]."}];
Flocci$chargeAlignment[chargeList_,parent\[CapitalPhi]_,parent\[Beta]_,parentg_,\[CapitalLambda]\[Alpha]_,Flocci$User$IrrepWeightLocation_]:=Module[{LabeledParent\[CapitalPhi],ord,repList},
LabeledParent\[CapitalPhi]=Flatten[Table[Map[Append[#,i]&,Flocci$WeightSystemSorted[parentg,parent\[Beta][[i]]]],{i,1,Length[parent\[Beta]]}],1]//Sort;
ord=Ordering[Transpose[{Take[LabeledParent\[CapitalPhi],All,{1,-2}].Transpose[\[CapitalLambda]\[Alpha]],LabeledParent\[CapitalPhi]}]];
repList=LabeledParent\[CapitalPhi][[All,-1]][[ord]];
(*AppendTo[testCases,{chargeList,parent\[CapitalPhi],\[CapitalLambda]\[Alpha],Flocci$User$IrrepWeightLocation,repList,ord}];*)
Flocci$chargeAlignmentComplied[chargeList,parent\[CapitalPhi],\[CapitalLambda]\[Alpha],Flocci$User$IrrepWeightLocation,repList,ord]
]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$U1Find",{"U1","There is only one algebra at play here\nchargeList) The charges which pass the anomaly free condition.\n parent\[CapitalPhi]) The weight system of the algebra. \n \[Beta]) The highst weights of the algebra.. \n \[CapitalLambda]\[Alpha]) The projection matrix for the parent algebra.\n Flocci$User$IrrepWeightLocation) See there.","A 3-tensor of integers.","Outputs those charges allowed which sit in the parent algebra. This uses a LinearSolve method."}];
Flocci$U1Find[chargeList_,parent\[CapitalPhi]_,parent\[Beta]_,parentg_,\[CapitalLambda]\[Alpha]_,Flocci$User$IrrepWeightLocation_]:=Module[{LabeledParent\[CapitalPhi],ord,repList,chargesTest,ra},
LabeledParent\[CapitalPhi]=Flatten[Table[Map[Append[#,i]&,Flocci$WeightSystemSorted[parentg,parent\[Beta][[i]]]],{i,1,Length[parent\[Beta]]}],1]//Sort;
ord=Ordering[Transpose[{Take[LabeledParent\[CapitalPhi],All,{1,-2}].Transpose[\[CapitalLambda]\[Alpha]],LabeledParent\[CapitalPhi]}]];
repList=LabeledParent\[CapitalPhi][[All,-1]][[ord]];
chargesTest=Flocci$chargeAlignmentComplied[chargeList,parent\[CapitalPhi],\[CapitalLambda]\[Alpha],Flocci$User$IrrepWeightLocation,repList,ord];
ra=MatrixRank[parent\[CapitalPhi]//Transpose];
Table[If[MatrixRank[Join[Transpose[parent\[CapitalPhi]],Transpose[c]]]== ra,Table[LinearSolve[parent\[CapitalPhi],ci],{ci,Transpose[c]}],Nothing],{c,chargesTest}]
]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$ProjectionMatrixNonEmpty\[CapitalGamma]sQ",{"U1","g) A semi-simple Lie algebra.\n \[CapitalLambda]\[Alpha]) A projection matrix, containing U(1) rows.","True or False.","Tests that for each root  r  in Flocci$User$RootList the subset of Flocci$Roots[g] in roots which land on r under \[CapitalLambda]\[Alpha] is non-zero."}];
Flocci$ProjectionMatrixNonEmpty\[CapitalGamma]sQ[g_,\[CapitalLambda]\[Alpha]_]:=Module[{roots\[Beta],ranklist,elWS,\[CapitalPhi]HW\[Beta],\[CapitalPhi]\[Beta],\[CapitalGamma]s,\[CapitalGamma]sb},
roots\[Beta]=Flocci$Roots[g];
\[CapitalGamma]s=Table[Sort[Select[roots\[Beta],\[CapitalLambda]\[Alpha].#==r&]],{r,Flocci$User$RootList}];
If[Count[\[CapitalGamma]s,{}]>= 1,Return[False];];
True]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$ProjectionMatrixExtendableSimpleQ",{"U1","g1) A semi-simple Lie algebra.\nsb) A simple Lie algebra.\n\[CapitalLambda]\[Alpha]) A projection matrix from sb to g1+u(1)^n.","True or false.","Tests whether or not a full embedding \[Alpha] can be made from \[CapitalLambda]\[Alpha]. This uses a Groebner Basis, which can be slow.","3"}]
Flocci$SetDescription["Flocci$ProjectionMatrixExtendableQ",{"U1","g1) A semi-simple Lie algebra.\ng) A semi-simple Lie algebra.\n\[CapitalLambda]\[Alpha]) A projection matrix from sb to g1+u(1)^n.","True or false.","Tests whether or not a full embedding \[Alpha] can be made from \[CapitalLambda]\[Alpha]."}]
Flocci$ProjectionMatrixExtendableSimpleQ[g1_,sb_,\[CapitalLambda]\[Alpha]_]:=Flocci$ProjectionMatrixExtendableSimpleQ[g1,sb,\[CapitalLambda]\[Alpha]]=Module[{Alg,lab, \[CapitalGamma],i,j,k,row,fembeddingSS,fembeddingU1,fembedding,feq,flist,fsol,rankList,gen1,gen2,rowRange,rowIndex,noU1s,rootsb,gens,comSS1,comSS2,eqOffDig,eqOnDig,varID,ASb,Ag1,gb,\[CapitalPhi]t,\[CapitalPhi]p}, 
(*The input of this is g1: The semi-simple part of the userinput.*)
(*The input of this is sb: The simple algebra we are considering the embedding into.*)
(*The input of this is \[CapitalLambda]\[Alpha]: The corresponding projection matrix.*)

(*We check if the embedding is trivial*)
If[AllTrue[Flatten[\[CapitalLambda]\[Alpha]],#==0&],Return[True]];
(*We find the total number of u(1)'s*)
rankList=Flocci$Rank[g1];
rowRange=Transpose[{Prepend[Drop[Accumulate[rankList],-1],0]+1,Accumulate[rankList]}];
noU1s=Length[\[CapitalLambda]\[Alpha]]-Total[rankList];
rowIndex=Table[Join[Range[r[[1]],r[[2]]],Range[noU1s]+ Total[rankList]],{r,rowRange}];
rootsb=Flocci$Roots[{sb}];
(*We do a quicker check for su(n)*)
(*If[Flocci$TypeAQ[sb],
\[CapitalPhi]t=Flocci$WeightSystemFromFlat[{sb},Normal[SparseArray[1\[Rule] 1, Flocci$Rank[sb]]]];
\[CapitalPhi]p=\[CapitalPhi]t.Transpose[\[CapitalLambda]\[Alpha]];
If[Flocci$ExtractHighestWeights[Join[g1,ConstantArray[U1,noU1s]],\[CapitalPhi]p]===False,Return[False];,Return[True]];
];*)
(*For each simple ideal, we want to construct the most general embedding.*)
varID=0;
fembeddingSS=Table[
row=rowRange[[i,1]]-1;
gen1=Take[\[CapitalLambda]\[Alpha],rowRange[[i]]];
gen2=Table[Flatten[Position[rootsb,_?(\[CapitalLambda]\[Alpha].#==Join[ConstantArray[0,row],x,ConstantArray[0,Length[\[CapitalLambda]\[Alpha]]-rowRange[[i,2]]]]&),{1}]],{x,Flocci$Roots[{g1[[i]]}]}];
gen2=Flatten[Table[Map[{i,#}&,gen2[[i]]],{i,1,Length[gen2]}],1]//DeleteDuplicates;
gen2=SparseArray[Table[g->a[++varID],{g,gen2}],{Length[Flocci$Roots[{g1[[i]]}]],Length[rootsb]}]//Normal;
{{gen1,0},{0,gen2}}//ArrayFlatten
,{i,1,Length[g1]}];
(*We form the raw embedding for the u(1) part.*)
fembeddingU1=Map[Join[#,ConstantArray[0,Length[rootsb]]]&,Take[\[CapitalLambda]\[Alpha],{-noU1s,-1}]];

(*We find the commutator matrices*)
ASb=Flocci$Commutators[sb];
Ag1=Map[Flocci$Commutators,g1];

(*We now want to find the equations*)
(*Equations for different simple ideals to commute.*)
eqOffDig=Table[
Sum[ASb[[i,j]]X1[[i]] X2[[j]],{i,1,Length[X1]},{j,1,Length[X2]}]
,{m,1,Length[g1]},{n,m+1,Length[g1]},{X1,fembeddingSS[[m]]},{X2,fembeddingSS[[n]]}];
(*Equations for a simple ideals to obey the correct commutation realtions.*)
eqOnDig=Table[
Transpose[fembeddingSS[[m]]].Ag1[[m,i,j]]-Sum[ASb[[i\[Prime],j\[Prime]]]fembeddingSS[[m,i]][[i\[Prime]]] fembeddingSS[[m,j]][[j\[Prime]]],{i\[Prime],1,Length[fembeddingSS[[m,i]]]},{j\[Prime],1,Length[fembeddingSS[[m,i]]]}]
,{m,1,Length[g1]},{i,1,Flocci$Rank[g1[[m]]]+Length[Flocci$Roots[{g1[[m]]}]]},{j,i+1,Flocci$Rank[g1[[m]]]+Length[Flocci$Roots[{g1[[m]]}]]}];
(* We form the full equation list. *)
feq=Join[eqOffDig,eqOnDig]//Flatten//DeleteDuplicates;
(* We check the grobner basis for constants *)
gb=GroebnerBasis[ feq,Array[a,varID]];
gb=={}||!AnyTrue[gb,Head[#]===Integer||Head[#]===Real||Head[#]===Complex||Head[#]===Rational&]
]
Flocci$ProjectionMatrixExtendableQ[g1_,g_List,\[CapitalLambda]\[Alpha]_]:=Module[{\[CapitalLambda]\[Alpha]split},\[CapitalLambda]\[Alpha]split=Map[Transpose,TakeList[Transpose[\[CapitalLambda]\[Alpha]],Flocci$Rank[g]]]; 
AllTrue[Range[Length[g]],Flocci$ProjectionMatrixExtendableSimpleQ[g1,g[[#]],\[CapitalLambda]\[Alpha]split[[#]]]&]]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$FrobeniusSimSolve"}];
Flocci$FrobeniusSimSolve::tag="UpDirec";
Flocci$FrobeniusSimSolve::input="level03: A list of non-negative integer vectors e.g. {{0,1},{1,0}}.\ncountCompare: A non-negative integer vector e.g. {1,1}. ";
Flocci$FrobeniusSimSolve::output="A 2-tensor of non-negative integer vectors, the first of which is {0,0}, and subsiqunet of which are solutions {a_i} to \\sum a_i level03_i=countCompare, for a_i>=0.";
Flocci$FrobeniusSimSolve::description="The vectors in level03 are multiplicites of hws in irreps. The vector countCompare is the multiplicity that we want to get. This function tells us all the ways we can combine types of irreps so that they branch correctly. ";
Flocci$FrobeniusSimSolve=Compile[{{level03,_Integer,2},{countCompare,_Integer,1}},
Block[{counter,currentIndex,test,bool,testarray,boolZero,boolToKill,outlist},
counter=Table[0,{i,1,Length[level03]}]; (*I couldn't use constant array here??*)
outlist={counter};
counter[[-1]]=1;
While[True,
bool=True;

testarray=countCompare-counter.level03;

Do[If[t<0,bool=False; Break[]],{t,testarray}];
(*test if zero*)
boolZero=True;
Do[If[t!= 0,boolZero=False; Break[]],{t,testarray}];
If[boolZero,AppendTo[outlist,counter]];
(*We work on indexing*)
boolToKill=True;
Do[If[t!= 0,boolToKill=False;Break[]],{t,Take[counter,{2,-1}]}];
If[!bool && boolToKill, Break[]];
If[bool, counter[[-1]]+=1;, 
Do[If[counter[[Length[counter]+1-i]]!= 0,counter[[Length[counter]+1-i]]=0;counter[[Length[counter]-i]]+=1; Break[]],{i,1,Length[counter]}]

];
];
outlist
]
,CompilationTarget->"C"];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$VertexAssocAppend"}];
Flocci$VertexAssocAppend::tag="UpDirec";
Flocci$VertexAssocAppend::input="SSdata: the list {parent algebra, sorted parent highest weights, projection matrix}";
Flocci$VertexAssocAppend::output="{Node ID, bool}";
Flocci$VertexAssocAppend::description="Input uniquely specifies a node in the graph. If parent node exists, return ID and False. If not, create node and return ID and True";

Flocci$VertexAssocAppend[SSdata_]:=Module[{ret},
ret=Lookup[Flocci$VertexAssoc,{SSdata},-1][[1]];(*need extra {} so doesn't look up each piece of data separately*)
If[ret==-1,
Flocci$SSNode$MaxId+=1;AssociateTo[Flocci$VertexAssoc,SSdata->Flocci$SSNode$MaxId];Return[{Flocci$SSNode$MaxId,True}](*node not in tree yet: add and return new id*),
Return[{ret,False}](*node in tree, simply return id*)
];
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$EdgeAssocAppend"}];
Flocci$EdgeAssocAppend::tag="UpDirec";
Flocci$EdgeAssocAppend::input="SEdata: the list {Parent node ID -> Child node ID, projection matrix}";
Flocci$EdgeAssocAppend::output="{Edge ID, bool}";
Flocci$EdgeAssocAppend::description="Input uniquely specifies an edge in the graph. If exists, return ID and False. If not, create edge and return ID and True";

Flocci$EdgeAssocAppend[SEdata_]:=Module[{ret},
ret=Lookup[Flocci$EdgeAssoc,{SEdata},-1][[1]];(*need extra {} so doesn't look up each piece of data separately*)
If[ret==-1,
Flocci$SSEdge$MaxId+=1;AssociateTo[Flocci$EdgeAssoc,SEdata->Flocci$SSEdge$MaxId];Return[{Flocci$SSEdge$MaxId,True}](*edge not in tree yet: add and return new id*),
Return[{ret,False}](*edge in tree, simply return id*)
];
];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$UnorderedTuples",{"UpDirec","len) An integer\n max) An integer","A integer 2-tensor","A list of all vectors of length len, with numbers 1-max in decending order."}];
Flocci$UnorderedTuples[len_,max_]:=Flatten[IntegerPartitions[#,{len},Range[max]]&/@Range[len,max*len],1](*https://mathematica.stackexchange.com/questions/136814/unordered-tuples?noredirect=1&lq=1*)


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$RaggedToFlat",{"UpDirec","A ragged list e.g. {{{1,2},{1,2}},{{3,4}}}","A pair of the input flattened at 1 level e.g. {{1,2},{1,2},{3,4}}, and the length of each ragged part e.g. {2,1}","Flattens the 1st level of a ragged list, and records the length, so that the ragged list can be reconstructed."}];
Flocci$RaggedToFlat[list_]:=Module[{flat,end,start,range},
flat=Flatten[list,1];
end=Accumulate[Map[Length,list]];
start=Prepend[Delete[end,-1],0]+1;
range={start,end}//Transpose;
{flat,range}
];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$SublistQ",{"UpDirec","FullList) An Integer 2-tensor\nSubList) An Integer 2-Tensor","True or False.","Outputs True if SubList is a sublist (accounting for multiplicities) of FullList."}]
Flocci$SublistQ=Compile[{{FullList,_Integer,2},{SubList,_Integer,2}},(*https://mathematica.stackexchange.com/questions/100660/*)
Block[{Templist,pos},
Templist=SubList;
Do[
pos=Position[Templist,si];
If[Length[pos]!=0, Templist=Delete[Templist,pos[[1,1]]]];
,{si,FullList}];
Length[Templist]==0
]
,CompilationTarget->"C"];
CompilePrint[Flocci$SublistQ];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$SelectByMemberQ",{"UpDirec","hw2) A integer 2-tensor.\n \[CapitalLambda]) A matrix.\n \[CapitalPhi]t) An integer 2-tensor","An integer-2tensor","Selects those elements of hw2 by weather \[CapitalLambda].# is in \[CapitalPhi]t."}];
Flocci$SelectByMemberQ=Compile[{{hw2,_Integer,2},{\[CapitalLambda],_Integer,2},{\[CapitalPhi]t,_Integer,2}},
Select[hw2,MemberQ[\[CapitalPhi]t,\[CapitalLambda].#]&]
,CompilationTarget->"C",Parallelization->True,RuntimeOptions->"Speed"];
CompilePrint[Flocci$SelectByMemberQ];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$NonnegativeMatrixQ",{"UpDirec","\[CapitalLambda]) An integer 2-tensor","True or False","Outputs True if all elements of \[CapitalLambda] are non-negative. Otherwise outputs False."}];
Flocci$NonnegativeMatrixQ=Compile[{{\[CapitalLambda],_Integer,2}},
Block[{bool},bool=True;Do[If[r<0,bool=False;Break[];],{p,\[CapitalLambda]},{r,p}]; bool]
,CompilationTarget->"C"];
CompilePrint[Flocci$NonnegativeMatrixQ];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$HighestWeightMultiplicityId",{"UpDirec","inId) The id of a child node.\n irrep) The projected ws of a parent node.","A 1-integer tensor or multiplicities.","Runs Flocci$HighestWeightMultiplicity with the child node specified by inID."}];
Flocci$HighestWeightMultiplicityId[inID_,irrep_]:=With[{irrepMult=Flocci$HighestWeightMultiplicity[irrep,Flocci$SSNode$DeltaCoprime[inID],Flocci$SSNode$HWsMult[inID],Flocci$SSNode$UniHWs[inID],Flocci$SSNode$UniIrrepDominFlat[inID],Flocci$SSNode$UniIrrepDominRange[inID]]//Timing//Flocci$Timing["CanEmbedProjWS: 23"]},
If[irrepMult[[1]]==-1,Return[Nothing]];
irrepMult(*if can embed, has form: {irrepMult,{parent hw, parent ws}} eg. { {1,0} , { {{{1},{1,0}}} , {{1,1,0},...} } }*)
];


(* ::Input::Initialization:: *)
Flocci$SSNode$AlgebraList:=Table[{Flocci$SSNode$Algebra[i],Flocci$SSNode$HWs[i],Flocci$SSNode$\[CapitalLambda]\[Alpha][i]},{i,1,Flocci$SSNode$MaxId}];
Flocci$SSEdge$EdgeList:=Table[{Flocci$SSEdge$Edge[i],Flocci$SSEdge$\[CapitalLambda]\[Rho][i]},{i,1,Flocci$SSEdge$MaxId}]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$MakeParentNodes",{"UpDirec","inID) The id of the child node to be considered.\n g)A semi-simple Lie algebra \n \[CapitalLambda]) A projection matrix such that (g,\[CapitalLambda]) define a minimal sup algebra of inID.","None.","Finds all parent nodes in the UpDirec graph of the child node inID."}];
Flocci$MakeParentNodes[inID_][{g_,\[CapitalLambda]_}]:=Module[{irrepsL,elWS,\[CapitalLambda]ws,f,counts,keys,c2,WSSubSets,level0,allLevel,allLeveln,nint,np, sols,a,listReps,t,level03,pos,thisid,out,\[CapitalLambda]\[Alpha]t,\[CapitalLambda]\[Rho]t,out\[Beta],posed,aut\[CapitalLambda]\[Alpha],or,tot,part,ut,tt,SSalgebrasave,bool,booled,level01,thised,\[CapitalLambda]t,temp,tempe,lengths,selectList,lookup,dim,hw1,hw2,hwws,ranklist,selectListT,\[CapitalPhi]d,gtake,dimlist,AnomList,anomalycoef,parts2,\[Beta]multT,assoicationmap,out\[Beta]Association,tempA,ord,outused,ordInv},
(*Step 1: We find all irreps of g, of dimension less than or equal to the dimension of \tilde \beta. The output is pairs {\beta,\Phi(\beta)} of heighest weights, and weight systems.*)
dim=Length[Flocci$SSNode$WS[inID]];(*A natural number.*)
hw2=Flocci$IrrepsLessThenOrEqualDim[g,dim,Flocci$User$A1Dim]//Timing//Flocci$Timing["reps: 1"]; (*An integer 2-tensor of highest weights.*)
(*Step 2: We append to \[CapitalLambda]ws, the projection of \[CapitalPhi](\[Beta]) under the projection matrix \[CapitalLambda]\[Rho]. This contains a 'necessary' (but not sufficent) test of wether \[CapitalLambda](\[CapitalPhi](\[Beta])) is a subset of \[CapitalPhi](t\[Beta]).*)
(*tempe=AssociationMap[True&,Flocci$SSNode$WS[inID]]//Timing//Flocci$Timing["reps: 2.1"];*) (*A hash table.*)

\[CapitalLambda]t=Transpose[\[CapitalLambda]];(*A matrix.*)

ranklist=Flocci$Rank[g];

 \[CapitalPhi]d=Flocci$ExtractDominantWeights[Flocci$SSNode$WS[inID]];(*Should make global varible*)
With[{\[CapitalPhi]temp=If[Flocci$NonnegativeMatrixQ[\[CapitalLambda]],DeleteDuplicates[\[CapitalPhi]d],DeleteDuplicates[Flocci$SSNode$WS[inID]]]},
selectList=Flocci$SelectByMemberQ[hw2,\[CapitalLambda],\[CapitalPhi]temp];
]//Timing//Flocci$Timing["reps: 2.1-2"];(*An integer 2-tensor of highest weights.*)

(*selectList=Pick[hw2,Lookup[tempe,(Flatten/@hw2).\[CapitalLambda]t,False]]//Timing//Flocci$Timing["reps: 2.2"];*)(*select those hws that project into ws*)
        assoicationmap=GroupBy[selectList,Flocci$ExtractDominantWeights[Flocci$WeightSystemSorted[g,#].\[CapitalLambda]t]&];(*with keys as projected weight systems, and values as highest weights.*)

(*Step 3: We throw away all irreps which do not have \[CapitalLambda](\[CapitalPhi](\[Beta])) a subset of \[CapitalPhi](t\[Beta]).*)
level0=KeySelect[assoicationmap,Flocci$SublistQ[\[CapitalPhi]d,#]&]//Timing//Flocci$Timing["reps: 3.1"];(*See lengths*)(*Maybe able to use some partition of integers here*)
level01=KeyDrop[KeyMap[Flocci$HighestWeightMultiplicityId[inID,#]&,level0],Nothing]//Timing//Flocci$Timing["reps: 3.2"];
(*A list of pairs:  {irrepMult,{parent hw, parent ws}}*)
If[Length[level01]==0,Return[];];
(*Step 4: We find all reducible representations (g,\[Beta]) which branch down to (tg, t\[Beta]) under \[Rho].*)
(*listReps=listRepsF[inID,level01,g]//Timing//Flocci$Timing["reps: 4"];*) (*A list of pairs: 1) List of hws, 2) Weight system*)
(*We now solve the simultanous Frobenius equations.*)
\[Beta]multT=Flocci$SSNode$HWsMult[inID];
allLevel=Delete[Flocci$FrobeniusSimSolve[Keys[level01],\[Beta]multT],1]//Timing//Flocci$Timing["reps: 4.3"]; (*A list of non-negative integer solutions.*)

Block[{hwEqualTup,hwAllTup,hwAllTupFlat,unihw,anomAssoMap,anomFree,faithful},
hwEqualTup=Table[ Map[level01[Keys[level01][[k]]][[#]]&,Flocci$UnorderedTuples[sol[[k]],Length[level01[Keys[level01][[k]]]]]],{sol,allLevel},{k,1,Length[sol]}]; (*Could do this with a compiled unordered Tuples *)
hwAllTup=Flatten[Map[Tuples,hwEqualTup],1];
hwAllTupFlat=Map[Flatten[#,1]&, hwAllTup];
(*We select those which act faithfully*)
faithful=Select[hwAllTupFlat,!AnyTrue[TakeList[Transpose[#],Flocci$Rank[g]] ,LinearAlgebra`Private`ZeroArrayQ]&];
If[faithful=={},Return[];];
(*We find the anomaly cancelations association map*)
unihw=DeleteDuplicates[Flatten[faithful,1]];
gtake=Map[Transpose,TakeList[Transpose[unihw],Flocci$Rank[g]]];
dimlist=Map[Length[Flocci$WeightSystemSorted[g,#]]&,unihw];
AnomList=Table[If[Flocci$TypeAQ[g[[i]]]&&!(g[[i]]===A1), Flocci$AnomCoeffCompiled[gtake[[i]],dimlist],ConstantArray[0,Length[dimlist]]],{i,1,Length[g]}]//Transpose;
anomAssoMap=AssociationThread[unihw,AnomList];
(*We select those with anomaly cancleation*)
anomFree=Select[faithful,LinearAlgebra`Private`ZeroArrayQ[Sum[anomAssoMap[#[[i]]],{i,1,Length[#]}]]&];
(*Adding the weight systems in*)
listReps=Map[{#,Sort[Join@@Table[Flocci$WeightSystemSorted[g,#[[i]]],{i,1,Length[#]}]]}&,anomFree];
];
(*Step 5: We test whether the triple (g,\[Beta],\[CapitalLambda]\[Alpha]) allow a valid u(1) obeying the ACCs, after possible extention. *)
(*Is it doing matrix multiplication here for every entry?*)
If[Flocci$User$U1sPresentBool,
listReps=Map[{#[[1]],#[[2]],Sort[Flocci$anomalyFreeU1Addition[Flocci$SSNode$AnomFreeCharges[inID],Flocci$SSNode$WS[inID],#[[2]],\[CapitalLambda]]]}&,listReps]//Timing//Flocci$Timing["reps: 5.1"];
listReps=Select[listReps,Length[#[[3]]]> 0 &]//Timing//Flocci$Timing["reps: 5.2"];

listReps=Select[listReps,Length[Flocci$chargeAlignment[#[[3]],#[[2]],#[[1]],g,Flocci$SSNode$\[CapitalLambda]\[Alpha][inID].\[CapitalLambda],Flocci$User$IrrepWeightLocation]]>0&]//Timing//Flocci$Timing["reps: 5.3"];(*See listReps above*)
];
(*Step 6: We take our representations (g,\[Beta]) to our chosen representative of the equvilence class \[LeftDoubleBracket]g,\[Beta]\[RightDoubleBracket] defined by out-automorphism of g on \[Beta]. We save the outer-automorphism, for later use.
We must do this, since we only one \[Rho] per-equivelence class defined by automorphism of g.*)
out=Flocci$OuterAutomorphisms[g]//Timing//Flocci$Timing["reps: 6.1"];(*A list of vectors of integers. Each vector of integers corresponds to the columns where the 1 appears in the projection matrix.*)
out\[Beta]Association=GroupBy[listReps,Flocci$OuterAutTakeWsToMinAndGroupPreserveMin[out,#[[2]]]&];
out\[Beta]Association=If[Flocci$User$U1sPresentBool,
AssociationThread[Keys[out\[Beta]Association]-> KeyValueMap[
Table[ord=Ordering[Transpose[Join[Transpose[o[[2,All,#1[[1]]]]],o[[3,All]]]]];{o[[1,All,#1[[1]]]],Sort[o[[2,All,#1[[1]]]]],o[[3,All,ord]]},{o,#2}]
&,out\[Beta]Association]],
AssociationThread[Keys[out\[Beta]Association]-> KeyValueMap[Table[{o[[1,All,#1[[1]]]],Sort[o[[2,All,#1[[1]]]]]},{o,#2}]&,out\[Beta]Association]]
]
;
Do[
{\[CapitalLambda]\[Alpha]t,\[CapitalLambda]\[Rho]t,aut\[CapitalLambda]\[Alpha],outused}=Flocci$ProjectionMatricesUniqueForm[Flocci$SSNode$\[CapitalLambda]\[Alpha][inID],\[CapitalLambda][[All,out\[Beta][[1]]]],out\[Beta][[2]],g,Flocci$SSNode$AutPres\[CapitalLambda]\[Alpha][inID]]//Timing //Flocci$Timing["reps: 9.1"];
Do[

(*{thisid,bool}=SSDecisionTreeAppend[g,r\[LeftDoubleBracket]1\[RightDoubleBracket],\[CapitalLambda]\[Alpha]t]//Timing //Flocci$Timing["reps: 9.2"];*)
{thisid,bool}=Flocci$VertexAssocAppend[{g,r[[1]]//Sort,\[CapitalLambda]\[Alpha]t}]//Timing //Flocci$Timing["reps: 9.2"];
(*pos=FirstPosition[Flocci$SSNode$AlgebraList,{g,Sort[r\[LeftDoubleBracket]1\[RightDoubleBracket]],\[CapitalLambda]\[Alpha]t}];*)
If[bool,(*We check if we are making a duplicate or not*)
(Flocci$SSNode$Algebra[thisid]=g; (*A list of algebras.*)
Flocci$SSNode$HWs[thisid]=r[[1]]//Sort; (*A list of hw seperated by simple ideals. e.g. {{ {1},{1,0}}, {{2},{1,1}}}*)
Flocci$SSNode$WS[thisid]=r[[2]]//Sort;(*A list of vectors. {{1,0},{1,0},{-1,1},{-1,1}} of all weights*)
Flocci$SSNode$\[CapitalLambda]\[Alpha][thisid]=\[CapitalLambda]\[Alpha]t;(*A matrix*)
Flocci$SSNode$AutPres\[CapitalLambda]\[Alpha][thisid]=aut\[CapitalLambda]\[Alpha]; (*A list of matrices*)
ord=Ordering[r[[2,All]].Transpose[outused]];
ordInv=Range[Length[ord]];
Do[ordInv[[ord[[i]]]]=i,{i,1,Length[ord]}];
If[Flocci$User$U1sPresentBool,Flocci$SSNode$AnomFreeCharges[thisid]=r[[3]][[All,ordInv]]];
Flocci$SSNode$Delta[thisid]=Flatten[Table[Flocci$MetricTensor[a].ConstantArray[1,Flocci$Rank[a]],{a,Flocci$SSNode$Algebra[thisid]}]];
Flocci$SSNode$DeltaCoprime[thisid]=Flocci$SSNode$Delta[thisid]/GCD@@Flocci$SSNode$Delta[thisid];
Flocci$SSNode$UniHWs[thisid]=(Tally[Flocci$SSNode$HWs[thisid]][[All,1]]);(*child hws (flattened) eg. list of {1,0,0}*)
Flocci$SSNode$HWsMult[thisid]=Tally[Flocci$SSNode$HWs[thisid]][[All,2]];(*list of their multiplicities*)


Flocci$SSNode$UniIrrepDomin[thisid]=Map[Flocci$ExtractDominantWeights[Flocci$WeightSystemSorted[Flocci$SSNode$Algebra[thisid],#]]&,DeleteDuplicates[Flocci$SSNode$HWs[thisid]]]; (*A list of lists of vectors, where each sublist is the weight system of a unique hw.*)
{Flocci$SSNode$UniIrrepDominFlat[thisid],Flocci$SSNode$UniIrrepDominRange[thisid]}=Flocci$RaggedToFlat[Flocci$SSNode$UniIrrepDomin[thisid]];

//Timing )//Flocci$Timing["reps: 9.3"];
];

(*{thised,booled}=SEDecisionTreeAppend[(thisid\[Rule] inID),\[CapitalLambda]\[Rho]t]//Timing //Flocci$Timing["reps: 9.4"];*)
{thised,booled}=Flocci$EdgeAssocAppend[{thisid-> inID,\[CapitalLambda]\[Rho]t}]//Timing //Flocci$Timing["reps: 9.4"];


If[booled,
(Flocci$SSEdge$Edge[thised]=thisid-> inID;  (*A rule specifying the parent and child node.*)
Flocci$SSEdge$\[CapitalLambda]\[Rho][thised]=\[CapitalLambda]\[Rho]t;(*A matrix*)//Timing) //Flocci$Timing["reps: 9.5"];
]

,{r,out\[Beta]Association[out\[Beta]]}];
,{out\[Beta],Keys[out\[Beta]Association]}];

];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$ShowIntermediateGraph",{"UpDirec","-","A graph","Outputs the graph after the Updirec has been done. This is not the final graph of the program."}];
Flocci$ShowIntermediateGraph:=Module[{vertices,edgesV,labels},vertices= Range[Flocci$SSNode$MaxId];edgesV=Table[Flocci$SSEdge$Edge[i],{i,1,Flocci$SSEdge$MaxId}];
labels=Map[ Flocci$SSNode$Algebra[#]&,vertices];
Graph[edgesV,VertexLabels->{v_:>Placed[v(*Style[labels\[LeftDoubleBracket]v\[RightDoubleBracket]]*),Center]},VertexSize->0.4,ImageSize->Full,PlotTheme->"IndexLabeled",GraphLayout->"LayeredDigraphEmbedding"]]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$DeleteChildData",{"UpDirec","inID) The id of the child node just done.","None.","Deletes data that we no longer need."}];
Flocci$DeleteChildData[inID_]:=Module[{},
KeyDropFrom[Flocci$SSNode$UniIrrepDomin,inID];
KeyDropFrom[Flocci$SSNode$UniIrrepDominFlat,inID];
KeyDropFrom[Flocci$SSNode$UniIrrepDominRange,inID];
KeyDropFrom[Flocci$SSNode$UniHWs,inID];
KeyDropFrom[Flocci$SSNode$HWsMult,inID];
KeyDropFrom[Flocci$SSNode$Delta,inID];
KeyDropFrom[Flocci$SSNode$DeltaCoprime,inID];
];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$DeleteStoredData",{"UpDirec","None.","None.","Deletes stored data, helping with memory constraints."}];
Flocci$SetDescription["Flocci$DeleteStoredDataCounter",{"UpDirec","None.","None.","A user defined varible of how frequent to clear data."}];
Flocci$DeleteStoredData:=Module[{},
ClearSystemCache[];
];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$GenerateGraphUpwards",{"UpDirec","-","None.","This is the main code for generaing the graph upwards. In particular it runs Flocci$MakeParentNodes recursively."}];

Flocci$SetDescription["Flocci$UpAlgebraTracker",{"UpDirec","-","String.","Keeps track of current algebra for display."}]
Flocci$SetDescription["Flocci$User$MemoryPlot",{"UpDirec","-","A list of integers.","Keeps track of memory usage to plot memory graph."}]
Flocci$SetDescription["Flocci$DetailedProgressData",{"UpDirec","-","True or False.","A user defined option in SuperFlocci on whether or not do show detailed progress data."}]

Flocci$GenerateGraphUpwards:=Module[{progrssPlotTemp,algebraTrackerTemp,memoryPlotTemp,progrssPlotTempLab},

(*We monitor progress with trackers*)
Flocci$User$GraphPoints={{0,0,0}};
progrssPlotTemp=PrintTemporary[Dynamic[ListPlot[Transpose[Flocci$User$GraphPoints],Joined->True,Frame-> True,BaseStyle->{InsetBoxOptions->{Background->RGBColor@{0.996078431372549`,0.9529411764705882`,0.8901960784313725`}}}
,PlotLabel->"Progress"]]];
progrssPlotTempLab=PrintTemporary[LineLegend[ColorData[97,"ColorList"],{"Total number of nodes done.","Total number of nodes found.","No. found - No. done (first part of code will finish when this reaches 0)"}]];

If[Flocci$DetailedProgressData,Flocci$User$MemoryPlot={MemoryInUse[]/10^6};
memoryPlotTemp=PrintTemporary[Dynamic[ListPlot[Flocci$User$MemoryPlot,Joined->True,Frame-> True,BaseStyle->{InsetBoxOptions->{Background->RGBColor@{0.996078431372549`,0.9529411764705882`,0.8901960784313725`}}}
,PlotLabel->"Memory Usage"]]];
Flocci$UpAlgebraTracker="";
algebraTrackerTemp=PrintTemporary[Dynamic["Current algebra: "<>Flocci$UpAlgebraTracker]];
];

Monitor[While[Flocci$SSNode$currentSSid<= Flocci$SSNode$MaxId,
If[Flocci$DetailedProgressData,Flocci$UpAlgebraTracker=ToString[Flocci$SSNode$Algebra[Flocci$SSNode$currentSSid]]];
Do[
If[Length[x[[1]]]<=Flocci$SimpleIdealConstraint ,
Flocci$MakeParentNodes[Flocci$SSNode$currentSSid][x]
]
,{x,Flocci$MinimalSupAlgebras[Flocci$SSNode$Algebra[Flocci$SSNode$currentSSid],Flocci$User$MaxAlgList]}];

(*We clear data of the child node*)
Flocci$DeleteChildData[Flocci$SSNode$currentSSid];
(*We increment the id*) 
  Flocci$SSNode$currentSSid++;
(*If we are at the given frequency, we checkpoint the data*)
If[!(Flocci$Checkpoint$FileName===False)&&Mod[Flocci$SSNode$currentSSid,Flocci$Checkpoint$CheckpointUpFreq]==0,Flocci$Checkpoint$SaveDataUp];
(*If[Mod[Flocci$SSNode$currentSSid,checkpointfreq]\[Equal]0,Flocci$SaveCheckpoint[checkpointfile]];*)
(*We clear data every so many evaluations*)
If[Mod[Flocci$SSNode$currentSSid,Flocci$DeleteStoredDataCounter]==0, Flocci$DeleteStoredData];
AppendTo[Flocci$User$GraphPoints,{Flocci$SSNode$currentSSid,Flocci$SSNode$MaxId,Flocci$SSNode$MaxId-Flocci$SSNode$currentSSid}];
If[Flocci$DetailedProgressData,AppendTo[Flocci$User$MemoryPlot,MemoryInUse[]/10^6]];
],{Flocci$SSNode$currentSSid,Flocci$SSNode$MaxId,Flocci$SSNode$MaxId-Flocci$SSNode$currentSSid}];

NotebookDelete[progrssPlotTemp];
NotebookDelete[progrssPlotTempLab];
If[Flocci$DetailedProgressData,NotebookDelete[algebraTrackerTemp];NotebookDelete[memoryPlotTemp];];
]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$SpawnU1Nodes",{"DownDirec","idIn) The id of the node of the UpDirec graph to consider.","Either inId or Nothing.","Generarates the nodes in the RR graph based on the nodes of the SS graph. If a given idIn does not lead to any RR nodes, we output inID else Nothing."}];
Flocci$SpawnU1Nodes[idIn_]:=Module[{u1rows,u1rows1,stabalizerRows,orbits,representatives,nearestNeigbours,supSSid,supRRid,supRRidL,\[CapitalLambda]\[Rho],aut\[CapitalLambda]\[Rho],objectEquivelenceClasses},
(*We update our progress indicator*)
Flocci$U1ProgressCounter+=1;
Flocci$U1Progress=ToString[Flocci$U1ProgressCounter]<>" ("<>ToString[idIn]<>"): "<>Flocci$PrintLie[Flocci$SSNode$Algebra[idIn]];
(*We get all u1 rows which can be added to \[CapitalLambda]\[Alpha]*)
input={Flocci$SSNode$AnomFreeCharges[idIn],Flocci$SSNode$WS[idIn],Flocci$SSNode$HWs[idIn],Flocci$SSNode$Algebra[idIn],Flocci$SSNode$\[CapitalLambda]\[Alpha][idIn],Flocci$User$IrrepWeightLocation};
u1rows=Flocci$U1Find[Flocci$SSNode$AnomFreeCharges[idIn],Flocci$SSNode$WS[idIn],Flocci$SSNode$HWs[idIn],Flocci$SSNode$Algebra[idIn],Flocci$SSNode$\[CapitalLambda]\[Alpha][idIn],Flocci$User$IrrepWeightLocation];
(*We remove those rows which will never lead to a commuting extension of \[CapitalLambda]\[Alpha] to a full \[Alpha]*)
u1rows1=Select[u1rows,Flocci$ProjectionMatrixNonEmpty\[CapitalGamma]sQ[Flocci$SSNode$Algebra[idIn],Join[Flocci$SSNode$\[CapitalLambda]\[Alpha][idIn],#]]&];
If[Length[u1rows1]!= Length[u1rows],Print["Contradiction to supposed conjecture"]];
(*We now do the full test of weather a \[CapitalLambda]\[Alpha] extends to a full \[Alpha].*)
(*u1rows=Select[u1rows1,Flocci$ProjectionMatrixExtendableQ[Flocci$SSNode$Algebra[1],Flocci$SSNode$Algebra[idIn],Join[Flocci$SSNode$\[CapitalLambda]\[Alpha][idIn],#]]&];
(*JTS conjectures that the below will never output true..*)
If[Length[u1rows1]\[NotEqual] Length[u1rows],Print["Contradiction to supposed conjecture"]];*)
u1rows=u1rows1;
(*If no rows remain we output idIn, which indicates that this node and all those nodes below it in the SS tree are to be removed.*)
If[Length[u1rows]==0,Return[idIn];];
(*We want to find the orbits of the u1s under Automorphisms.*)
(*This may not be the same as the full automorphism group, since some out-automorphisms may change the u1 charges but not the semi-simple reps.*)
(*stabalizerRows=Select[Flocci$SSNode$AutPres\[CapitalLambda]\[Alpha][idIn], Function[o, Sort[Map[#.o&, u1rows]]==Sort[u1rows]]];
orbits=Map[Sort[DeleteDuplicates[Table[#.o,{o,stabalizerRows}]]]&, u1rows]//DeleteDuplicates;
representatives=orbits\[LeftDoubleBracket]All,1\[RightDoubleBracket];*)
(*We want to get the equivelence classes of objects, and the morphisms which connect them*)
objectEquivelenceClasses=Map[Sort[DeleteDuplicates[Table[#.o,{o,Flocci$SSNode$AutPres\[CapitalLambda]\[Alpha][idIn]}]]]&, u1rows]//DeleteDuplicates;
representatives=objectEquivelenceClasses[[All,1]];
(*We select direct parent nodes to the current nodes*)
nearestNeigbours=Select[Flocci$SSEdge$EdgeList,#[[1,2]]==idIn&];

Do[(*We sum over representatives of objectEquivelenceClasses. Each representative gives a different node on our RR graph.*)
(*We create the node*)
Flocci$RRNode$MaxId+=1;
Flocci$RRNode$CorSSid[Flocci$RRNode$MaxId]=idIn;
Flocci$RRNode$U1\[CapitalLambda]\[Alpha]Rows[Flocci$RRNode$MaxId]=representatives[[r]];
(*Flocci$RRNode$StabalizeU1List[Flocci$RRNode$MaxId]=stabalizerRows;*)
Flocci$RRNode$U1EquivelenceClasses[Flocci$RRNode$MaxId]=objectEquivelenceClasses[[r]];
(*We now want to consider the morphisms*)
Do[(*For each of the existing parent edge we want to see new edges.*)
(*For the parent node in SS, we get the corresponding nodes in RR*)
supSSid=n[[1,1]]; 
supRRidL=Select[Range[Flocci$RRNode$MaxId],Flocci$RRNode$CorSSid[#]==supSSid &]; (*The corresponding list of Flocci$RRNode$MaxId's*)
(*We select the parent nodes which maps down to the current node under \[CapitalLambda]\[Rho]*)
\[CapitalLambda]\[Rho]=n[[2]];
supRRid=Select[supRRidL, MemberQ[Flocci$RRNode$U1EquivelenceClasses[#],representatives[[r]].\[CapitalLambda]\[Rho]]&][[1]]; (*The length of this must be 1*)
(*We want to select an outer automorphism so that the projection matrix works for the represenative*)
aut\[CapitalLambda]\[Rho]=Select[Flocci$SSNode$AutPres\[CapitalLambda]\[Alpha][supSSid],representatives[[r]].\[CapitalLambda]\[Rho].#==Flocci$RRNode$U1\[CapitalLambda]\[Alpha]Rows[supRRid] &];
\[CapitalLambda]\[Rho]=\[CapitalLambda]\[Rho].aut\[CapitalLambda]\[Rho][[1]];
(*We then save this data to our list of edges.*)
Flocci$RREdge$MaxId+=1;
Flocci$RREdge$Edge[Flocci$RREdge$MaxId]=supRRid-> Flocci$RRNode$MaxId;
Flocci$RREdge$\[CapitalLambda]\[Rho][Flocci$RREdge$MaxId]=\[CapitalLambda]\[Rho];
,{n,nearestNeigbours}];
,{r,1,Length[representatives]}];
(*If we get to this point, our SS node gives valid RR nodes.*)
Nothing
]


(* ::Input::Initialization:: *)
Flocci$RRNode$Algebra[id_]:=Flocci$SSNode$Algebra[Flocci$RRNode$CorSSid[id]]
Flocci$RRNode$HWs[id_]:=Flocci$SSNode$HWs[Flocci$RRNode$CorSSid[id]]
Flocci$RRNode$WS[id_]:=Flocci$SSNode$WS[Flocci$RRNode$CorSSid[id]]
Flocci$RRNode$\[CapitalLambda]\[Alpha][id_]:=Join[Flocci$SSNode$\[CapitalLambda]\[Alpha][Flocci$RRNode$CorSSid[id]],Flocci$RRNode$U1\[CapitalLambda]\[Alpha]Rows[id]]
Flocci$RRNode$AlgebraList:=Table[{Flocci$RRNode$Algebra[id],Flocci$RRNode$HWs[id],Flocci$RRNode$\[CapitalLambda]\[Alpha][id]},{id,1,Flocci$RRNode$MaxId}]
Flocci$RREdge$EdgeList:=Table[{Flocci$RREdge$Edge[id],Flocci$RREdge$\[CapitalLambda]\[Rho][id]},{id,1,Flocci$RREdge$MaxId}]


(* ::Input::Initialization:: *)
Flocci$VertexDelete[p_,assMap_]:=
Module[{newEdges,alledges,oldEdges},
If[p==1,Return[{}]];
oldEdges={p};
alledges={p};

alledges=Reap[While[True,
newEdges=Select[Flatten[Map[assMap,oldEdges]],(!MemberQ[alledges,#])&];
If[Length[newEdges]==0,Break[]];
oldEdges=DeleteDuplicates[DeleteCases[newEdges,1]];
Sow[oldEdges];
];];
Prepend[alledges[[2]],p]//Flatten//DeleteDuplicates

]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$GenerateGraphDownwards",{"DownDirec","UserAlgebra) The inputed user algebra.\nUserHW)The inputted user weight system. ","Nothing.","Works through the SS graph to create the RR graph. Then it performs the checks on extending \[CapitalLambda]\[Alpha] to \[Alpha]."}];
Flocci$GenerateGraphDownwards[UserAlgebra_,UserHW_]:=Module[{vertices,edgesV,Vertexasc,assMap,edgeListFlat,maximalSS,g,toRemove,PathRemove,paths,verticesDelete,minimal,conjectureBool,u1ProgressTemp},
 Flocci$RRNode$MaxId=0;
 Flocci$RREdge$MaxId=0;
Flocci$UserHW=UserHW;
(*We start with a list of vertices and edges, and make the full graph.*)
vertices= Range[Flocci$SSNode$MaxId];
edgesV=Table[Flocci$SSEdge$Edge[i],{i,1,Flocci$SSEdge$MaxId}];
g=Graph[vertices,edgesV];
edgeListFlat=edgesV/.Rule[x_,y_]:> {x,y};
assMap=Map[#[[All,2]] &,GroupBy[edgeListFlat,#[[1]]&]];
(*We extract the maximial nodeS of the garph.*)
maximalSS=GraphComputation`SourceVertexList[g];
(*We create an progress monitor*)
Flocci$U1Progress="";
Flocci$U1ProgressCounter=0;
u1ProgressTemp=PrintTemporary[Dynamic[Flocci$U1Progress]];
While[!(maximalSS==={1}),
graphTest={maximalSS,g,PathRemove,vertices,edgesV,assMap};
(*DumpSave["GraphTest4.mx",{graphTest}];*)
(*For each maximal node SS node, we make the RR nodes. If no RR nodes exist, the corresponding id will be in this list. *)
PathRemove=Map[Flocci$SpawnU1Nodes,maximalSS];
(*We will delete all maximal nodes, and all paths from those for which no u1 exists.*)
verticesDelete=maximalSS;
Monitor[Do[
verticesDelete=DeleteCases[DeleteDuplicates[Join[verticesDelete,Flocci$VertexDelete[p,assMap]]],1];
,{p,PathRemove}],p];

vertices=Complement[vertices,verticesDelete];
Vertexasc=AssociationMap[True&,verticesDelete];
edgesV=Select[edgesV,!(Lookup[Vertexasc,#[[1]],False]||Lookup[Vertexasc,#[[2]],False])&];

(*We repeate the above steps with the new maximal nodes, until we have none left.*)
g=Graph[vertices,edgesV];
maximalSS=GraphComputation`SourceVertexList[g];

(*verticesDelete=maximalSS;
Do[
paths=FindPath[g,p,1,Infinity,All];
verticesDelete=DeleteCases[DeleteDuplicates[Join[verticesDelete,Flatten[paths]]],1];
,{p,PathRemove}];
vertices=Select[vertices,!MemberQ[verticesDelete,#]&];
edgesV=Select[edgesV,!(MemberQ[verticesDelete,#\[LeftDoubleBracket]1\[RightDoubleBracket]]||MemberQ[verticesDelete,#\[LeftDoubleBracket]2\[RightDoubleBracket]])&];
(*We repeate the above steps with the new maximal nodes, until we have none left.*)
g=Graph[vertices,edgesV];
maximalSS=GraphComputation`SourceVertexList[g];*)
];

(*We now do the full test of weather a \[CapitalLambda]\[Alpha] extends to a full \[Alpha]. This should really be in Flocci$SpawnU1Nodes. However, if the minimal pass then it is sufficent to do only these. We conjecture that this check never fails.*)
PrintTemporary["Performing check on extending \[CapitalLambda]\[Alpha] to full \[Alpha]."]; 
If[Flocci$PerformExtendingChecks,
(*We get the sink vertcies*)
edgesV=Table[Flocci$RREdge$Edge[i],{i,1,Flocci$RREdge$MaxId}];
vertices= Range[Flocci$RRNode$MaxId];
g=Graph[vertices,edgesV];
minimal=GraphComputation`SinkVertexList[g];
conjectureBool=True;
Do[
conjectureBoolTemp=Flocci$ProjectionMatrixExtendableQ[Flocci$SSNode$Algebra[1],Flocci$RRNode$Algebra[m],Flocci$RRNode$\[CapitalLambda]\[Alpha][m]];
(*The below will output false on e.g. A1,A2,U1 {{0,1,1,-4},{0,1,1,4},{1,0,1,-1},{1,1,0,1}}*)
If[!conjectureBoolTemp,Print["Some algebras are not extendable, a more detailed analysis will be done. Example of fail: ",Flocci$RRNode$Algebra[m],Flocci$RRNode$\[CapitalLambda]\[Alpha][m]];conjectureBool=False;Break[];];
,{m,minimal}];
(*If the result is not true - we extract all algebras for which it fails. JTS:20/01/23*)
Block[{minimalBreak,edgesRmv,verticesRmv,compVert,compEdge},
If[!conjectureBool,
(*We find which of the minimal algebras break the condition*)
While[True,
minimalBreak=Monitor[Table[ If[Flocci$ProjectionMatrixExtendableQ[Flocci$SSNode$Algebra[1],Flocci$RRNode$Algebra[mt],Flocci$RRNode$\[CapitalLambda]\[Alpha][mt]],Nothing,mt],{mt,minimal}],{mt,Length[minimal]}];
If[Length[minimalBreak]==0,Break[];];
(*We find the new minima*)
edgesRmv=Select[Range[Flocci$RREdge$MaxId],MemberQ[minimalBreak,Flocci$RREdge$Edge[#][[1]]]||MemberQ[minimalBreak,Flocci$RREdge$Edge[#][[2]]]&];
verticesRmv=minimalBreak//Sort;
(*Changing: Flocci$RRNode$MaxId, Flocci$RRNode$CorSSid, Flocci$RRNode$U1\[CapitalLambda]\[Alpha]Rows, Flocci$RRNode$U1EquivelenceClasses,Flocci$RRNode$Algebra,Flocci$RRNode$HWs,Flocci$RRNode$WS,Flocci$RRNode$\[CapitalLambda]\[Alpha]*)
compVert=Complement[vertices,minimalBreak]//Sort;
Flocci$RRNode$MaxId=Flocci$RRNode$MaxId-Length[minimalBreak];
Do[
Flocci$RRNode$CorSSid[ip]=Flocci$RRNode$CorSSid[compVert[[ip]]];
Flocci$RRNode$U1\[CapitalLambda]\[Alpha]Rows[ip]=Flocci$RRNode$U1\[CapitalLambda]\[Alpha]Rows[compVert[[ip]]];
Flocci$RRNode$U1EquivelenceClasses[ip]=Flocci$RRNode$U1EquivelenceClasses[compVert[[ip]]];
,{ip,1,Flocci$RRNode$MaxId}];
(*Changing: Flocci$RREdge$MaxId,Flocci$RREdge$Edge,Flocci$RREdge$\[CapitalLambda]\[Rho] *)
compEdge=Complement[Range[Flocci$RREdge$MaxId],edgesRmv]//Sort;
Flocci$RREdge$MaxId=Flocci$RREdge$MaxId-Length[edgesRmv];
Do[
Flocci$RREdge$Edge[ip]=Flocci$RREdge$Edge[compEdge[[ip]]]/. Thread[compVert-> Range[Flocci$RRNode$MaxId]];
Flocci$RREdge$\[CapitalLambda]\[Rho][ip]=Flocci$RREdge$\[CapitalLambda]\[Rho][compEdge[[ip]]];
,{ip,1,Flocci$RREdge$MaxId}];
edgesV=Table[Flocci$RREdge$Edge[i],{i,1,Flocci$RREdge$MaxId}];
vertices= Range[Flocci$RRNode$MaxId];
g=Graph[vertices,edgesV];
minimal=GraphComputation`SinkVertexList[g];
];
];
];];
PrintTemporary["End of check on extending \[CapitalLambda]\[Alpha] to full \[Alpha]."]; 
NotebookDelete[u1ProgressTemp];
]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$ShowFinalGraph",{"DownDirec","-","A graph","Generates the final RR graph."}];
Flocci$ShowFinalGraph:=Module[{vertices,edgesV,labels},vertices= Range[Flocci$RRNode$MaxId];edgesV=Table[Flocci$RREdge$Edge[i],{i,1,Flocci$RREdge$MaxId}];
labels=Map[ Flocci$RRNode$Algebra[#]&,vertices];
Graph[vertices,edgesV,VertexLabels->{v_:>Placed[v(*Style[labels\[LeftDoubleBracket]v\[RightDoubleBracket]]*),Center]},VertexSize->0.4,ImageSize->Full,PlotTheme->"IndexLabeled",GraphLayout->"LayeredDigraphEmbedding"]]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$Checkpoint$FileName",{"Checkpoint","-","False or a string.","False is checkpointing should not be done. The start bit of the file name, if checkpointing should be done."}];
Flocci$SetDescription["Flocci$Checkpoint$CheckpointUpFreq",{"Checkpoint","-","An integer.","How often in terms of Flocci$SSNode$currentSSid should checkpointing be done."}];
Flocci$SetDescription["Flocci$Checkpoint$StartFromCheckpoint",{"Checkpoint","-","True or False.","If true, the evalutation will start from a mid-point if the required file name exists."}];


(* ::Input::Initialization:: *)
SetDirectory[NotebookDirectory[]];
Flocci$SetDescription["Flocci$Checkpoint$SaveDataUp",{"Checkpoint","-","-","Saves the minimal set of data required to restart the code from mid-evalutation."}];
Flocci$Checkpoint$SaveDataUp:=Module[{},
PrintTemporary["Checkpointed"];

DumpSave[Flocci$Checkpoint$FileName<>".mx",{Flocci$SSNode$currentSSid,Flocci$SSNode$MaxId,Flocci$SSNode$Algebra,Flocci$SSNode$HWs,Flocci$SSNode$WS,Flocci$SSNode$UniIrrepDomin,Flocci$SSNode$UniIrrepDominFlat,Flocci$SSNode$UniIrrepDominRange,Flocci$SSNode$UniHWs,Flocci$SSNode$HWsMult,Flocci$SSNode$Delta,Flocci$SSNode$DeltaCoprime,Flocci$SSNode$\[CapitalLambda]\[Alpha],Flocci$SSNode$AutPres\[CapitalLambda]\[Alpha],Flocci$SSNode$AnomFreeCharges,Flocci$SSNode$AlgebraList,Flocci$SSEdge$MaxId,Flocci$SSEdge$Edge,Flocci$SSEdge$\[CapitalLambda]\[Rho],Flocci$SSEdge$EdgeList,Flocci$VertexAssoc,Flocci$EdgeAssoc}];
];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$Checkpoint$Restart",{"Checkpoint","-","-","Reads in data required for restart at a mid-evaluation point."}];
Flocci$Checkpoint$Restart:=Module[{},
PrintTemporary["Loading in saved data"];
Import[Flocci$Checkpoint$FileName<>".mx"];
];


(* ::Input::Initialization:: *)
(*The SS nodes*)
Flocci$SetDescription["Flocci$SSNode$currentSSid",{"Global","-","Integer","The current child node we are looking at. This will be less then Flocci$SSNode$MaxId.","1"}];
Flocci$SetDescription["Flocci$SSNode$MaxId",{"Global","-","Integer","The number of SS nodes generated.","1"}];
Flocci$SetDescription["Flocci$SSNode$Algebra",{"Global","i) Integer >= 1","A semi-simple algebra","The algebra associated with SS node i.","2"}];
Flocci$SetDescription["Flocci$SSNode$HWs",{"Global","i) Integer >= 1","An integer 2-tensor.","The heighest weights associated with SS node i.","2"}];
Flocci$SetDescription["Flocci$SSNode$WS",{"Global","i) Integer >= 1","An integer 2-tensor.","The weight system of Flocci$SSNode$HWs[i].","2"}];
Flocci$SetDescription["Flocci$SSNode$UniIrrepDomin",{"Global","i) Integer >= 1","A ragged list of 2-tensors.","The dominant weights of unique irreps appearing in Flocci$SSNode$HWs[i]. Could be un-globalized.","2"}];
Flocci$SetDescription["Flocci$SSNode$UniIrrepDominFlat",{"Global","i) Integer >= 1","An integer 2-tensors.","A flattened version of Flocci$SSNode$UniIrrepDomin[i].","2"}]
Flocci$SetDescription["Flocci$SSNode$UniIrrepDominRange",{"Global","i) Integer >= 1","An integer 2-tensors.","The ranges between which each 2-tensor in  Flocci$SSNode$UniIrrepDomin[i] appears in the flattened version Flocci$SSNode$UniIrrepDominFlat[i].","2"}]
Flocci$SetDescription["Flocci$SSNode$UniHWs",{"Global","i) Integer >= 1","An integer 2-tensors.","The highest weights associated with SS node i with duplicates deleted.","2"}]
Flocci$SetDescription["Flocci$SSNode$HWsMult",{"Global","i) Integer >= 1","An integer 1-tensors.","The multiplicity of each unique type of weight in Flocci$SSNode$HWs[i] in an order matching Flocci$SSNode$UniHWs[i].","2"}]
Flocci$SetDescription["Flocci$SSNode$Delta",{"Global","i) Integer >= 1","An 1-tensors.","A concontatination of the vectors formed by applying the metric tensor of each simple ideal in Flocci$SSNode$Algebra[i] to the constant vector of 1s. ","2"}]
Flocci$SetDescription["Flocci$SSNode$Delta",{"Global","i) Integer >= 1","An 1-tensors.","A concontatination of the vectors formed by applying the metric tensor of each simple ideal in Flocci$SSNode$Algebra[i] to the constant vector of 1s.Could be un-globalized. ","2"}]
Flocci$SetDescription["Flocci$SSNode$DeltaCoprime",{"Global","i) Integer >= 1","An integer 1-tensors.","A constant multiple of Flocci$SSNode$Delta such that all entries are integer.","2"}]
Flocci$SetDescription["Flocci$SSNode$\[CapitalLambda]\[Alpha]",{"Global","i) Integer >= 1","An integer 2-tensors.","The projection matrix down to the semi-simple part of the user input algebra associated with the SS node i.","2"}]
Flocci$SetDescription["Flocci$SSNode$AutPres\[CapitalLambda]\[Alpha]",{"Global","i) Integer >= 1","An  list of integer 2-tensors.","The automorphisms of Flocci$SSNode$Algebra[i] which preserve the weight system and Flocci$SSNode$\[CapitalLambda]\[Alpha][i].","2"}]
Flocci$SetDescription["Flocci$SSNode$AnomFreeCharges",{"Global","i) Integer >= 1","An integer 3-tensors.","Charge assigments matching the weightsystem which pass anomaly free checks. Permutations amonst equal weights are not repeated.","2"}]
Flocci$SetDescription["Flocci$SSNode$AlgebraList",{"Global","-","A list of triples.","Outputs the list of all {Flocci$SSNode$Algebra[i],Flocci$SSNode$HWs[i],Flocci$SSNode$\[CapitalLambda]\[Alpha][i]}"}];

(*The SS edges*)
Flocci$SetDescription["Flocci$SSEdge$MaxId",{"Global","-","An Integer.","The number of SS edges generated.","1"}];
Flocci$SetDescription["Flocci$SSEdge$Edge",{"Global","i) Integer >= 1 and <= Flocci$SSEdge$MaxId","A Rule[...,...]","The rule will be j1->j2 indicating that j1 is a parent node of j2.","2"}];
Flocci$SetDescription["Flocci$SSEdge$\[CapitalLambda]\[Rho]",{"Global","i) Integer >= 1 and <= Flocci$SSEdge$MaxId","A 2-integer.","The projection matrix associated with the edge Flocci$SSEdge$Edge[i].","2"}];
Flocci$SetDescription["Flocci$SSEdge$EdgeList",{"Global","-","A list of pairs.","Outputs the list of all Flocci$SSEdge$Edge[i],Flocci$SSEdge$\[CapitalLambda]\[Rho][i]"}];
(*The RR nodes*)
Flocci$SetDescription["Flocci$RRNode$MaxId",{"Global","-","An Integer.","The number of RR edges generated.","1"}];
Flocci$SetDescription["Flocci$RRNode$CorSSid",{"Global","i) An Integer >= 1 and <=Flocci$RRNode$MaxId","An Integer.","The id of the SS node this RR node spawned from.","2"}];
Flocci$SetDescription["Flocci$RRNode$U1\[CapitalLambda]\[Alpha]Rows",{"Global","i) An Integer >= 1 and <=Flocci$RRNode$MaxId","An Integer 2-tensor.","The rows of \[CapitalLambda]\[Alpha] associated with U(1)'s.","2"}];
(*Flocci$SetDescription["Flocci$RRNode$StabalizeU1List",{"Global","i) An Integer >= 1 and <=Flocci$RRNode$MaxId","A  integer 3-Tensor.","Let idIn be the corresponding SS node id. The subgroup of Flocci$SSNode$AutPres\[CapitalLambda]\[Alpha][idIn] which preserves the list of all u1 rows (not point wise).","2"}];*)
Flocci$SetDescription["Flocci$RRNode$U1EquivelenceClasses",{"Global","i) An Integer >= 1 and <=Flocci$RRNode$MaxId","An Integer 3-tensor.","The connected elements of Flocci$RRNode$U1\[CapitalLambda]\[Alpha]Rows[i] under the action of  Flocci$SSNode$AutPres\[CapitalLambda]\[Alpha][inID].","2"}];
Flocci$SetDescription["Flocci$RRNode$Algebra",{"Global","i) Integer >= 1 and <=Flocci$RRNode$MaxId","A semi-simple algebra","The algebra associated with RR node i."}];
Flocci$SetDescription["Flocci$RRNode$HWs",{"Global","i) Integer >= 1 and <=Flocci$RRNode$MaxId","An integer 2-tensor.","The heighest weights associated with RR node i."}];
Flocci$SetDescription["Flocci$RRNode$WS",{"Global","i) Integer >= 1 and <=Flocci$RRNode$MaxId","An integer 2-tensor.","The weight system of Flocci$RRNode$HWs[i]."}];
Flocci$SetDescription["Flocci$RRNode$\[CapitalLambda]\[Alpha]",{"Global","i) Integer >= 1 and <=Flocci$RRNode$MaxId","An integer 2-tensors.","The projection matrix down to the user input algebra associated with the RR node i."}]
Flocci$SetDescription["Flocci$RRNode$AlgebraList",{"Global","-","A list of triples.","Outputs the list of all {Flocci$RRNode$Algebra[id],Flocci$RRNode$HWs[id],Flocci$RRNode$\[CapitalLambda]\[Alpha][id]}"}];

(*The RR edges*)
Flocci$SetDescription["Flocci$RREdge$MaxId",{"Global","-","An Integer.","The number of RR edges generated.","1"}];
Flocci$SetDescription["Flocci$RREdge$Edge",{"Global","i) Integer >= 1 and <= Flocci$RREdge$MaxId","A Rule[...,...]","The rule will be j1->j2 indicating that j1 is a parent node of j2.","2"}];
Flocci$SetDescription["Flocci$RREdge$\[CapitalLambda]\[Rho]",{"Global","i) Integer >= 1 and <= Flocci$RREdge$MaxId","A 2-integer.","The projection matrix associated with the edge Flocci$RREdge$Edge[i].","2"}];
Flocci$SetDescription["Flocci$RREdge$EdgeList",{"Global","-","A list of pairs.","Outputs the list of all {Flocci$RREdge$Edge[id],Flocci$RREdge$\[CapitalLambda]\[Rho][id]}"}];

(*Other global varibles*)
Flocci$FunctionListAdd[{"Flocci$User$A1Dim","Flocci$User$U1sPresentBool","Flocci$User$RootList","Flocci$User$IrrepWeightLocation","Flocci$User$MaxAlgList","Flocci$User$GraphPoints"}];
Flocci$SetDescription["Flocci$User$A1Dim",{"Global","-","An Integer.","The dimension of all reps that are tirivial under all non-A1 factors.","1"}];
Flocci$SetDescription["Flocci$User$U1sPresentBool",{"Global","-","True or False","True if the user algebra contains U(1)'s, False otherwise.","1"}];
Flocci$SetDescription["Flocci$User$RootList",{"Global","-","A Integer 2-Tensor","A list of the roots for the user algebra, with 0's for U(1) factors.","1"}];
Flocci$SetDescription["Flocci$User$IrrepWeightLocation",{"Global","-","A Integer 2-Tensor","Contains a list based on the user algebra e.g. {{31, 32}, {1, 2}, {3, 4}, {7, 8}, {25, 26}, {27, 28}, {-1, -1}, {17, 20}, {9, 12}, {21, 24}, {-1, -1}, {29, 30}, {5, 6}, {-1, -1}, {13, 16}}. The {-1,-1} splits distinict irreps. The first number e.g. {31,32} is the location of the highest weight. The numbers which follow are the positions of the other weights for that representation (in no real order).","1"}];
Flocci$SetDescription["Flocci$User$MaxAlgList",{"Global","-","A list of triples containing 1) The simple parent algebra. 2) The semi-simple child algebra. 3) The projection matrix.","Contains the dynamically generated list of maximal embeddings","1"}];
Flocci$SetDescription["Flocci$User$GraphPoints",{"Global","-","A 2-tensor","Used for plotting the progress graph on running the code.","1"}];
Flocci$SetDescription["Flocci$U1Progress",{"Global","-","A string","Used to monitor the progress in the downward direction.","1"}];
Flocci$SetDescription["Flocci$U1ProgressCounter",{"Global","-","An Integer","Used to monitor the progress in the downward direction.","1"}];
Flocci$SetDescription["Flocci$ProjectionMatrixList",{"Global","-","False or list of projection matrices","Optional input, so algebra list does not have to be created multiple times."}]
Flocci$SetDescription["Flocci$SimpleIdealConstraint",{"Global","-","An Integer","Optional input, limiting the number simple ideals in the up direction tree."}];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$InitializeInputData",{"Meta","UserAlgbra) The User algebra.\n UserHW) The User highest weights.","None.","Sets global varibles, and the first node of the SS graph. Runs Flocci$GenerateMaxEmbeddingList."}];
Flocci$InitializeInputData[UserAlgebra_,UserHW_]:=Module[{rank,U1ws,chargesUser,noU1s,weightList,weightListFlat},
Flocci$ClearSavedData;
(*.......................................*)
(*We want to count the number of U1's in our algebra.*)
noU1s=Count[UserAlgebra,U1];
Flocci$User$U1sPresentBool=noU1s!= 0;
(*.......................................*)
(*We reset our counters*)
Flocci$SSNode$MaxId=1;(*Flocci$SSNode$MaxId tracks the nodes*)
Flocci$SSEdge$MaxId=0; (*Flocci$SSEdge$MaxId tracks the edges*)
(*.......................................*)
(*We initiate association maps.*)
Flocci$SSNode$UniIrrepDomin=<||>;
Flocci$SSNode$UniIrrepDominFlat=<||>;
Flocci$SSNode$UniIrrepDominRange=<||>;
Flocci$SSNode$UniHWs=<||>;
Flocci$SSNode$HWsMult=<||>;
Flocci$SSNode$Delta=<||>;
Flocci$SSNode$DeltaCoprime=<||>;
Flocci$SSNode$AutPres\[CapitalLambda]\[Alpha]=<||>;
(*.......................................*)
(*We start saving the data for our terminal node regarding the representation \[Beta].*)
Flocci$SSNode$Algebra[1]=Take[UserAlgebra,{1,-noU1s-1}]//Sort; (*Algebra*) 
Flocci$SSNode$HWs[1]=Flatten/@Take[UserHW,All,{1,-noU1s-1}]//Sort; (*hw of representation, without u(1) charges*)
Flocci$SSNode$WS[1]=Join@@Map[Flocci$WeightSystemSorted[Flocci$SSNode$Algebra[1],#]&,Flocci$SSNode$HWs[1]]//Sort;(*The sorted weight system of the representation*)

Flocci$SSNode$UniIrrepDomin[1]=Map[Flocci$ExtractDominantWeights[Flocci$WeightSystemSorted[Flocci$SSNode$Algebra[1],#]]&,DeleteDuplicates[Flocci$SSNode$HWs[1]]];(*The dominant weights of unique irreps appearing in \[Beta]*)
{Flocci$SSNode$UniIrrepDominFlat[1],Flocci$SSNode$UniIrrepDominRange[1]}=Flocci$RaggedToFlat[Flocci$SSNode$UniIrrepDomin[1]];(*\[Beta]uniWSFlat contains a list of weights and \[Beta]uniWSFlatRange 
(a nx2 matrix) contains how they should be partitioned *)
Flocci$SSNode$UniHWs[1]=Tally[Flocci$SSNode$HWs[1]][[All,1]];(*child hws (flattened) eg. list of {1,0,0}*)
Flocci$SSNode$HWsMult[1]=Tally[Flocci$SSNode$HWs[1]][[All,2]];(*list of their multiplicities*)
(*.......................................*)
(*Creating \[Delta]'s*)
Flocci$SSNode$Delta[1]=Flatten[Table[Flocci$MetricTensor[a].ConstantArray[1,Flocci$Rank[a]],{a,Flocci$SSNode$Algebra[1]}]];
Flocci$SSNode$DeltaCoprime[1]=Flocci$SSNode$Delta[Flocci$SSNode$MaxId]/GCD@@Flocci$SSNode$Delta[1];
(*.......................................*)
(*A1 dim: We count the number of dimensions in A1's only.*)
Flocci$User$A1Dim=Module[{A1only},
A1only=Select[Flocci$SSNode$HWs[1],Total[Pick[TakeList[#,Flocci$Rank[Flocci$SSNode$Algebra[1]]],!(#===SU2)&/@Flocci$SSNode$Algebra[1]],2]==0&];
Flocci$Dim[Flocci$SSNode$Algebra[1],A1only]];(*The dimension of all reps that are trivial under all non-su(2) factors*)
(*.......................................*)
(*The embedding \[Alpha]: We want to save data regarding the projection matrix \[CapitalLambda]\[Alpha], which in this case is the identity.*)
rank=Flocci$Rank[Flocci$SSNode$Algebra[1]]//Total;
Flocci$SSNode$\[CapitalLambda]\[Alpha][1]=IdentityMatrix[rank];(*\[CapitalLambda]\[Alpha] is the identity matrix*)
Flocci$SSNode$AutPres\[CapitalLambda]\[Alpha][1]={IdentityMatrix[rank]};(*The only automorphism which preserves the identity, is the identity*)
(*.......................................*)
(*U(1) charges: We construct global varibles relating to the U(1) charges.*)
U1ws=Flocci$SSNode$WS[1];


If[Flocci$User$U1sPresentBool,
U1ws=Table[Flocci$WeightSystemSorted[Flocci$SSNode$Algebra[1],Flatten[Take[hw,{1,-1-noU1s}]]],{hw,UserHW}];
U1ws=Table[Map[Join[#,Flatten[Take[UserHW[[i]],{-noU1s,-1}]]]&,U1ws[[i]]],{i,1,Length[U1ws]}];
U1ws=Flatten[U1ws,1]//Sort; (*The weight system with U(1) factors*)

chargesUser=Take[Transpose[U1ws],{-noU1s,-1}]//Transpose;(*A 2-tensor of charges.*)
Flocci$SSNode$AnomFreeCharges[1]={chargesUser};(*A 3-tensor of charges.*)
Flocci$User$RootList=Map[Join[#,ConstantArray[0,noU1s]]&,Flocci$Roots[Flocci$SSNode$Algebra[1]]];(*A list of roots for our algebra. This is used in the elementary check of U(1)'s.*)
(*We create a weight list, with the highest weight at the front, and sorted by their lengths*)
weightList=SortBy[Map[Prepend[DeleteCases[Flocci$WeightSystemSorted[Flocci$SSNode$Algebra[1],#],#],#]&,DeleteDuplicates[Flocci$SSNode$HWs[1]]],-Length[#]&];
weightList=Riffle[weightList,"new"];
weightListFlat=Flatten[weightList,1];
Flocci$User$IrrepWeightLocation=Map[If[#==="new",{-1,-1},Position[Flocci$SSNode$WS[1],#][[{1,-1},1]]]&,weightListFlat];
];
(*.......................................*)
(*We generate the maximal list of algebras.*)
Flocci$User$MaxAlgList =If[!(Flocci$ProjectionMatrixList===False),Flocci$ProjectionMatrixList,Flocci$GenerateMaxEmbeddingList[U1ws]] ;
(*Generate list of maximal embeddings up to lowest dimensional irrep of parent algebra <= Length[Flocci$SSNode$WS[Flocci$SSNode$MaxId]]*)
(*.......................................*)
(*We configure the Timing functions, and reset Flocci$SSNode$currentSSid*)
Flocci$SSNode$currentSSid=1;
Flocci$TimingReset;
]



(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$ClearSavedData",{"Meta","-","-","Clears data stored during the running of the code. This uses function::clear to determine what to do with a specific function."}];
Flocci$ClearSavedData:=Module[{clearTypes,unDefine,downEmpty,downBut1,downBut2},
(*We extract the clear types of the functions.*)
clearTypes=Map[ToExpression[#,InputForm,Function[x,MessageName[x,"clear"],HoldFirst]]&,Flocci$FunctionList];
(*We get those functions which we simply want to undefine. Clear=1*)
unDefine=Flocci$FunctionList[[Position[clearTypes,"1"]//Flatten]];
Clear[#] &/@ unDefine;
(*We get those functions we want to set the DownValues equal to {}. Clear=2*)
downEmpty=Flocci$FunctionList[[Position[clearTypes,"2"]//Flatten]];
Map[ToExpression[#,InputForm,Function[x,DownValues[x]={},HoldFirst]]&,downEmpty];
(*We get those functions we want to set (DownValues[#]={DownValues[#]\[LeftDoubleBracket]-1\[RightDoubleBracket]}). Clear=3*)
downBut1=Flocci$FunctionList[[Position[clearTypes,"3"]//Flatten]];
Map[ToExpression[#,InputForm,Function[x,DownValues[x]={DownValues[x][[-1]]},HoldFirst]]&,downBut1];
(*We get those functions we want to set (DownValues[#]=Take[DownValues[#],{-2,-1}]. Clear=4*)
downBut2=Flocci$FunctionList[[Position[clearTypes,"4"]//Flatten]];
Map[ToExpression[#,InputForm,Function[x,DownValues[x]={DownValues[x][[-2]],DownValues[x][[-1]]},HoldFirst]]&,downBut2];
(*We clear association data*)
Flocci$VertexAssoc=Association[];
Flocci$EdgeAssoc=Association[];
]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$GenerateGraph",{"Meta","UserAlgebra) The User algebra.\n fermionicReps) The inputed highest weights.","None","Runs the code to generate the graph upwards and downwards."}];
Flocci$GenerateGraph[UserAlgebra_,fermionicReps_]:=Module[{},
PrintTemporary["Making the semi-simple tree:"];
Flocci$GenerateGraphUpwards;
(*Print[Flocci$IntermediateGraph];*)
If[Flocci$User$U1sPresentBool,
PrintTemporary["Dealing with the u(1)'s:"];
Flocci$GenerateGraphDownwards[UserAlgebra,fermionicReps];
];

];


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$MaxMinOutputReorder",{"Display","ouput) The output of SuperFlocci","A list of: \n algListRe)The algebra list reordered.\n edgeListRe) The edge list adjusted for the reordring\n The number of max algebras. \n The number of min Algebras.","Reorders the output of SuperFlocci, so that the max and min algebras come first."}];
Flocci$MaxMinOutputReorder[output_]:=Module[{algList,edgeList,vertices,edgesV,graphRaw,maxList,minList,nonMaxMin,reorder,ordInv,algListRe,edgeListRe},
(*We extract the data from output*)
algList=output[[3]];
edgeList=output[[4]];
(*We make the graph*)
vertices= Range[Length[algList]];
edgesV=edgeList[[All,1]];
graphRaw=Graph[vertices,edgesV];
maxList=GraphComputation`SourceVertexList[graphRaw];
minList=GraphComputation`SinkVertexList[graphRaw];
Do[minList=DeleteCases[minList,m],{m,maxList}];
(*We want to create a reordering, where the maxList and the minList come first*)
nonMaxMin=Complement[Range[Length[algList]],Join[maxList,minList]]//Sort;
reorder=Join[maxList,minList,nonMaxMin];
ordInv=Range[Length[reorder]];
Do[ordInv[[reorder[[i]]]]=i,{i,1,Length[reorder]}];
(*We reorder the algList*)
algListRe=algList[[reorder]];
(*We modify the edge list*)
edgeListRe=edgeList /. Rule[x_,y_]:> Rule[ordInv[[x]],ordInv[[y]]];
(*We output the modified algList, and edgeList, and length of maximal and minimal lists*)
{algListRe,edgeListRe,Length[maxList],Length[minList]}
]



(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$PrintLie",{"Display","g) A semi-simple lie algebra.","A string","Outputs g in a nice form for display in mathematica."}];
Flocci$PrintLie[s_]:=Which[Flocci$TypeAQ[s],"su("<>ToString[Flocci$Rank[s]+1]<>")",Flocci$TypeBQ[s],"so("<>ToString[2*Flocci$Rank[s]+1]<>")",Flocci$TypeCQ[s],"sp("<>ToString[2*Flocci$Rank[s]]<>")",Flocci$TypeDQ[s],"so("<>ToString[2*Flocci$Rank[s]]<>")",Flocci$TypeG2Q[s],"G2",Flocci$TypeF4Q[s],"F4",Flocci$TypeE6Q[s],"E6",Flocci$TypeE7Q[s],"E7",Flocci$TypeE8Q[s],"E8",Flocci$TypeU1Q[s],"u(1)"];
Flocci$PrintLie[g_List]:=StringRiffle[Map[Flocci$PrintLie,g],"\[CirclePlus]"]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$PrintWeights",{"Display","g) A semi-simple lie algebra.\n hw) A list of weights","A list of strings and quantities to display","Gives the backbone of the structure needed to display hw in a nice form."}];

Flocci$PrintWeights[g_,hw_]:=Module[{partitioned,dimArray,listWeights,dimArrayT,irrepList,repList},
(*We partition the irreps based on the rank of g, and find the transpose*)
partitioned=Map[TakeList[#,Flocci$Rank[g]]&,hw]//Transpose;
(*We create an array of dimensions of irreps, and place bars on them if certain conditions are met.*)
dimArrayT=Table[If[(Flocci$TypeAQ[g[[i]]]&&!OrderedQ[{Reverse[p],p}])||(Flocci$TypeDQ[g[[i]]]&&!OrderedQ[{Take[p,{-2,-1}],Take[p,{-2,-1}]}]),OverBar[Flocci$Dim[g[[i]],p]],If[!Flocci$TypeU1Q[g[[i]]],Flocci$Dim[g[[i]],p],p[[1]]]]
,{i,1,Length[g]},{p,partitioned[[i]]}];
dimArray=dimArrayT//Transpose;
(*Irreps are written as (...,...,..)*)
irrepList=Map[Append[Prepend[Riffle[#,","],"("],")"]&,dimArray];
(*Reps are written as (...,...,..)\[CirclePlus](...,...,..)\[CirclePlus](...,...,..)*)
repList=Riffle[irrepList,"\[CirclePlus]"]//Flatten;

repList
]
Flocci$PrintWeights[{A1,A2,U1},{{1,1,0,-3},{2,0,1,-2}}]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$MathematicaDisplay",{"Display","output) The output of SuperFlocci.","-","Prints the output in mathematica."}];
Flocci$MathematicaDisplay[output_]:=Module[{inputg,delim,input\[CapitalPhi],dateTime,algList,edgeList,vertices,edgesV,graph,graphRaw,reorder,ordInv,printAlg,algListRe,edgeListRe,noMax,noMin},
(*We extract the data from output*)
inputg=output[[1]];
input\[CapitalPhi]=output[[2]];
algList=output[[3]];
edgeList=output[[4]];
dateTime=output[[7]];
(*We make the graph*)
vertices= Range[Length[algList]];
{algListRe,edgeListRe,noMax,noMin}=Flocci$MaxMinOutputReorder[output];
(*We create a delimiter*)
delim="_______________________________________________________________";
(*We start printing outputs*)
Print[delim];
Print[delim];
Print["SuperFlocci Output"];
Print[Style["Program by: Andrew Gomes, Maximillian Ruhdorfer, and Joseph Tooby-Smith. 2022",Italic]];
Print[delim];
Print["Input algebra: ",Flocci$PrintLie[inputg]];
Print@@Join[{"Input representation: "},Flocci$PrintWeights[inputg,Map[Flatten,input\[CapitalPhi]]]];
Print["Date of generation: "<>dateTime];
Print[delim];
Print["Total number of extensions: ",Length[algList]];
Print["Of which are maximal: ",noMax];
Print["Of which are minimal: ",noMin];
Print[delim];
Print["Visual display of data: "];
If[Length[edgeListRe]<= 500,
graph=Graph[vertices,edgeListRe[[All,1]],VertexLabels->None,VertexShapeFunction->(Text[Framed[Style[DisplayForm[#2],Black,8],Background->Which[1<= #2<= noMax,LightRed,noMax+1<= #2<= noMax+noMin,LightGreen,True,LightGray],FrameStyle->Gray,FrameMargins->3],#1]&),ImageSize->Large,GraphLayout->"LayeredDigraphEmbedding"];
Print[graph],"Graph too big for printing"];
Print[delim];
Print["Maximal algebras: "];
printAlg[i_]:=Print@@Join[{ToString[i]<>") ",Flocci$PrintLie[algListRe[[i,1]]]," "},Flocci$PrintWeights[algListRe[[i,1]],algListRe[[i,2]]]];
Do[printAlg[i],{i,1,noMax}];
Print[delim];
Print["Minimal algebras: "];
Do[printAlg[i],{i,noMax+1,noMax+noMin}];
Print[delim];
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$LieAlgebraLatex"}];
Flocci$LieAlgebraLatex::tag="Display";
Flocci$LieAlgebraLatex::input="simple Lie algebra s or semi-simple Lie algebra {s1,s2,...}.";
Flocci$LieAlgebraLatex::output="Lie algebra formatted in Latex.";
Flocci$LieAlgebraLatex::description="Formats Lie algebra in Latex";
Flocci$LieAlgebraLatex[s_]:=Which[Flocci$TypeAQ[s],"\\mathfrak{su}("<>ToString[Flocci$Rank[s]+1]<>")",Flocci$TypeBQ[s],"\\mathfrak{so}("<>ToString[2*Flocci$Rank[s]+1]<>")",Flocci$TypeCQ[s],"\\mathfrak{sp}("<>ToString[2*Flocci$Rank[s]]<>")",Flocci$TypeDQ[s],"\\mathfrak{so}("<>ToString[2*Flocci$Rank[s]]<>")",Flocci$TypeG2Q[s],"G_2",Flocci$TypeF4Q[s],"F_4",Flocci$TypeE6Q[s],"E_6",Flocci$TypeE7Q[s],"E_7",Flocci$TypeE8Q[s],"E_8",Flocci$TypeU1Q[s],"\\mathfrak{u}(1)"];
Flocci$LieAlgebraLatex[g_List]:=Module[{s},StringRiffle[Table[If[s[[2]]==1,Flocci$LieAlgebraLatex[s[[1]]],Flocci$LieAlgebraLatex[s[[1]]]<>"^{\\oplus "<>ToString[s[[2]]]<>"}"],{s,Tally[g]}]," \\oplus "]]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$IrrepLatex"}];
Flocci$IrrepLatex::tag="Display";
Flocci$IrrepLatex::input="g: Lie algebra in the form {s1,s2,...} \nhw: highest weights in the format {hw1,hw2,...}.";
Flocci$IrrepLatex::output="Irreps formatted in Latex in the form (dim1,dim2,...)\[ImplicitPlus].";
Flocci$IrrepLatex::description="Formats irreps in Latex in terms of their dimension.";
Flocci$IrrepLatex[g_,hw_]:=Module[{partitioned,dimArray,listWeights,dimArrayT,irrepList,repList,irrepListMult,irrep},
(*We partition the irreps based on the rank of g, and find the transpose*)
partitioned=Map[TakeList[#,Flocci$Rank[g]]&,hw]//Transpose;
(*We create an array of dimensions of irreps, and place bars on them if certain conditions are met.*)
dimArrayT=Table[If[(Flocci$TypeAQ[g[[i]]]&&!OrderedQ[{Reverse[p],p}])||(Flocci$TypeDQ[g[[i]]]&&!OrderedQ[{Take[p,{-2,-1}],Take[p,{-2,-1}]}]),"\\mathbf{\\overline{"<>ToString[Flocci$Dim[g[[i]],p]]<>"}}",If[!Flocci$TypeU1Q[g[[i]]],"\\mathbf{"<>ToString[Flocci$Dim[g[[i]],p]]<>"}",ToString[p[[1]]]]]
,{i,1,Length[g]},{p,partitioned[[i]]}];
dimArray=dimArrayT//Transpose;
(*Irreps are written as (...,...,..) if Length[g]>1 *)
If[Length[g]>1,
irrepList=Map["("<>StringRiffle[#," , "]<>")"&,dimArray];,
irrepList=Map[StringRiffle[#," , "]&,dimArray];
];
irrepListMult=Tally[irrepList];
(*Reps are written as (...,...,..)\[CirclePlus](...,...,..)\[CirclePlus](...,...,..)*)
repList=StringRiffle[Table[If[irrep[[2]]==1,irrep[[1]],irrep[[1]]<>"^{\\oplus "<>ToString[irrep[[2]]]<>"}"],{irrep,irrepListMult}],"\\oplus "];

Return[repList]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"Flocci$TableLatex"}];
Flocci$TableLatex::tag="Display";
Flocci$TableLatex::input="heading: heading for the table as string. If it is a list it assumes it is a composite table. \ntableData: Lie algebras and representations in output format {{{s1,s2,...},{hw1,hw2,...},projection matrix},...}. \ncaption: String of Latex code for table caption. \nlabel: String label for hyperlinks in the pdf file. \noffset: Integer, offset for numbering of algebras. \nlink: Boolean, if True it generates hyperlinks to details of embeddings.";
Flocci$TableLatex::output="String of Latex code to generate Table.";
Flocci$TableLatex::description="Generates Latex code for table of Lie Algebras and Irreps.";
Flocci$TableLatex[heading_,tableData_,caption_,label_,offset_,link_:False]:=Module[{tableString,i,separator,counter},
(*Initialize Latex Table*)
separator="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";
tableString="
\\renewcommand{\\arraystretch}{1.5} 
\\fontsize{8}{9.2}\\selectfont
\\begin{xltabular}{\\linewidth}{| c | B{6cm} | V{12cm} |} \\hline
\\multicolumn{3}{|c|}{\\small "<>heading<> " } \\\\ \\hline
& {\\small Algebra}&\\small Fermion representations corresponding to $\\beta$ \\\\ \\hline 

 \\endfirsthead
  
 \\hline
\\multicolumn{3}{|c|}{\\small "<>heading<> " continued} \\\\ \\hline
& {\\small Algebra}&\\small Fermion representations corresponding to $\\beta$ \\\\ \\hline 

 \\endhead
  
 \\endfoot \n";

counter=1+offset;
(*Loop through algebras and construct table*)
Do[tableString=tableString<>separator<>If[link,"\\hyperlink{alg"<>ToString[counter]<>"}{"<>ToString[counter]<>"}",ToString[counter]]<>" & $"<>Flocci$LieAlgebraLatex[tableData[[i,1]]]<>"$ & $"<>Flocci$IrrepLatex[tableData[[i,1]],tableData[[i,2]]]<>"$ \\\\ \\hline \n";
counter=counter+1;
,{i,1,Length[tableData]}];

(*Write Latex Table Footer*)
tableString=tableString<>separator<>"
\\caption{\\label{"<>label<>"} "<>caption<>"}
\\end{xltabular}
";
Return[tableString];
];

Flocci$TableLatex[heading_List,tableData_,caption_,label_,offset_,link_:False]:=Module[{tableString,i,separator,j,counter},
(*Initialize Latex Table*)
separator="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n";
tableString="
\\renewcommand{\\arraystretch}{1.5} 
\\fontsize{8}{9.2}\\selectfont
\\begin{xltabular}{\\linewidth}{| c | B{6cm} | V{12cm} |} \\hline
\\multicolumn{3}{|c|}{\\small "<>heading[[1]]<> " } \\\\ \\hline
& {\\small Algebra}&\\small Fermion representations corresponding to $\\beta$ \\\\ \\hline 

 \\endfirsthead
  
 \\hline
& {\\small Algebra}&\\small Fermion representations corresponding to $\\beta$ \\\\ \\hline 

 \\endhead
  
 \\endfoot \n";

(*Loop through algebras and construct table*)
counter=1+offset;
Do[
If[j>1,tableString=tableString<>separator<>separator<>"\\multicolumn{3}{|c|}{\\small "<>heading[[j]]<> " } \\\\ \\hline"<>separator<>separator];
Do[tableString=tableString<>separator<>If[link,"\\hyperlink{alg"<>ToString[counter]<>"}{"<>ToString[counter]<>"}",ToString[counter]]<>" & $"<>Flocci$LieAlgebraLatex[tableData[[j,i,1]]]<>"$ & $"<>Flocci$IrrepLatex[tableData[[j,i,1]],tableData[[j,i,2]]]<>"$ \\\\ \\hline \n";
counter++;,{i,1,Length[tableData[[j]]]}],{j,1,Length[tableData]}];

(*Write Latex Table Footer*)
tableString=tableString<>separator<>"
\\caption{\\label{"<>label<>"} "<>caption<>"}
\\end{xltabular}
";
Return[tableString];
];


(* ::Input::Initialization:: *)
(*Flocci$FunctionListAdd[{"Flocci$TableLatex"}];
Flocci$TableLatex::tag="Display";
Flocci$TableLatex::input="heading: heading for the table as string. If it is a list it assumes it is a composite table. \ntableData: Lie algebras and representations in output format {{{s1,s2,...},{hw1,hw2,...},projection matrix},...}. \ncaption: String of Latex code for table caption. \nlabel: String label for hyperlinks in the pdf file.";
Flocci$TableLatex::output="String of Latex code to generate Table.";
Flocci$TableLatex::description="Generates Latex code for table of Lie Algebras and Irreps.";*)
(*Flocci$ListLatex22[out_]:=Module[{outt,string,separator,inpAlg,tensorproduct,nonmaxminembeddings},
separator="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n";(*tensorproduct, nonmaxminembeddings*)

tensorproduct="Both";(*Both, Dim, HW, None*)
nonmaxminembeddings=True;

outt=Flocci$MaxMinOutputReorder[out];
inpAlg=out[[1]];
string="Input algebra: $"<>Flocci$LieAlgebraLatex[inpAlg]<>"$\n\n"<>separator;

string=string
<>Flocci$ListLatex[outt,inpAlg,"Maximal Algebras",{1,outt[[3]]},True,tensorproduct]
<>Flocci$ListLatex[outt,inpAlg,"Minimal Algebras",{outt[[3]]+1,outt[[3]]+outt[[4]]},False,tensorproduct];
If[nonmaxminembeddings,
string=string<>Flocci$ListLatex[outt,inpAlg,"Neither Maximal nor Minimal Algebras",{outt[[3]]+outt[[4]]+1,Length[outt[[1]]]},True,tensorproduct];
];

Return[string]
];*)

Flocci$ListLatex[outt_,inpAlg_,title_,range_,inclRhos_,tensorproduct_,label_,QRCode_]:=Module[{string,separator,tens},
separator="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n";

string="\\subsection*{"<>title<>"}\n~\\\\\n";
Do[
string=string<>separator<>"\\noindent\\rule{0.5\\textwidth}{0.5pt}~\\\\ \n\\textbf{\\underline{Algebra \\hypertarget{alg"<>ToString[id]<>"}{"<>ToString[id]<>"}:}} $"<>Flocci$LieAlgebraLatex[outt[[1,id,1]]]<>"$\\\\\n~\\\\\n"(*<>"\n\n\\vspace{2mm}\n\n"*);
Do[
string=string<>"$"<>Flocci$IrrepLatex[outt[[1,id,1]],{irrep}]<>" = "<>Flocci$ParenthRep[irrep//ToString] <>" \\rightarrow ("<>StringRiffle[Flocci$ExtractHighestWeights[inpAlg,Flocci$WeightSystemFromFlat[outt[[1,id,1]],irrep].Transpose[outt[[1,id,3]]]]/.label,","]<>")$\\\\\n%\n";
,{irrep,outt[[1,id,2]]}];

string=string<>"~\\\\\n";

(*All tensor products of irrep pairs*)
If[tensorproduct!="None",
tens=DeleteDuplicates[Flatten[Flocci$TensorProduct[outt[[1,id,1]],#[[1]],#[[2]]]&/@Tuples[outt[[1,id,2]],2],1]];
string=string(*<>"\\vspace{2mm}\n\n"*)<>"Tensor products of irrep pairs:\\\\\n";
Do[
string=string<>"$"<>If[(tensorproduct=="Both")||(tensorproduct=="Dim"),Flocci$IrrepLatex[outt[[1,id,1]],{irrep}],""]<>If[tensorproduct=="Both"," = ",""]<>If[(tensorproduct=="Both")|| (tensorproduct=="HW"),Flocci$ParenthRep[irrep//ToString] ,""]<>"$,\\\\ \n";
,{irrep,tens}];
];

string = string<>"~\\\\\n%\n\\emph{Projection matrix down to input algebra:}:\n\\begin{flalign*}\n"<>(outt[[1,id,3]]//TeXForm//ToString)<>"\n";If[QRCode===True,string=string<>"&&\\qrcode[height=0.5in]{"<>StringReplace[outt[[1,id,3]]//InputForm//ToString,{"{"-> "\{","}"-> "\}"}]<>"}";];
string=string<>"\\end{flalign*}\n~\\\\\n";
If[inclRhos,
string = string<>"\\emph{Projection matrices down to direct child algebras:}:";
Do[
If[pcrel[[1]][[1]]!=id,Continue[]];
string=string<>"\n\\begin{flalign*}{\\text{-~Algebra \\hyperlink{alg"<>ToString[pcrel[[1]][[2]]]<>"}{"<>ToString[pcrel[[1]][[2]]]<>"} }("<>Flocci$LieAlgebraLatex[outt[[1,pcrel[[1]][[2]],1]]]<>") : }"<>(pcrel[[2]]//TeXForm//ToString);
If[QRCode===True,string=string<>"&&\\qrcode[height=0.5in]{"<>StringReplace[pcrel[[2]]//InputForm//ToString,{"{"-> "\{","}"-> "\}"}]<>"}";];
string=string<>"\\end{flalign*} \n";
,{pcrel,outt[[2]]}];
string = string<>"\n%\n";
];
string=string<>separator;
,{id,Range@@range}];

Return[string]
];

Flocci$ParenthRep[text_]:=StringReplace[text,{"{"->"(","}"->")"}];


(*to remove*)
Flocci$TensorProduct[g_,\[Lambda]1_,\[Lambda]2_]:=Module[{ws1,ws2,plus},ws1=Flocci$WeightSystemFromFlat[g,\[Lambda]1];
ws2=Flocci$WeightSystemFromFlat[g,\[Lambda]2];
plus=Flatten[Outer[Plus,ws1,ws2,1],1];
Flocci$ExtractHighestWeights[g,plus]]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"FlocciOutput"}];
FlocciOutput::tag="User";
FlocciOutput::input="output: output of SuperFlocci\nOptional Arguments: \n-display (False): True or False, visualization of SuperFlocci output. \n-save (False): True or False, save mathematica output. \n-filename (\"auto\"): string, filename for mathematica and/or Latex output relative to notebook directory.\n-labelrep (\"auto\"): replacement rules, string labels for user representations in the format {{1,0,0,...}->\"label1\",...}. \n-latex (False): if not false produces Latex summary with inputs specified as String as e.g. latex->{\"maxtable\"}\n----\"maxtable\": table with all maximal algebras\n----\"mintable\": table with all minimal algebras\n----\"alltables\": tables with all algebras\n----\"embeddingsdetail\": detailed overview of all embeddings.\n----\"tensorproduct\": gives all bilinear tensorproducts of representations (only in combination with \"embeddingsdetail\")\n----\"onlymaxminembeddings\": restricts embeddingsdetail to maximal and minimal embeddings (only in combination with \"embeddingsdetail\")\n----\"projectiontree\": outputs projection matrices between algebras on same branch of tree (only in combination with \"embeddingsdetail\" and is neglected for \"onlymaxminembeddings\")\n----\"QR\": outputs QR Code which encodes the projection matrices (only in combination with \"embeddingsdetail\")";
FlocciOutput::output="Visualisation of output and option Latex or data file.";
FlocciOutput::description="Outputs and saves data generated by SuperFlocci";
FlocciOutput[output_,OptionsPattern[{display->True,filename->"auto",save->False,labelrep->"auto",latex->False}]]:=Module[{LatexHead,LatexBottom,filenameFinal,latexOptions,latexCode,file,outputReord,separator,inpAlg,tensProd,outputData,rhoMatrices,labelList,wsFlattened,repMult,i,currLabel,userLabel,currPos,userLabelCount,j,QRCode},

inpAlg=output[[1]];
wsFlattened=Flatten/@output[[2]];

separator="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n";
(* Define Head and Bottom of Latex document *)
LatexHead="\\documentclass{article}
\\usepackage{amscd}
\\usepackage{amsmath, bbm} 
\\usepackage{amsfonts}
\\usepackage{amssymb}
\\usepackage{hyperref}
\\usepackage{xltabular}
\\usepackage{varwidth}
\\usepackage[margin=0.6in]{geometry}
\\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=black,      
    urlcolor=black,
    citecolor = black,
}
\\usepackage{qrcode}
\\makeatletter
\\newcolumntype{B}[1]{%
  >{\\begin{varwidth}[t]{#1}\\narrowragged\\let\\\\\\tabularnewline}%
  r%
  <{\\@finalstrut\\@arstrutbox\\end{varwidth}}}
\\makeatother
 
\\begin{document}
\\title{Superfloccinaucinihilipilification - output}
\\author{\\emph{Program by: }Andrew Gomes, Maximillian Ruhdorfer, and Joseph Tooby-Smith}
\\maketitle
";

(* Generate filename is none is given *)
If[OptionValue[filename]=="auto",filenameFinal="Flocci_"<>DateString["ISODateTime"],filenameFinal=ToString[OptionValue[filename]]];

LatexBottom="\\end{document}";
(* If save = True save Mathematica output to filename *)
If[OptionValue[save]===True,Print["Saving the Mathematica output to "<>NotebookDirectory[]<>filenameFinal<>".m"];
FlocciOutputData=output;
Save[NotebookDirectory[]<>filenameFinal<>".m",FlocciOutputData]
];

(* Display output if display==True *)
If[OptionValue[display]===True,Flocci$MathematicaDisplay[output]];



(* reorder output *)
outputReord=Flocci$MaxMinOutputReorder[output];

(* If latex is not False generate Latex file with options *)
If[!(OptionValue[latex]===False),
Print["Creating Latex Output"];
If[ListQ[OptionValue[latex]],
(* check if user specified labels for the fermions and if not generate them automatically *)
repMult=Tally[wsFlattened];
labelList={};
i=1;
If[OptionValue[labelrep]==="auto",
(* generate labels automatically *)
Do[
currLabel="\\psi_{"<>StringRiffle[Table[ToString[i+j],{j,0,rep[[2]]-1}],","]<>"}";
i=i+rep[[2]];
AppendTo[labelList,rep[[1]]->currLabel]
,{rep,repMult}],
(* use user specified labels *)
userLabel=OptionValue[labelrep];
userLabelCount=Tally[First/@DeleteDuplicates[userLabel]];
Print[userLabelCount];
Do[
(* check if userLabel contains all representations in the input *)
If[MemberQ[userLabelCount[[All,1]],rep[[1]]],
(* if representation is contained check how many labels are specified for this representation *)
currPos=Position[userLabelCount[[All,1]],rep[[1]]][[1,1]];
(*If[userLabelCount[[currPos,2]]>1,
For[j=userLabelCount[[currPos,2]],j<rep[[2]],j++,
AppendTo[userLabel,rep[[1]]->"\\psi_{"<>ToString[i]<>"}"];
i=i+1;
]];*)
For[j=1,j<=rep[[2]],j++,
If[userLabelCount[[currPos,2]]<j,
AppendTo[userLabel,rep[[1]]->"\\psi_{"<>ToString[i]<>"}"];
i=i+1];
]
,
(* if representation is not contained add automatic labels *)
currLabel="\\psi_{"<>StringRiffle[Table[ToString[i+j],{j,0,rep[[2]]-1}],","]<>"}";
i=i+rep[[2]];
AppendTo[userLabel,rep[[1]]->currLabel];
]
,{rep,repMult}];
Print[userLabel];
labelList= Map[#[[1,1]]->StringRiffle[DeleteDuplicates[If[Length[#]>1,#[[All,2]],{#[[1,2]]}]],"/"]&,SplitBy[Sort[userLabel],#[[1]]&]];
];

latexOptions=OptionValue[latex];
latexCode=LatexHead<>separator<>"\n";
latexCode=latexCode<>"\\begin{abstract}\nThis document was automatically generated by the code \\texttt{Superfloccinaucinihilipilification} on "<>output[[7]]<>". If you use the data generated by this code in a publication please cite\\\\~\\\\\n%\n\\textit{Citation information.}\\\\~\\\\\n%\nThe current document contains tables of and details on semi-simple extensions of the gauge algebra and fermion representations specified in Section~\\ref{sec:user}.\n\\end{abstract}\\tableofcontents\n\\section{User Input}\\label{sec:user}\n~\\\\";
latexCode=latexCode<>"Input algebra: $"<>Flocci$LieAlgebraLatex[inpAlg]<>"$\\\\\nInput representations:\\\\\n";

Do[
latexCode=latexCode<>"$"<>ToString[irrep/.labelList]<>"\\rightarrow "<>Flocci$IrrepLatex[output[[1]],{irrep}]<>" = "<>Flocci$ParenthRep[irrep//ToString]<>"$\\\\\n%\n";
,{irrep,DeleteDuplicates[wsFlattened]}];

(* Add summary tables if requested *)
If[MemberQ[latexOptions,"alltables"],
(* add all tables *)
latexCode=latexCode<>"\\section{Tables}\n";
latexCode=latexCode<>(*"\\setcounter{table}{-1}\n"<>*)Flocci$TableLatex[{"Maximal","Minimal"},{outputReord[[1,1;;outputReord[[3]]]],outputReord[[1,outputReord[[3]]+1;;outputReord[[3]]+outputReord[[4]]]]},"All maximal and minimal algebras.","tab:MinMax",0,If[MemberQ[latexOptions,"embeddingsdetail"],True,False]]<>separator<>(*"\\setcounter{table}{0}\n"<>*)Flocci$TableLatex["Non-Maximal and Non-Minimal Algebras",outputReord[[1,outputReord[[3]]+outputReord[[4]]+1;;]],"All algebras which are neither maximal nor minimal.","tab:nonMinMax",outputReord[[3]]+outputReord[[4]],If[MemberQ[latexOptions,"embeddingsdetail"]&&!MemberQ[latexOptions,"onlymaxminembeddings"],True,False]],
If[MemberQ[latexOptions,"maxtable"]&&MemberQ[latexOptions,"mintable"],
(* add max and min tables *)
latexCode=latexCode<>"\\section{Tables}\n";
latexCode=latexCode<>(*"\\setcounter{table}{-1}\n"<>*)Flocci$TableLatex[{"Maximal","Minimal"},{outputReord[[1,1;;outputReord[[3]]]],outputReord[[1,outputReord[[3]]+1;;outputReord[[3]]+outputReord[[4]]]]},"All maximal and minimal algebras.","tab:MinMax",0,If[MemberQ[latexOptions,"embeddingsdetail"],True,False]],
If[MemberQ[latexOptions,"maxtable"],
latexCode=latexCode<>"\\section{Tables}\n";
latexCode=latexCode<>(*"\\setcounter{table}{-1}\n"<>*)Flocci$TableLatex["Maximal Algebras",outputReord[[1,1;;outputReord[[3]]]],"All maximal algebras.","tab:Max",0,If[MemberQ[latexOptions,"embeddingsdetail"],True,False]]];
If[MemberQ[latexOptions,"mintable"],
latexCode=latexCode<>"\\section{Tables}\n";
latexCode=latexCode<>(*"\\setcounter{table}{-1}\n"<>*)Flocci$TableLatex["Minimal",outputReord[[1,outputReord[[3]]+1;;outputReord[[3]]+outputReord[[4]]]],"All minimal algebras.","tab:Min",outputReord[[3]],If[MemberQ[latexOptions,"embeddingsdetail"],True,False]]]]];
latexCode=latexCode<>separator;


(* check if detailed information about embeddings is requested and add it if required *)
If[MemberQ[latexOptions,"embeddingsdetail"],
If[MemberQ[latexOptions,"tensorproduct"],tensProd="Both"(*Both, Dim, HW, None*),tensProd=None];
If[MemberQ[latexOptions,"projectiontree"],rhoMatrices=True,rhoMatrices=False];
If[MemberQ[latexOptions,"QR"],QRCode=True,QRCode=False];
latexCode=latexCode<>"\\section{Details on Embeddings}\n%\n \\setlength{\\arraycolsep}{2pt} % General space between cols (6pt standard)
\\renewcommand{\\arraystretch}{1} % General space between rows (1 standard)\n";
latexCode=latexCode<>Flocci$ListLatex[outputReord,inpAlg,"Maximal Algebras",{1,outputReord[[3]]},rhoMatrices,tensProd,labelList,QRCode]
<>Flocci$ListLatex[outputReord,inpAlg,"Minimal Algebras",{outputReord[[3]]+1,outputReord[[3]]+outputReord[[4]]},False,tensProd,labelList,QRCode];
If[!MemberQ[latexOptions,"onlymaxminembeddings"],latexCode=latexCode<>Flocci$ListLatex[outputReord,inpAlg,"Neither Maximal nor Minimal Algebras",{outputReord[[3]]+outputReord[[4]]+1,Length[outputReord[[1]]]},False,tensProd,labelList,QRCode]];
];

(* add bottom and save file *)
latexCode=latexCode<>LatexBottom;
Print["Generating Latex file at "<>NotebookDirectory[]<>filenameFinal<>".tex"];
If[FileExistsQ[NotebookDirectory[]<>filenameFinal<>".tex"],Print["File "<>NotebookDirectory[]<>filenameFinal<>".tex already exists. Overwriting it."];DeleteFile[NotebookDirectory[]<>filenameFinal<>".tex"]];
file=CreateFile[NotebookDirectory[]<>filenameFinal<>".tex"];
WriteString[file,latexCode];
Close[file];
];
]
]


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"SuperFlocci"}];
SuperFlocci::tag="User";
SuperFlocci::input="userg) A reductive Lie algebra e.g. {A2,A1,U1}.\nuser\[CapitalPhi]) The weight system of the fermionic representations.\nOptional Arguments:\n-Checkpoint (False): The file name where checkpointed data should be saved to.\n-CheckpointUpFreq (1000): How frequently checkpoints should be carried out on the up-part of the program.\n-StartFromCheckpoint (True): If checkpoint file given, and already exists, start from saved checkpoint.\n-ClearDataFreq (1000): How often Cache should be cleared.\n-SimpleIdealConstraint (\[Infinity]): An upper limit on the number of simple ideals of nodes generated.\n-DetailedProgressData (False): Put to true if want more detailed progress data when running code.";
SuperFlocci::output="A list containing:\n The inputed Lie algebra\n The inputed fermonic reps \n The list of semi-simple extensions \n The list of edges between these extensions \n A collection of timing data \n The date and time that the function was generated.";
SuperFlocci::description="The main function of our program. This takes the user input, and generates the output data.";

SuperFlocci[userg_,user\[CapitalPhi]_,OptionsPattern[{Checkpoint->False,CheckpointUpFreq->1000,StartFromCheckpoint->True,ClearDataFreq->1000,ProjectionMatrixList-> False,SimpleIdealConstraint-> \[Infinity],DetailedProgressData-> False,ExtendedKappaCheck-> True}]]:=Module[{user\[CapitalPhi]NF,n,ord,g,\[CapitalPhi]t,FlocciOutput,U1sOnlyBool,algList,edList,testCond,pos,adjust,TotalTimeOfFunction},
TotalTimeOfFunction=AbsoluteTiming[(
(*We read in optional data to global varibles*)
Flocci$Checkpoint$FileName=OptionValue[Checkpoint];
Flocci$Checkpoint$CheckpointUpFreq=OptionValue[CheckpointUpFreq];
Flocci$Checkpoint$StartFromCheckpoint=OptionValue[StartFromCheckpoint];
Flocci$ProjectionMatrixList=OptionValue[ProjectionMatrixList];
Flocci$DeleteStoredDataCounter=OptionValue[ClearDataFreq];
Flocci$SimpleIdealConstraint=OptionValue[SimpleIdealConstraint];
Flocci$DetailedProgressData=OptionValue[DetailedProgressData];
Flocci$PerformExtendingChecks=OptionValue[ExtendedKappaCheck];
(*We find the rank of the algebra*)
n=Total[Flocci$Rank[userg]];
(*First we partition user\[CapitalPhi] if entered in the flat version*)
user\[CapitalPhi]NF=If[Head[user\[CapitalPhi][[1,1]]]===List,user\[CapitalPhi],Map[TakeList[#,Flocci$Rank[userg]]&,user\[CapitalPhi]]];
(*We sort the user algebra*)
ord=userg//Ordering;
g=userg[[ord]];
\[CapitalPhi]t=user\[CapitalPhi]NF[[All,ord]];
(*If we just have U(1)'s then we change the input algebra to su(2) x u(1)..., and add (1,0,...) to the hws.
This allows us to run our program without major modification. In the end we just extract those algebras which have the trivial su(2)\[Rule]su(2) embedding.*)
U1sOnlyBool=False;
If[Count[g,U1]==Length[g],
Print["The inserted algebra only contains u(1)'s. A trick is made by replacing the algebra with su(2) x u(1)x...."];
U1sOnlyBool=True;
g=Prepend[g,A1];
\[CapitalPhi]t=Append[Map[Prepend[#,{0}]&,\[CapitalPhi]t],Join[{{1}},ConstantArray[{0},Length[g]-1]]];
];
(*We set up the state, also the old state is clared*)
Flocci$InitializeInputData[g,\[CapitalPhi]t];

(*We upload checkpointed data, if need be*)
If[!(Flocci$Checkpoint$FileName===False) &&Flocci$Checkpoint$StartFromCheckpoint &&FileExistsQ[Flocci$Checkpoint$FileName<>".mx"], Flocci$Checkpoint$Restart];
(*We then run the code*)
Flocci$GenerateGraph[g,\[CapitalPhi]t];
(*We extract the right algebra and edge list*)
algList=If[Flocci$User$U1sPresentBool,Flocci$RRNode$AlgebraList,Flocci$SSNode$AlgebraList];
edList=If[Flocci$User$U1sPresentBool,Flocci$RREdge$EdgeList,Flocci$SSEdge$EdgeList];
(*If U1sOnlyBool is true, then we need to modify these, to remove the su(2) part we added.*)
If[U1sOnlyBool,
(*We extract the positions with a trivial su(2) embedding*)
testCond[{g1_,\[Beta]t_,\[CapitalLambda]\[Alpha]t_}]:=g[[1]]==A1&&\[CapitalLambda]\[Alpha]t[[1,1]]==1 && AllTrue[Delete[\[CapitalLambda]\[Alpha]t[[1]],1],#==0&]&&AllTrue[Delete[Transpose[\[CapitalLambda]\[Alpha]t][[1]],1],#==0&]&&\[Beta]t[[-1,1]]==1 && AllTrue[Delete[\[Beta]t[[-1]],1],#==0&]&&AllTrue[Delete[Transpose[\[Beta]t][[1]],-1],#==0&];
pos=Position[algList,_?(testCond),{1}]//Flatten;
algList=algList[[pos]];
(*We get the relevent infor from algList*)
adjust[{g1_,\[Beta]t_,\[CapitalLambda]\[Alpha]t_}]:={Delete[g1,1],Map[Delete[#,1]&,Delete[\[Beta]t,-1]],Map[Delete[#,1]&,Delete[\[CapitalLambda]\[Alpha]t,1]]};
algList=Map[adjust,algList];
(*We adjust the edge list*)
edList=Select[edList,MemberQ[pos,#[[1,1]]]&&MemberQ[pos,#[[1,2]]]&]/.Thread[pos->Range[Length[pos]]];
];)
][[1]];
(*We print the relevent information*)
FlocciOutput={userg,user\[CapitalPhi],algList,edList,TotalTimeOfFunction,Flocci$TimingPrint,DateString[CurrentDate[]]};
Print["Evaluation took a time of: ",TotalTimeOfFunction," seconds"];
FlocciOutput
]


(* ::Input::Initialization:: *)
Flocci$SetDescription["Flocci$CombinatoricsFactor",{"Meta","g) A reductive Lie algebra
nhws) A list of highest weights","An Integer","Gives a rough measure of how difficult the U(1) part of the code will be."}];
Flocci$CombinatoricsFactor[g_,hws_]:=Module[{hwFlat,WS,rank,U1pos,SSpos,gathered,equa,sizes},
hwFlat=Map[Flatten,hws];
WS=Flatten[Map[Flocci$WeightSystemFromFlatU1[g,#]&,hwFlat],1];
rank=Table[g[[i]],{i,1,Length[g]},{j,1,Flocci$Rank[g[[i]]]}]//Flatten;
U1pos=Flatten[Position[rank,U1]];
SSpos=Complement[Range[Length[rank]],U1pos];
gathered=GatherBy[WS,#[[SSpos]]&];
equa=Map[Split[Sort[#]]&,gathered];
sizes=Map[Length,equa,{2}];
Times@@Table[Factorial[Total[s]]/Times@@Factorial[s],{s,sizes}]
];


(* ::Input::Initialization:: *)
Flocci$FunctionListAdd[{"ScanExtensions"}];
ScanExtensions::tag="User";
ScanExtensions::input="g: A reductive Lie algebra e.g. {A2,A1,U1}.\nmaxIrrepDim: An integer corresponding to the maximal dimension of a single irrep. If it is given as a list it is interpreted as the maximal dimension of irreps restricted to the corresponding part of the semi-simple algebra.\nmaxIrrepNumber: An integer specifying the maximal number of additional irreps.\nU1Charges: A list of U(1) charges that should be considered of the form {-1,0,1}. For more than one U(1) this should be of the form {{-1,0,1},{0,2,4},...}.";
ScanExtensions::output="A list containing possible anomaly free extensions for the given algebra in the format {{{algebra},{irrep1,irrep2,...}},...}.";
ScanExtensions::description="Generates possible anomaly free extensions to a given model. This can be used as an input for a scan.";

ScanExtensions[g_,maxIrrepDim_,maxIrrepNumber_,U1Charges_List]:=Module[{BaseIrreps,SSalgebra,u1positions,extensionList,currIrrep,rankList,dimList,SSirrep,anomFreeSSirrep,u1Values,u1ChargesProcessed,algebra,u1Assignments,dimSorted},
(*Check if input is sensible*)
If[maxIrrepNumber<1,Return[{}]];
(*Initialize list in which we collect all anomaly free extensions*)
extensionList={};
algebra=Sort[g];
(*We first find the u1 positions*)
u1positions=Position[algebra,_?(Flocci$TypeU1Q[#]&)];
u1ChargesProcessed=U1Charges;
If[Length[u1positions]>1,If[ListQ[U1Charges[[1]]],If[!(Length[U1Charges]==Length[u1positions]),Print["Please specify U(1) charges for all U(1) factors."];Return[{}]],u1ChargesProcessed=Table[U1Charges,{i,1,Length[u1positions]}]]];
If[Length[u1positions]==1&&!ListQ[U1Charges[[1]]],u1ChargesProcessed={U1Charges}];
u1Values=Tuples[u1ChargesProcessed];
(*We get the semi-simple part*)
SSalgebra=Delete[algebra,u1positions];
(*Find list of irreps for semi-simple part*)
If[ListQ[maxIrrepDim],If[Length[maxIrrepDim]!=Length[SSalgebra],Print["Length of maximal dimensions list has to agree with the number simple factors in the algebra."];Return[{}],
dimSorted=maxIrrepDim[[Ordering[Delete[g,Position[g,_?(Flocci$TypeU1Q[#]&)]]]]];
BaseIrreps=Flatten/@Tuples[MapThread[Flocci$IrrepsLessThenOrEqualDim[{#1},#2,#2]&,{SSalgebra,dimSorted}]];
],
BaseIrreps=Flocci$IrrepsLessThenOrEqualDim[SSalgebra,maxIrrepDim,maxIrrepDim]];

(*One irrep can only be non-anomalous if all U(1)-charges are 0*)
Do[
currIrrep=Join[irrep,ConstantArray[0,Length[u1positions]]];
If[Flocci$AnomalyFreeCheck[algebra,{currIrrep}],AppendTo[extensionList,{algebra,{currIrrep}}]]
,{irrep,BaseIrreps}];
(*Add more irreps*)
Do[
(*Do SS part first*)
SSirrep=Select[DeleteDuplicates[Map[Sort,Tuples[BaseIrreps,numIrrep]]],Flocci$AnomalyFreeCheck[SSalgebra,#]&];
(*Add U(1) charges for all non-anomalous SS representations*)
If[Length[u1positions]>0,
u1Assignments=Tuples[Table[u1Values,{j,1,numIrrep}]];
Do[
Do[
currIrrep=MapThread[Join[#1,#2]&,{irr,u1ch}];
If[Flocci$AnomalyFreeCheck[algebra,currIrrep],AppendTo[extensionList,{algebra,currIrrep}]]
,{u1ch,u1Assignments}]
,{irr,SSirrep}];
,Join[extensionList,Map[{{SSalgebra},#}&,SSirrep]]]
,{numIrrep,2,maxIrrepNumber}];
Return[DeleteDuplicates[Map[{#[[1]],Sort[#[[2]]]}&,extensionList]]];
]


(* ::Input::Initialization:: *)
sm["Q"]={{1},{1,0},{1}};
sm["U"]={{0},{0,1},{-4}};
sm["D"]={{0},{0,1},{2}};
sm["L"]={{1},{0,0},{-3}};
sm["E"]={{0},{0,0},{6}};
sm["N"]={{0},{0,0},{0}};
